"use strict";Object.defineProperty(exports, "__esModule", {value: true});


























var _chunkUV2F4F4Rjs = require('./chunk-UV2F4F4R.js');

// src/EventSource.ts
function makeEventSource() {
  const _onetimeObservers = /* @__PURE__ */ new Set();
  const _observers = /* @__PURE__ */ new Set();
  function subscribe(callback) {
    _observers.add(callback);
    return () => _observers.delete(callback);
  }
  function subscribeOnce(callback) {
    _onetimeObservers.add(callback);
    return () => _onetimeObservers.delete(callback);
  }
  function notify(event) {
    _onetimeObservers.forEach((callback) => callback(event));
    _onetimeObservers.clear();
    _observers.forEach((callback) => callback(event));
  }
  function clear() {
    _onetimeObservers.clear();
    _observers.clear();
  }
  return {
    notify,
    subscribe,
    subscribeOnce,
    clear,
    observable: {
      subscribe,
      subscribeOnce
    }
  };
}

// src/ImmutableRef.ts
function merge(target, patch) {
  let updated = false;
  const newValue = _chunkUV2F4F4Rjs.__spreadValues.call(void 0, {}, target);
  Object.keys(patch).forEach((k) => {
    const key = k;
    const val = patch[key];
    if (newValue[key] !== val) {
      if (val === void 0) {
        delete newValue[key];
      } else {
        newValue[key] = val;
      }
      updated = true;
    }
  });
  return updated ? newValue : target;
}
var ImmutableRef = class {
  constructor() {
    this._ev = makeEventSource();
  }
  get didInvalidate() {
    return this._ev.observable;
  }
  invalidate() {
    if (this._cache !== void 0) {
      this._cache = void 0;
      this._ev.notify();
    }
  }
  get current() {
    var _a;
    return (_a = this._cache) != null ? _a : this._cache = this._toImmutable();
  }
};

// src/MeRef.ts
var MeRef = class extends ImmutableRef {
  constructor(initialPresence) {
    super();
    this._me = _chunkUV2F4F4Rjs.freeze.call(void 0, _chunkUV2F4F4Rjs.compactObject.call(void 0, initialPresence));
  }
  _toImmutable() {
    return this._me;
  }
  patch(patch) {
    const oldMe = this._me;
    const newMe = merge(oldMe, patch);
    if (oldMe !== newMe) {
      this._me = _chunkUV2F4F4Rjs.freeze.call(void 0, newMe);
      this.invalidate();
    }
  }
};

// src/OthersRef.ts
function makeUser(conn, presence) {
  return _chunkUV2F4F4Rjs.freeze.call(void 0, _chunkUV2F4F4Rjs.compactObject.call(void 0, _chunkUV2F4F4Rjs.__spreadProps.call(void 0, _chunkUV2F4F4Rjs.__spreadValues.call(void 0, {}, conn), { presence })));
}
var OthersRef = class extends ImmutableRef {
  constructor() {
    super();
    this._connections = {};
    this._presences = {};
    this._users = {};
  }
  _toImmutable() {
    const users = _chunkUV2F4F4Rjs.compact.call(void 0, 
      Object.keys(this._presences).map(
        (connectionId) => this.getUser(Number(connectionId))
      )
    );
    return _chunkUV2F4F4Rjs.asArrayWithLegacyMethods.call(void 0, users);
  }
  clearOthers() {
    this._connections = {};
    this._presences = {};
    this._users = {};
    this.invalidate();
  }
  _getUser(connectionId) {
    const conn = this._connections[connectionId];
    const presence = this._presences[connectionId];
    if (conn !== void 0 && presence !== void 0) {
      return makeUser(conn, presence);
    }
    return void 0;
  }
  getUser(connectionId) {
    const cachedUser = this._users[connectionId];
    if (cachedUser) {
      return cachedUser;
    }
    const computedUser = this._getUser(connectionId);
    if (computedUser) {
      this._users[connectionId] = computedUser;
      return computedUser;
    }
    return void 0;
  }
  _invalidateUser(connectionId) {
    if (this._users[connectionId] !== void 0) {
      delete this._users[connectionId];
    }
    this.invalidate();
  }
  setConnection(connectionId, metaUserId, metaUserInfo) {
    this._connections[connectionId] = _chunkUV2F4F4Rjs.freeze.call(void 0, {
      connectionId,
      id: metaUserId,
      info: metaUserInfo
    });
    if (this._presences[connectionId] !== void 0) {
      this._invalidateUser(connectionId);
    }
  }
  removeConnection(connectionId) {
    delete this._connections[connectionId];
    delete this._presences[connectionId];
    this._invalidateUser(connectionId);
  }
  setOther(connectionId, presence) {
    this._presences[connectionId] = _chunkUV2F4F4Rjs.freeze.call(void 0, _chunkUV2F4F4Rjs.compactObject.call(void 0, presence));
    if (this._connections[connectionId] !== void 0) {
      this._invalidateUser(connectionId);
    }
  }
  patchOther(connectionId, patch) {
    const oldPresence = this._presences[connectionId];
    if (oldPresence === void 0) {
      return;
    }
    const newPresence = merge(oldPresence, patch);
    if (oldPresence !== newPresence) {
      this._presences[connectionId] = _chunkUV2F4F4Rjs.freeze.call(void 0, newPresence);
      this._invalidateUser(connectionId);
    }
  }
};

// src/ValueRef.ts
var ValueRef = class extends ImmutableRef {
  constructor(initialValue) {
    super();
    this._value = _chunkUV2F4F4Rjs.freeze.call(void 0, _chunkUV2F4F4Rjs.compactObject.call(void 0, initialValue));
  }
  _toImmutable() {
    return this._value;
  }
  set(newValue) {
    this._value = _chunkUV2F4F4Rjs.freeze.call(void 0, newValue);
    this.invalidate();
  }
};
var DerivedRef = class extends ImmutableRef {
  constructor(otherRefs, transformFn) {
    super();
    this._refs = otherRefs;
    this._refs.forEach((ref) => {
      ref.didInvalidate.subscribe(() => this.invalidate());
    });
    this._transform = transformFn;
  }
  _toImmutable() {
    return this._transform(this._refs[0].current, this._refs[1].current);
  }
};

// src/room.ts
var BACKOFF_RETRY_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];
var BACKOFF_RETRY_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];
var HEARTBEAT_INTERVAL = 3e4;
var PONG_TIMEOUT = 2e3;
function makeIdFactory(connectionId) {
  let count = 0;
  return () => `${connectionId}:${count++}`;
}
function log(..._params) {
  return;
}
function isConnectionSelfAware(connection) {
  return connection.state === "open" || connection.state === "connecting";
}
function makeStateMachine(state, config, mockedEffects) {
  const pool = {
    roomId: config.roomId,
    getNode: (id) => state.nodes.get(id),
    addNode: (id, node) => void state.nodes.set(id, node),
    deleteNode: (id) => void state.nodes.delete(id),
    generateId: () => `${getConnectionId()}:${state.clock++}`,
    generateOpId: () => `${getConnectionId()}:${state.opClock++}`,
    dispatch(ops, reverse, storageUpdates) {
      const activeBatch = state.activeBatch;
      if (activeBatch) {
        activeBatch.ops.push(...ops);
        storageUpdates.forEach((value, key) => {
          activeBatch.updates.storageUpdates.set(
            key,
            _chunkUV2F4F4Rjs.mergeStorageUpdates.call(void 0, 
              activeBatch.updates.storageUpdates.get(key),
              value
            )
          );
        });
        activeBatch.reverseOps.push(...reverse);
      } else {
        addToUndoStack(reverse);
        state.redoStack = [];
        dispatchOps(ops);
        notify({ storageUpdates });
      }
    }
  };
  const eventHub = {
    customEvent: makeEventSource(),
    me: makeEventSource(),
    others: makeEventSource(),
    error: makeEventSource(),
    connection: makeEventSource(),
    storage: makeEventSource(),
    history: makeEventSource(),
    storageDidLoad: makeEventSource()
  };
  const effects = mockedEffects || {
    authenticate(auth, createWebSocket) {
      const rawToken = state.token;
      const parsedToken = rawToken !== null && _chunkUV2F4F4Rjs.parseRoomAuthToken.call(void 0, rawToken);
      if (parsedToken && !_chunkUV2F4F4Rjs.isTokenExpired.call(void 0, parsedToken)) {
        const socket = createWebSocket(rawToken);
        authenticationSuccess(parsedToken, socket);
      } else {
        return auth(config.roomId).then(({ token }) => {
          if (state.connection.current.state !== "authenticating") {
            return;
          }
          const parsedToken2 = _chunkUV2F4F4Rjs.parseRoomAuthToken.call(void 0, token);
          const socket = createWebSocket(token);
          authenticationSuccess(parsedToken2, socket);
          state.token = token;
        }).catch(
          (er) => authenticationFailure(
            er instanceof Error ? er : new Error(String(er))
          )
        );
      }
    },
    send(messageOrMessages) {
      if (state.socket === null) {
        throw new Error("Can't send message if socket is null");
      }
      state.socket.send(JSON.stringify(messageOrMessages));
    },
    delayFlush(delay) {
      return setTimeout(tryFlushing, delay);
    },
    startHeartbeatInterval() {
      return setInterval(heartbeat, HEARTBEAT_INTERVAL);
    },
    schedulePongTimeout() {
      return setTimeout(pongTimeout, PONG_TIMEOUT);
    },
    scheduleReconnect(delay) {
      return setTimeout(connect, delay);
    }
  };
  const self = new DerivedRef(
    [state.connection, state.me],
    (conn, me) => isConnectionSelfAware(conn) ? {
      connectionId: conn.id,
      id: conn.userId,
      info: conn.userInfo,
      presence: me
    } : null
  );
  function createOrUpdateRootFromMessage(message) {
    if (message.items.length === 0) {
      throw new Error("Internal error: cannot load storage without items");
    }
    if (state.root) {
      updateRoot(message.items);
    } else {
      state.root = load(message.items);
    }
    for (const key in state.initialStorage) {
      if (state.root.get(key) === void 0) {
        state.root.set(key, state.initialStorage[key]);
      }
    }
  }
  function buildRootAndParentToChildren(items) {
    const parentToChildren = /* @__PURE__ */ new Map();
    let root = null;
    for (const [id, crdt] of items) {
      if (_chunkUV2F4F4Rjs.isRootCrdt.call(void 0, crdt)) {
        root = [id, crdt];
      } else {
        const tuple = [id, crdt];
        const children = parentToChildren.get(crdt.parentId);
        if (children !== void 0) {
          children.push(tuple);
        } else {
          parentToChildren.set(crdt.parentId, [tuple]);
        }
      }
    }
    if (root === null) {
      throw new Error("Root can't be null");
    }
    return [root, parentToChildren];
  }
  function updateRoot(items) {
    if (!state.root) {
      return;
    }
    const currentItems = /* @__PURE__ */ new Map();
    state.nodes.forEach((node, id) => {
      currentItems.set(id, node._serialize());
    });
    const ops = _chunkUV2F4F4Rjs.getTreesDiffOperations.call(void 0, currentItems, new Map(items));
    const result = apply(ops, false);
    notify(result.updates);
  }
  function load(items) {
    const [root, parentToChildren] = buildRootAndParentToChildren(items);
    return _chunkUV2F4F4Rjs.LiveObject._deserialize(root, parentToChildren, pool);
  }
  function _addToRealUndoStack(historyOps) {
    if (state.undoStack.length >= 50) {
      state.undoStack.shift();
    }
    state.undoStack.push(historyOps);
    onHistoryChange();
  }
  function addToUndoStack(historyOps) {
    if (state.pausedHistory !== null) {
      state.pausedHistory.unshift(...historyOps);
    } else {
      _addToRealUndoStack(historyOps);
    }
  }
  function notify({
    storageUpdates = /* @__PURE__ */ new Map(),
    presence = false,
    others: otherEvents = []
  }) {
    if (otherEvents.length > 0) {
      const others = state.others.current;
      for (const event of otherEvents) {
        eventHub.others.notify({ others, event });
      }
    }
    if (presence) {
      eventHub.me.notify(state.me.current);
    }
    if (storageUpdates.size > 0) {
      const updates = Array.from(storageUpdates.values());
      eventHub.storage.notify(updates);
    }
  }
  function getConnectionId() {
    const conn = state.connection.current;
    if (isConnectionSelfAware(conn)) {
      return conn.id;
    } else if (state.lastConnectionId !== null) {
      return state.lastConnectionId;
    }
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function apply(ops, isLocal) {
    const result = {
      reverse: [],
      updates: {
        storageUpdates: /* @__PURE__ */ new Map(),
        presence: false
      }
    };
    const createdNodeIds = /* @__PURE__ */ new Set();
    for (const op of ops) {
      if (op.type === "presence") {
        const reverse = {
          type: "presence",
          data: {}
        };
        for (const key in op.data) {
          reverse.data[key] = state.me.current[key];
        }
        state.me.patch(op.data);
        if (state.buffer.me === null) {
          state.buffer.me = { type: "partial", data: op.data };
        } else {
          for (const key in op.data) {
            state.buffer.me.data[key] = op.data[key];
          }
        }
        result.reverse.unshift(reverse);
        result.updates.presence = true;
      } else {
        let source;
        if (!op.opId) {
          op.opId = pool.generateOpId();
        }
        if (isLocal) {
          source = 0 /* UNDOREDO_RECONNECT */;
        } else {
          const deleted = state.offlineOperations.delete(_chunkUV2F4F4Rjs.nn.call(void 0, op.opId));
          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;
        }
        const applyOpResult = applyOp(op, source);
        if (applyOpResult.modified) {
          const parentId = applyOpResult.modified.node.parent.type === "HasParent" ? _chunkUV2F4F4Rjs.nn.call(void 0, 
            applyOpResult.modified.node.parent.node._id,
            "Expected parent node to have an ID"
          ) : void 0;
          if (!parentId || !createdNodeIds.has(parentId)) {
            result.updates.storageUpdates.set(
              _chunkUV2F4F4Rjs.nn.call(void 0, applyOpResult.modified.node._id),
              _chunkUV2F4F4Rjs.mergeStorageUpdates.call(void 0, 
                result.updates.storageUpdates.get(
                  _chunkUV2F4F4Rjs.nn.call(void 0, applyOpResult.modified.node._id)
                ),
                applyOpResult.modified
              )
            );
            result.reverse.unshift(...applyOpResult.reverse);
          }
          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {
            createdNodeIds.add(_chunkUV2F4F4Rjs.nn.call(void 0, applyOpResult.modified.node._id));
          }
        }
      }
    }
    return result;
  }
  function applyOp(op, source) {
    switch (op.type) {
      case 6 /* DELETE_OBJECT_KEY */:
      case 3 /* UPDATE_OBJECT */:
      case 5 /* DELETE_CRDT */: {
        const node = state.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);
      }
      case 1 /* SET_PARENT_KEY */: {
        const node = state.nodes.get(op.id);
        if (node === void 0) {
          return { modified: false };
        }
        if (node.parent.type === "HasParent" && _chunkUV2F4F4Rjs.isLiveList.call(void 0, node.parent.node)) {
          return node.parent.node._setChildKey(op.parentKey, node, source);
        }
        return { modified: false };
      }
      case 4 /* CREATE_OBJECT */:
      case 2 /* CREATE_LIST */:
      case 7 /* CREATE_MAP */:
      case 8 /* CREATE_REGISTER */: {
        if (op.parentId === void 0) {
          return { modified: false };
        }
        const parentNode = state.nodes.get(op.parentId);
        if (parentNode === void 0) {
          return { modified: false };
        }
        return parentNode._attachChild(op, source);
      }
    }
  }
  function subscribeToLiveStructureDeeply(node, callback) {
    return eventHub.storage.subscribe((updates) => {
      const relatedUpdates = updates.filter(
        (update) => _chunkUV2F4F4Rjs.isSameNodeOrChildOf.call(void 0, update.node, node)
      );
      if (relatedUpdates.length > 0) {
        callback(relatedUpdates);
      }
    });
  }
  function subscribeToLiveStructureShallowly(node, callback) {
    return eventHub.storage.subscribe((updates) => {
      for (const update of updates) {
        if (update.node._id === node._id) {
          callback(update.node);
        }
      }
    });
  }
  function subscribe(first, second, options) {
    if (typeof first === "string" && _chunkUV2F4F4Rjs.isRoomEventName.call(void 0, first)) {
      if (typeof second !== "function") {
        throw new Error("Second argument must be a callback function");
      }
      const callback = second;
      switch (first) {
        case "event":
          return eventHub.customEvent.subscribe(
            callback
          );
        case "my-presence":
          return eventHub.me.subscribe(callback);
        case "others": {
          const cb = callback;
          return eventHub.others.subscribe(
            ({ others, event }) => cb(others, event)
          );
        }
        case "error":
          return eventHub.error.subscribe(callback);
        case "connection":
          return eventHub.connection.subscribe(
            callback
          );
        case "storage":
          return eventHub.storage.subscribe(
            callback
          );
        case "history":
          return eventHub.history.subscribe(callback);
        default:
          return _chunkUV2F4F4Rjs.assertNever.call(void 0, first, "Unknown event");
      }
    }
    if (second === void 0 || typeof first === "function") {
      if (typeof first === "function") {
        const storageCallback = first;
        return eventHub.storage.subscribe(storageCallback);
      } else {
        throw new Error("Please specify a listener callback");
      }
    }
    if (_chunkUV2F4F4Rjs.isLiveNode.call(void 0, first)) {
      const node = first;
      if (options == null ? void 0 : options.isDeep) {
        const storageCallback = second;
        return subscribeToLiveStructureDeeply(node, storageCallback);
      } else {
        const nodeCallback = second;
        return subscribeToLiveStructureShallowly(node, nodeCallback);
      }
    }
    throw new Error(`"${first}" is not a valid event name`);
  }
  function getConnectionState() {
    return state.connection.current.state;
  }
  function connect() {
    var _a, _b, _c, _d;
    if (state.connection.current.state !== "closed" && state.connection.current.state !== "unavailable") {
      return null;
    }
    const auth = prepareAuthEndpoint(
      config.authentication,
      (_b = (_a = config.polyfills) == null ? void 0 : _a.fetch) != null ? _b : config.fetchPolyfill
    );
    const createWebSocket = prepareCreateWebSocket(
      config.liveblocksServer,
      (_d = (_c = config.polyfills) == null ? void 0 : _c.WebSocket) != null ? _d : config.WebSocketPolyfill
    );
    updateConnection({ state: "authenticating" });
    effects.authenticate(auth, createWebSocket);
  }
  function updatePresence(patch, options) {
    const oldValues = {};
    if (state.buffer.me === null) {
      state.buffer.me = {
        type: "partial",
        data: {}
      };
    }
    for (const key in patch) {
      const overrideValue = patch[key];
      if (overrideValue === void 0) {
        continue;
      }
      state.buffer.me.data[key] = overrideValue;
      oldValues[key] = state.me.current[key];
    }
    state.me.patch(patch);
    if (state.activeBatch) {
      if (options == null ? void 0 : options.addToHistory) {
        state.activeBatch.reverseOps.push({
          type: "presence",
          data: oldValues
        });
      }
      state.activeBatch.updates.presence = true;
    } else {
      tryFlushing();
      if (options == null ? void 0 : options.addToHistory) {
        addToUndoStack([{ type: "presence", data: oldValues }]);
      }
      notify({ presence: true });
    }
  }
  function authenticationSuccess(token, socket) {
    socket.addEventListener("message", onMessage);
    socket.addEventListener("open", onOpen);
    socket.addEventListener("close", onClose);
    socket.addEventListener("error", onError);
    updateConnection({
      state: "connecting",
      id: token.actor,
      userInfo: token.info,
      userId: token.id
    });
    state.idFactory = makeIdFactory(token.actor);
    state.socket = socket;
  }
  function authenticationFailure(error) {
    if (process.env.NODE_ENV !== "production") {
      console.error("Call to authentication endpoint failed", error);
    }
    state.token = null;
    updateConnection({ state: "unavailable" });
    state.numberOfRetry++;
    state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());
  }
  function onVisibilityChange(visibilityState) {
    if (visibilityState === "visible" && state.connection.current.state === "open") {
      log("Heartbeat after visibility change");
      heartbeat();
    }
  }
  function onUpdatePresenceMessage(message) {
    if (message.targetActor !== void 0) {
      const oldUser = state.others.getUser(message.actor);
      state.others.setOther(message.actor, message.data);
      const newUser = state.others.getUser(message.actor);
      if (oldUser === void 0 && newUser !== void 0) {
        return { type: "enter", user: newUser };
      }
    } else {
      state.others.patchOther(message.actor, message.data), message;
    }
    const user = state.others.getUser(message.actor);
    if (user) {
      return {
        type: "update",
        updates: message.data,
        user
      };
    } else {
      return void 0;
    }
  }
  function onUserLeftMessage(message) {
    const user = state.others.getUser(message.actor);
    if (user) {
      state.others.removeConnection(message.actor);
      return { type: "leave", user };
    }
    return null;
  }
  function onRoomStateMessage(message) {
    for (const key in message.users) {
      const user = message.users[key];
      const connectionId = Number(key);
      state.others.setConnection(connectionId, user.id, user.info);
    }
    return { type: "reset" };
  }
  function onNavigatorOnline() {
    if (state.connection.current.state === "unavailable") {
      log("Try to reconnect after connectivity change");
      reconnect();
    }
  }
  function onHistoryChange() {
    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });
  }
  function onUserJoinedMessage(message) {
    state.others.setConnection(message.actor, message.id, message.info);
    state.buffer.messages.push({
      type: 100 /* UPDATE_PRESENCE */,
      data: state.me.current,
      targetActor: message.actor
    });
    tryFlushing();
    const user = state.others.getUser(message.actor);
    return user ? { type: "enter", user } : void 0;
  }
  function parseServerMessage(data) {
    if (!_chunkUV2F4F4Rjs.isJsonObject.call(void 0, data)) {
      return null;
    }
    return data;
  }
  function parseServerMessages(text) {
    const data = _chunkUV2F4F4Rjs.tryParseJson.call(void 0, text);
    if (data === void 0) {
      return null;
    } else if (_chunkUV2F4F4Rjs.isJsonArray.call(void 0, data)) {
      return _chunkUV2F4F4Rjs.compact.call(void 0, data.map((item) => parseServerMessage(item)));
    } else {
      return _chunkUV2F4F4Rjs.compact.call(void 0, [parseServerMessage(data)]);
    }
  }
  function onMessage(event) {
    if (event.data === "pong") {
      clearTimeout(state.timeoutHandles.pongTimeout);
      return;
    }
    const messages = parseServerMessages(event.data);
    if (messages === null || messages.length === 0) {
      return;
    }
    const updates = {
      storageUpdates: /* @__PURE__ */ new Map(),
      others: []
    };
    for (const message of messages) {
      switch (message.type) {
        case 101 /* USER_JOINED */: {
          const userJoinedUpdate = onUserJoinedMessage(message);
          if (userJoinedUpdate) {
            updates.others.push(userJoinedUpdate);
          }
          break;
        }
        case 100 /* UPDATE_PRESENCE */: {
          const othersPresenceUpdate = onUpdatePresenceMessage(message);
          if (othersPresenceUpdate) {
            updates.others.push(othersPresenceUpdate);
          }
          break;
        }
        case 103 /* BROADCASTED_EVENT */: {
          eventHub.customEvent.notify({
            connectionId: message.actor,
            event: message.event
          });
          break;
        }
        case 102 /* USER_LEFT */: {
          const event2 = onUserLeftMessage(message);
          if (event2) {
            updates.others.push(event2);
          }
          break;
        }
        case 104 /* ROOM_STATE */: {
          updates.others.push(onRoomStateMessage(message));
          break;
        }
        case 200 /* INITIAL_STORAGE_STATE */: {
          const offlineOps = new Map(state.offlineOperations);
          createOrUpdateRootFromMessage(message);
          applyAndSendOfflineOps(offlineOps);
          _getInitialStateResolver == null ? void 0 : _getInitialStateResolver();
          eventHub.storageDidLoad.notify();
          break;
        }
        case 201 /* UPDATE_STORAGE */: {
          const applyResult = apply(message.ops, false);
          applyResult.updates.storageUpdates.forEach((value, key) => {
            updates.storageUpdates.set(
              key,
              _chunkUV2F4F4Rjs.mergeStorageUpdates.call(void 0, 
                updates.storageUpdates.get(key),
                value
              )
            );
          });
          break;
        }
      }
    }
    notify(updates);
  }
  function onClose(event) {
    state.socket = null;
    clearTimeout(state.timeoutHandles.pongTimeout);
    clearInterval(state.intervalHandles.heartbeat);
    if (state.timeoutHandles.flush) {
      clearTimeout(state.timeoutHandles.flush);
    }
    clearTimeout(state.timeoutHandles.reconnect);
    state.others.clearOthers();
    notify({ others: [{ type: "reset" }] });
    if (event.code >= 4e3 && event.code <= 4100) {
      updateConnection({ state: "failed" });
      const error = new LiveblocksError(event.reason, event.code);
      eventHub.error.notify(error);
      const delay = getRetryDelay(true);
      state.numberOfRetry++;
      if (process.env.NODE_ENV !== "production") {
        console.error(
          `Connection to Liveblocks websocket server closed. Reason: ${error.message} (code: ${error.code}). Retrying in ${delay}ms.`
        );
      }
      updateConnection({ state: "unavailable" });
      state.timeoutHandles.reconnect = effects.scheduleReconnect(delay);
    } else if (event.code === 4999 /* CLOSE_WITHOUT_RETRY */) {
      updateConnection({ state: "closed" });
    } else {
      const delay = getRetryDelay();
      state.numberOfRetry++;
      if (process.env.NODE_ENV !== "production") {
        console.warn(
          `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${delay}ms.`
        );
      }
      updateConnection({ state: "unavailable" });
      state.timeoutHandles.reconnect = effects.scheduleReconnect(delay);
    }
  }
  function updateConnection(connection) {
    state.connection.set(connection);
    eventHub.connection.notify(connection.state);
  }
  function getRetryDelay(slow = false) {
    if (slow) {
      return BACKOFF_RETRY_DELAYS_SLOW[state.numberOfRetry < BACKOFF_RETRY_DELAYS_SLOW.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS_SLOW.length - 1];
    }
    return BACKOFF_RETRY_DELAYS[state.numberOfRetry < BACKOFF_RETRY_DELAYS.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS.length - 1];
  }
  function onError() {
  }
  function onOpen() {
    clearInterval(state.intervalHandles.heartbeat);
    state.intervalHandles.heartbeat = effects.startHeartbeatInterval();
    if (state.connection.current.state === "connecting") {
      updateConnection(_chunkUV2F4F4Rjs.__spreadProps.call(void 0, _chunkUV2F4F4Rjs.__spreadValues.call(void 0, {}, state.connection.current), { state: "open" }));
      state.numberOfRetry = 0;
      if (state.lastConnectionId !== void 0) {
        state.buffer.me = {
          type: "full",
          data: _chunkUV2F4F4Rjs.__spreadValues.call(void 0, {}, state.me.current)
        };
        tryFlushing();
      }
      state.lastConnectionId = state.connection.current.id;
      if (state.root) {
        state.buffer.messages.push({ type: 200 /* FETCH_STORAGE */ });
      }
      tryFlushing();
    } else {
    }
  }
  function heartbeat() {
    if (state.socket === null) {
      return;
    }
    clearTimeout(state.timeoutHandles.pongTimeout);
    state.timeoutHandles.pongTimeout = effects.schedulePongTimeout();
    if (state.socket.readyState === state.socket.OPEN) {
      state.socket.send("ping");
    }
  }
  function pongTimeout() {
    log("Pong timeout. Trying to reconnect.");
    reconnect();
  }
  function reconnect() {
    if (state.socket) {
      state.socket.removeEventListener("open", onOpen);
      state.socket.removeEventListener("message", onMessage);
      state.socket.removeEventListener("close", onClose);
      state.socket.removeEventListener("error", onError);
      state.socket.close();
      state.socket = null;
    }
    updateConnection({ state: "unavailable" });
    clearTimeout(state.timeoutHandles.pongTimeout);
    if (state.timeoutHandles.flush) {
      clearTimeout(state.timeoutHandles.flush);
    }
    clearTimeout(state.timeoutHandles.reconnect);
    clearInterval(state.intervalHandles.heartbeat);
    connect();
  }
  function applyAndSendOfflineOps(offlineOps) {
    if (offlineOps.size === 0) {
      return;
    }
    const messages = [];
    const ops = Array.from(offlineOps.values());
    const result = apply(ops, true);
    messages.push({
      type: 201 /* UPDATE_STORAGE */,
      ops
    });
    notify(result.updates);
    effects.send(messages);
  }
  function tryFlushing() {
    const storageOps = state.buffer.storageOperations;
    if (storageOps.length > 0) {
      storageOps.forEach((op) => {
        state.offlineOperations.set(_chunkUV2F4F4Rjs.nn.call(void 0, op.opId), op);
      });
    }
    if (state.socket === null || state.socket.readyState !== state.socket.OPEN) {
      state.buffer.storageOperations = [];
      return;
    }
    const now = Date.now();
    const elapsedTime = now - state.lastFlushTime;
    if (elapsedTime > config.throttleDelay) {
      const messages = flushDataToMessages(state);
      if (messages.length === 0) {
        return;
      }
      effects.send(messages);
      state.buffer = {
        messages: [],
        storageOperations: [],
        me: null
      };
      state.lastFlushTime = now;
    } else {
      if (state.timeoutHandles.flush !== null) {
        clearTimeout(state.timeoutHandles.flush);
      }
      state.timeoutHandles.flush = effects.delayFlush(
        config.throttleDelay - (now - state.lastFlushTime)
      );
    }
  }
  function flushDataToMessages(state2) {
    const messages = [];
    if (state2.buffer.me) {
      messages.push(
        state2.buffer.me.type === "full" ? {
          type: 100 /* UPDATE_PRESENCE */,
          targetActor: -1,
          data: state2.buffer.me.data
        } : {
          type: 100 /* UPDATE_PRESENCE */,
          data: state2.buffer.me.data
        }
      );
    }
    for (const event of state2.buffer.messages) {
      messages.push(event);
    }
    if (state2.buffer.storageOperations.length > 0) {
      messages.push({
        type: 201 /* UPDATE_STORAGE */,
        ops: state2.buffer.storageOperations
      });
    }
    return messages;
  }
  function disconnect() {
    if (state.socket) {
      state.socket.removeEventListener("open", onOpen);
      state.socket.removeEventListener("message", onMessage);
      state.socket.removeEventListener("close", onClose);
      state.socket.removeEventListener("error", onError);
      state.socket.close();
      state.socket = null;
    }
    updateConnection({ state: "closed" });
    if (state.timeoutHandles.flush) {
      clearTimeout(state.timeoutHandles.flush);
    }
    clearTimeout(state.timeoutHandles.reconnect);
    clearTimeout(state.timeoutHandles.pongTimeout);
    clearInterval(state.intervalHandles.heartbeat);
    state.others.clearOthers();
    notify({ others: [{ type: "reset" }] });
    Object.values(eventHub).forEach((eventSource) => eventSource.clear());
  }
  function getPresence() {
    return state.me.current;
  }
  function getOthers() {
    return state.others.current;
  }
  function broadcastEvent(event, options = {
    shouldQueueEventIfNotReady: false
  }) {
    if (state.socket === null && !options.shouldQueueEventIfNotReady) {
      return;
    }
    state.buffer.messages.push({
      type: 103 /* BROADCAST_EVENT */,
      event
    });
    tryFlushing();
  }
  function dispatchOps(ops) {
    state.buffer.storageOperations.push(...ops);
    tryFlushing();
  }
  let _getInitialStatePromise = null;
  let _getInitialStateResolver = null;
  function startLoadingStorage() {
    if (_getInitialStatePromise === null) {
      state.buffer.messages.push({ type: 200 /* FETCH_STORAGE */ });
      tryFlushing();
      _getInitialStatePromise = new Promise(
        (resolve) => _getInitialStateResolver = resolve
      );
    }
    return _getInitialStatePromise;
  }
  function getStorageSnapshot() {
    const root = state.root;
    if (root !== void 0) {
      return root;
    } else {
      startLoadingStorage();
      return null;
    }
  }
  function getStorage() {
    return _chunkUV2F4F4Rjs.__async.call(void 0, this, null, function* () {
      if (state.root) {
        return Promise.resolve({
          root: state.root
        });
      }
      yield startLoadingStorage();
      return {
        root: _chunkUV2F4F4Rjs.nn.call(void 0, state.root)
      };
    });
  }
  function undo() {
    if (state.activeBatch) {
      throw new Error("undo is not allowed during a batch");
    }
    const historyOps = state.undoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    state.pausedHistory = null;
    const result = apply(historyOps, true);
    notify(result.updates);
    state.redoStack.push(result.reverse);
    onHistoryChange();
    for (const op of historyOps) {
      if (op.type !== "presence") {
        state.buffer.storageOperations.push(op);
      }
    }
    tryFlushing();
  }
  function canUndo() {
    return state.undoStack.length > 0;
  }
  function redo() {
    if (state.activeBatch) {
      throw new Error("redo is not allowed during a batch");
    }
    const historyOps = state.redoStack.pop();
    if (historyOps === void 0) {
      return;
    }
    state.pausedHistory = null;
    const result = apply(historyOps, true);
    notify(result.updates);
    state.undoStack.push(result.reverse);
    onHistoryChange();
    for (const op of historyOps) {
      if (op.type !== "presence") {
        state.buffer.storageOperations.push(op);
      }
    }
    tryFlushing();
  }
  function canRedo() {
    return state.redoStack.length > 0;
  }
  function batch(callback) {
    if (state.activeBatch) {
      return callback();
    }
    state.activeBatch = {
      ops: [],
      updates: {
        storageUpdates: /* @__PURE__ */ new Map(),
        presence: false,
        others: []
      },
      reverseOps: []
    };
    try {
      return callback();
    } finally {
      const currentBatch = state.activeBatch;
      state.activeBatch = null;
      if (currentBatch.reverseOps.length > 0) {
        addToUndoStack(currentBatch.reverseOps);
      }
      if (currentBatch.ops.length > 0) {
        state.redoStack = [];
      }
      if (currentBatch.ops.length > 0) {
        dispatchOps(currentBatch.ops);
      }
      notify(currentBatch.updates);
      tryFlushing();
    }
  }
  function pauseHistory() {
    state.pausedHistory = [];
  }
  function resumeHistory() {
    const historyOps = state.pausedHistory;
    state.pausedHistory = null;
    if (historyOps !== null && historyOps.length > 0) {
      _addToRealUndoStack(historyOps);
    }
  }
  function simulateSocketClose() {
    if (state.socket) {
      state.socket = null;
    }
  }
  function simulateSendCloseEvent(event) {
    onClose(event);
  }
  return {
    onClose,
    onMessage,
    authenticationSuccess,
    heartbeat,
    onNavigatorOnline,
    simulateSocketClose,
    simulateSendCloseEvent,
    onVisibilityChange,
    getUndoStack: () => state.undoStack,
    getItemsCount: () => state.nodes.size,
    connect,
    disconnect,
    subscribe,
    updatePresence,
    broadcastEvent,
    batch,
    undo,
    redo,
    canUndo,
    canRedo,
    pauseHistory,
    resumeHistory,
    getStorage,
    getStorageSnapshot,
    events: {
      customEvent: eventHub.customEvent.observable,
      others: eventHub.others.observable,
      me: eventHub.me.observable,
      error: eventHub.error.observable,
      connection: eventHub.connection.observable,
      storage: eventHub.storage.observable,
      history: eventHub.history.observable,
      storageDidLoad: eventHub.storageDidLoad.observable
    },
    getConnectionState,
    isSelfAware: () => isConnectionSelfAware(state.connection.current),
    getSelf: () => self.current,
    getPresence,
    getOthers
  };
}
function defaultState(initialPresence, initialStorage) {
  const others = new OthersRef();
  const connection = new ValueRef({ state: "closed" });
  return {
    token: null,
    lastConnectionId: null,
    socket: null,
    numberOfRetry: 0,
    lastFlushTime: 0,
    timeoutHandles: {
      flush: null,
      reconnect: 0,
      pongTimeout: 0
    },
    buffer: {
      me: {
        type: "full",
        data: initialPresence
      },
      messages: [],
      storageOperations: []
    },
    intervalHandles: {
      heartbeat: 0
    },
    connection,
    me: new MeRef(initialPresence),
    others,
    initialStorage,
    idFactory: null,
    clock: 0,
    opClock: 0,
    nodes: /* @__PURE__ */ new Map(),
    root: void 0,
    undoStack: [],
    redoStack: [],
    pausedHistory: null,
    activeBatch: null,
    offlineOperations: /* @__PURE__ */ new Map()
  };
}
function createRoom(options, config) {
  const { initialPresence, initialStorage } = options;
  const state = defaultState(
    typeof initialPresence === "function" ? initialPresence(config.roomId) : initialPresence,
    typeof initialStorage === "function" ? initialStorage(config.roomId) : initialStorage
  );
  const machine = makeStateMachine(
    state,
    config
  );
  const room = {
    id: config.roomId,
    getConnectionState: machine.getConnectionState,
    isSelfAware: machine.isSelfAware,
    getSelf: machine.getSelf,
    subscribe: machine.subscribe,
    getPresence: machine.getPresence,
    updatePresence: machine.updatePresence,
    getOthers: machine.getOthers,
    broadcastEvent: machine.broadcastEvent,
    getStorage: machine.getStorage,
    getStorageSnapshot: machine.getStorageSnapshot,
    events: machine.events,
    batch: machine.batch,
    history: {
      undo: machine.undo,
      redo: machine.redo,
      canUndo: machine.canUndo,
      canRedo: machine.canRedo,
      pause: machine.pauseHistory,
      resume: machine.resumeHistory
    },
    __INTERNAL_DO_NOT_USE: {
      simulateCloseWebsocket: machine.simulateSocketClose,
      simulateSendCloseEvent: machine.simulateSendCloseEvent
    }
  };
  return {
    connect: machine.connect,
    disconnect: machine.disconnect,
    onNavigatorOnline: machine.onNavigatorOnline,
    onVisibilityChange: machine.onVisibilityChange,
    room
  };
}
var LiveblocksError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
function prepareCreateWebSocket(liveblocksServer, WebSocketPolyfill) {
  if (typeof window === "undefined" && WebSocketPolyfill === void 0) {
    throw new Error(
      "To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill."
    );
  }
  const ws = WebSocketPolyfill || WebSocket;
  return (token) => {
    return new ws(
      `${liveblocksServer}/?token=${token}&version=${true ? "0.18.2" : "dev"}`
    );
  };
}
function prepareAuthEndpoint(authentication, fetchPolyfill) {
  if (authentication.type === "public") {
    if (typeof window === "undefined" && fetchPolyfill === void 0) {
      throw new Error(
        "To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill."
      );
    }
    return (room) => fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
      room,
      publicApiKey: authentication.publicApiKey
    });
  }
  if (authentication.type === "private") {
    if (typeof window === "undefined" && fetchPolyfill === void 0) {
      throw new Error(
        "To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill."
      );
    }
    return (room) => fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
      room
    });
  }
  if (authentication.type === "custom") {
    return (room) => _chunkUV2F4F4Rjs.__async.call(void 0, this, null, function* () {
      const response = yield authentication.callback(room);
      if (!response || !response.token) {
        throw new Error(
          'Authentication error. We expect the authentication callback to return a token, but it does not. Hint: the return value should look like: { token: "..." }'
        );
      }
      return response;
    });
  }
  throw new Error("Internal error. Unexpected authentication type");
}
function fetchAuthEndpoint(fetch2, endpoint, body) {
  return _chunkUV2F4F4Rjs.__async.call(void 0, this, null, function* () {
    const res = yield fetch2(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      throw new AuthenticationError(
        `Expected a status 200 but got ${res.status} when doing a POST request on "${endpoint}"`
      );
    }
    let data;
    try {
      data = yield res.json();
    } catch (er) {
      throw new AuthenticationError(
        `Expected a JSON response when doing a POST request on "${endpoint}". ${er}`
      );
    }
    if (!_chunkUV2F4F4Rjs.isPlainObject.call(void 0, data) || typeof data.token !== "string") {
      throw new AuthenticationError(
        `Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${endpoint}", but got ${JSON.stringify(
          data
        )}`
      );
    }
    const { token } = data;
    return { token };
  });
}
var AuthenticationError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// src/client.ts
function createClient(options) {
  const clientOptions = options;
  const throttleDelay = getThrottleDelayFromOptions(options);
  const rooms = /* @__PURE__ */ new Map();
  function getRoom(roomId) {
    const internalRoom = rooms.get(roomId);
    return internalRoom ? internalRoom.room : null;
  }
  function enter(roomId, options2) {
    var _a, _b;
    let internalRoom = rooms.get(roomId);
    if (internalRoom) {
      return internalRoom.room;
    }
    _chunkUV2F4F4Rjs.deprecateIf.call(void 0, 
      options2.initialPresence === null || options2.initialPresence === void 0,
      "Please provide an initial presence value for the current user when entering the room."
    );
    internalRoom = createRoom(
      {
        initialPresence: (_a = options2.initialPresence) != null ? _a : {},
        initialStorage: options2.initialStorage
      },
      {
        roomId,
        throttleDelay,
        polyfills: clientOptions.polyfills,
        WebSocketPolyfill: clientOptions.WebSocketPolyfill,
        fetchPolyfill: clientOptions.fetchPolyfill,
        liveblocksServer: (clientOptions == null ? void 0 : clientOptions.liveblocksServer) || "wss://api.liveblocks.io/v6",
        authentication: prepareAuthentication(clientOptions, roomId)
      }
    );
    rooms.set(
      roomId,
      internalRoom
    );
    if (!options2.DO_NOT_USE_withoutConnecting) {
      if (typeof atob === "undefined") {
        if (((_b = clientOptions.polyfills) == null ? void 0 : _b.atob) === void 0) {
          throw new Error(
            "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
          );
        }
        global.atob = clientOptions.polyfills.atob;
      }
      internalRoom.connect();
    }
    return internalRoom.room;
  }
  function leave(roomId) {
    const room = rooms.get(roomId);
    if (room) {
      room.disconnect();
      rooms.delete(roomId);
    }
  }
  if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
    window.addEventListener("online", () => {
      for (const [, room] of rooms) {
        room.onNavigatorOnline();
      }
    });
  }
  if (typeof document !== "undefined") {
    document.addEventListener("visibilitychange", () => {
      for (const [, room] of rooms) {
        room.onVisibilityChange(document.visibilityState);
      }
    });
  }
  return {
    getRoom,
    enter,
    leave
  };
}
function getThrottleDelayFromOptions(options) {
  if (options.throttle === void 0) {
    return 100;
  }
  if (typeof options.throttle !== "number" || options.throttle < 80 || options.throttle > 1e3) {
    throw new Error("throttle should be a number between 80 and 1000.");
  }
  return options.throttle;
}
function prepareAuthentication(clientOptions, roomId) {
  const { publicApiKey, authEndpoint } = clientOptions;
  if (authEndpoint !== void 0 && publicApiKey !== void 0) {
    throw new Error(
      "You cannot use both publicApiKey and authEndpoint. Please use either publicApiKey or authEndpoint, but not both. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  }
  if (typeof publicApiKey === "string") {
    if (publicApiKey.startsWith("sk_")) {
      throw new Error(
        "Invalid publicApiKey. You are using the secret key which is not supported. Please use the public key instead. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    } else if (!publicApiKey.startsWith("pk_")) {
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    }
    return {
      type: "public",
      publicApiKey,
      url: buildLiveblocksPublicAuthorizeEndpoint(clientOptions, roomId)
    };
  }
  if (typeof authEndpoint === "string") {
    return {
      type: "private",
      url: authEndpoint
    };
  } else if (typeof authEndpoint === "function") {
    return {
      type: "custom",
      callback: authEndpoint
    };
  } else if (authEndpoint !== void 0) {
    throw new Error(
      "authEndpoint must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
    );
  }
  throw new Error(
    "Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}
function buildLiveblocksPublicAuthorizeEndpoint(options, roomId) {
  if (options.publicAuthorizeEndpoint) {
    return options.publicAuthorizeEndpoint.replace("{roomId}", roomId);
  }
  return `https://api.liveblocks.io/v2/rooms/${encodeURIComponent(
    roomId
  )}/public/authorize`;
}

// src/shallow.ts
function shallowArray(xs, ys) {
  if (xs.length !== ys.length) {
    return false;
  }
  for (let i = 0; i < xs.length; i++) {
    if (!Object.is(xs[i], ys[i])) {
      return false;
    }
  }
  return true;
}
function shallowObj(objA, objB) {
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null || Object.prototype.toString.call(objA) !== "[object Object]" || Object.prototype.toString.call(objB) !== "[object Object]") {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])
  );
}
function shallow(a, b) {
  if (Object.is(a, b)) {
    return true;
  }
  const isArrayA = Array.isArray(a);
  const isArrayB = Array.isArray(b);
  if (isArrayA || isArrayB) {
    if (!isArrayA || !isArrayB) {
      return false;
    }
    return shallowArray(a, b);
  }
  return shallowObj(a, b);
}






exports.LiveList = _chunkUV2F4F4Rjs.LiveList; exports.LiveMap = _chunkUV2F4F4Rjs.LiveMap; exports.LiveObject = _chunkUV2F4F4Rjs.LiveObject; exports.createClient = createClient; exports.shallow = shallow;
