"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/deprecation.ts
var _emittedDeprecationWarnings = /* @__PURE__ */ new Set();
function deprecate(message, key = message) {
  if (process.env.NODE_ENV !== "production") {
    if (!_emittedDeprecationWarnings.has(key)) {
      _emittedDeprecationWarnings.add(key);
      console.error(`DEPRECATION WARNING: ${message}`);
    }
  }
}
function deprecateIf(condition, message, key = message) {
  if (process.env.NODE_ENV !== "production") {
    if (condition) {
      deprecate(message, key);
    }
  }
}
function throwUsageError(message) {
  if (process.env.NODE_ENV !== "production") {
    const usageError = new Error(message);
    usageError.name = "Usage error";
    throw usageError;
  }
}
function errorIf(condition, message) {
  if (process.env.NODE_ENV !== "production") {
    if (condition) {
      throwUsageError(message);
    }
  }
}

// src/assert.ts
function assertNever(_value, errmsg) {
  throw new Error(errmsg);
}
function assert(condition, errmsg) {
  if (process.env.NODE_ENV !== "production" && !condition) {
    const err = new Error(errmsg);
    err.name = "Assertion failure";
    throw err;
  }
}
function nn(value, errmsg = "Expected value to be non-nullable") {
  assert(value !== null && value !== void 0, errmsg);
  return value;
}

// src/types/ClientMsg.ts
var ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {
  ClientMsgCode2[ClientMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ClientMsgCode2[ClientMsgCode2["BROADCAST_EVENT"] = 103] = "BROADCAST_EVENT";
  ClientMsgCode2[ClientMsgCode2["FETCH_STORAGE"] = 200] = "FETCH_STORAGE";
  ClientMsgCode2[ClientMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  return ClientMsgCode2;
})(ClientMsgCode || {});

// src/types/Op.ts
var OpCode = /* @__PURE__ */ ((OpCode2) => {
  OpCode2[OpCode2["INIT"] = 0] = "INIT";
  OpCode2[OpCode2["SET_PARENT_KEY"] = 1] = "SET_PARENT_KEY";
  OpCode2[OpCode2["CREATE_LIST"] = 2] = "CREATE_LIST";
  OpCode2[OpCode2["UPDATE_OBJECT"] = 3] = "UPDATE_OBJECT";
  OpCode2[OpCode2["CREATE_OBJECT"] = 4] = "CREATE_OBJECT";
  OpCode2[OpCode2["DELETE_CRDT"] = 5] = "DELETE_CRDT";
  OpCode2[OpCode2["DELETE_OBJECT_KEY"] = 6] = "DELETE_OBJECT_KEY";
  OpCode2[OpCode2["CREATE_MAP"] = 7] = "CREATE_MAP";
  OpCode2[OpCode2["CREATE_REGISTER"] = 8] = "CREATE_REGISTER";
  return OpCode2;
})(OpCode || {});

// src/types/SerializedCrdt.ts
var CrdtType = /* @__PURE__ */ ((CrdtType2) => {
  CrdtType2[CrdtType2["OBJECT"] = 0] = "OBJECT";
  CrdtType2[CrdtType2["LIST"] = 1] = "LIST";
  CrdtType2[CrdtType2["MAP"] = 2] = "MAP";
  CrdtType2[CrdtType2["REGISTER"] = 3] = "REGISTER";
  return CrdtType2;
})(CrdtType || {});
function isRootCrdt(crdt) {
  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);
}
function isChildCrdt(crdt) {
  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;
}

// src/types/ServerMsg.ts
var ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {
  ServerMsgCode2[ServerMsgCode2["UPDATE_PRESENCE"] = 100] = "UPDATE_PRESENCE";
  ServerMsgCode2[ServerMsgCode2["USER_JOINED"] = 101] = "USER_JOINED";
  ServerMsgCode2[ServerMsgCode2["USER_LEFT"] = 102] = "USER_LEFT";
  ServerMsgCode2[ServerMsgCode2["BROADCASTED_EVENT"] = 103] = "BROADCASTED_EVENT";
  ServerMsgCode2[ServerMsgCode2["ROOM_STATE"] = 104] = "ROOM_STATE";
  ServerMsgCode2[ServerMsgCode2["INITIAL_STORAGE_STATE"] = 200] = "INITIAL_STORAGE_STATE";
  ServerMsgCode2[ServerMsgCode2["UPDATE_STORAGE"] = 201] = "UPDATE_STORAGE";
  return ServerMsgCode2;
})(ServerMsgCode || {});

// src/types/index.ts
function isRoomEventName(value) {
  return value === "my-presence" || value === "others" || value === "event" || value === "error" || value === "connection" || value === "history";
}
var WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_ABNORMAL"] = 1006] = "CLOSE_ABNORMAL";
  WebsocketCloseCodes2[WebsocketCloseCodes2["INVALID_MESSAGE_FORMAT"] = 4e3] = "INVALID_MESSAGE_FORMAT";
  WebsocketCloseCodes2[WebsocketCloseCodes2["NOT_ALLOWED"] = 4001] = "NOT_ALLOWED";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_SECONDS"] = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS"] = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP"] = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP";
  WebsocketCloseCodes2[WebsocketCloseCodes2["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM"] = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM";
  WebsocketCloseCodes2[WebsocketCloseCodes2["CLOSE_WITHOUT_RETRY"] = 4999] = "CLOSE_WITHOUT_RETRY";
  return WebsocketCloseCodes2;
})(WebsocketCloseCodes || {});

// src/position.ts
var min = 32;
var max = 126;
function makePosition(before, after) {
  if (before !== void 0 && after !== void 0) {
    return pos(makePositionFromCodes(posCodes(before), posCodes(after)));
  } else if (before !== void 0) {
    return getNextPosition(before);
  } else if (after !== void 0) {
    return getPreviousPosition(after);
  }
  return pos([min + 1]);
}
function getPreviousPosition(after) {
  const result = [];
  const afterCodes = posCodes(after);
  for (let i = 0; i < afterCodes.length; i++) {
    const code = afterCodes[i];
    if (code <= min + 1) {
      result.push(min);
      if (afterCodes.length - 1 === i) {
        result.push(max);
        break;
      }
    } else {
      result.push(code - 1);
      break;
    }
  }
  return pos(result);
}
function getNextPosition(before) {
  const result = [];
  const beforeCodes = posCodes(before);
  for (let i = 0; i < beforeCodes.length; i++) {
    const code = beforeCodes[i];
    if (code === max) {
      result.push(code);
      if (beforeCodes.length - 1 === i) {
        result.push(min + 1);
        break;
      }
    } else {
      result.push(code + 1);
      break;
    }
  }
  return pos(result);
}
function makePositionFromCodes(before, after) {
  let index = 0;
  const result = [];
  while (true) {
    const beforeDigit = before[index] || min;
    const afterDigit = after[index] || max;
    if (beforeDigit > afterDigit) {
      throw new Error(
        `Impossible to generate position between ${before} and ${after}`
      );
    }
    if (beforeDigit === afterDigit) {
      result.push(beforeDigit);
      index++;
      continue;
    }
    if (afterDigit - beforeDigit === 1) {
      result.push(beforeDigit);
      result.push(...makePositionFromCodes(before.slice(index + 1), []));
      break;
    }
    const mid = afterDigit + beforeDigit >> 1;
    result.push(mid);
    break;
  }
  return result;
}
function posCodes(str) {
  const codes = [];
  for (let i = 0; i < str.length; i++) {
    codes.push(str.charCodeAt(i));
  }
  return codes;
}
function pos(codes) {
  return String.fromCharCode(...codes);
}
function comparePosition(posA, posB) {
  const aCodes = posCodes(posA);
  const bCodes = posCodes(posB);
  const maxLength = Math.max(aCodes.length, bCodes.length);
  for (let i = 0; i < maxLength; i++) {
    const a = aCodes[i] === void 0 ? min : aCodes[i];
    const b = bCodes[i] === void 0 ? min : bCodes[i];
    if (a === b) {
      continue;
    } else {
      return a - b;
    }
  }
  throw new Error(
    `Impossible to compare similar position "${posA}" and "${posB}"`
  );
}

// src/AbstractCrdt.ts
function crdtAsLiveNode(value) {
  return value;
}
function HasParent(node, key) {
  return Object.freeze({ type: "HasParent", node, key });
}
var NoParent = Object.freeze({ type: "NoParent" });
function Orphaned(oldKey) {
  return Object.freeze({ type: "Orphaned", oldKey });
}
var AbstractCrdt = class {
  constructor() {
    this._parent = NoParent;
  }
  _getParentKeyOrThrow() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  get _pool() {
    return this.__pool;
  }
  get roomId() {
    return this.__pool ? this.__pool.roomId : null;
  }
  get _id() {
    return this.__id;
  }
  get parent() {
    return this._parent;
  }
  get _parentNode() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.node;
      case "NoParent":
        return null;
      case "Orphaned":
        return null;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  get _parentKey() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        return null;
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  _apply(op, _isLocal) {
    switch (op.type) {
      case 5 /* DELETE_CRDT */: {
        if (this.parent.type === "HasParent") {
          return this.parent.node._detachChild(crdtAsLiveNode(this));
        }
        return { modified: false };
      }
    }
    return { modified: false };
  }
  _setParentLink(newParentNode, newParentKey) {
    switch (this.parent.type) {
      case "HasParent":
        if (this.parent.node !== newParentNode) {
          throw new Error("Cannot set parent: node already has a parent");
        } else {
          this._parent = HasParent(newParentNode, newParentKey);
          return;
        }
      case "Orphaned":
      case "NoParent": {
        this._parent = HasParent(newParentNode, newParentKey);
        return;
      }
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  _attach(id, pool) {
    if (this.__id || this.__pool) {
      throw new Error("Cannot attach node: already attached");
    }
    pool.addNode(id, crdtAsLiveNode(this));
    this.__id = id;
    this.__pool = pool;
  }
  _detach() {
    if (this.__pool && this.__id) {
      this.__pool.deleteNode(this.__id);
    }
    switch (this.parent.type) {
      case "HasParent": {
        this._parent = Orphaned(this.parent.key);
        break;
      }
      case "NoParent": {
        this._parent = NoParent;
        break;
      }
      case "Orphaned": {
        this._parent = Orphaned(this.parent.oldKey);
        break;
      }
      default:
        assertNever(this.parent, "Unknown state");
    }
    this.__pool = void 0;
  }
  invalidate() {
    if (this._cachedImmutable !== void 0) {
      this._cachedImmutable = void 0;
      if (this.parent.type === "HasParent") {
        this.parent.node.invalidate();
      }
    }
  }
  toImmutable() {
    if (this._cachedImmutable === void 0) {
      this._cachedImmutable = this._toImmutable();
    }
    return this._cachedImmutable;
  }
};

// src/LiveRegister.ts
var LiveRegister = class extends AbstractCrdt {
  constructor(data) {
    super();
    this._data = data;
  }
  get data() {
    return this._data;
  }
  static _deserialize([id, item], _parentToChildren, pool) {
    const register = new LiveRegister(item.data);
    register._attach(id, pool);
    return register;
  }
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error(
        "Cannot serialize register if parentId or parentKey is undefined"
      );
    }
    return [
      {
        type: 8 /* CREATE_REGISTER */,
        opId: pool == null ? void 0 : pool.generateOpId(),
        id: this._id,
        parentId,
        parentKey,
        data: this.data
      }
    ];
  }
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveRegister if parent is missing");
    }
    return {
      type: 3 /* REGISTER */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
      data: this.data
    };
  }
  _attachChild(_op) {
    throw new Error("Method not implemented.");
  }
  _detachChild(_crdt) {
    throw new Error("Method not implemented.");
  }
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  _toImmutable() {
    return this._data;
  }
};

// src/LiveMap.ts
var LiveMap = class extends AbstractCrdt {
  constructor(entries2) {
    super();
    this.unacknowledgedSet = /* @__PURE__ */ new Map();
    if (entries2) {
      const mappedEntries = [];
      for (const entry of entries2) {
        const value = lsonToLiveNode(entry[1]);
        value._setParentLink(this, entry[0]);
        mappedEntries.push([entry[0], value]);
      }
      this._map = new Map(mappedEntries);
    } else {
      this._map = /* @__PURE__ */ new Map();
    }
  }
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool == null ? void 0 : pool.generateOpId(),
      type: 7 /* CREATE_MAP */,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const [key, value] of this._map) {
      ops.push(...value._toOps(this._id, key, pool));
    }
    return ops;
  }
  static _deserialize([id, _item], parentToChildren, pool) {
    const map = new LiveMap();
    map._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return map;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(map, crdt.parentKey);
      map._map.set(crdt.parentKey, child);
      map.invalidate();
    }
    return map;
  }
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of this._map) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, parentKey, opId } = op;
    const key = parentKey;
    const child = creationOpToLiveNode(op);
    if (this._pool.getNode(id) !== void 0) {
      return { modified: false };
    }
    if (source === 2 /* ACK */) {
      const lastUpdateOpId = this.unacknowledgedSet.get(key);
      if (lastUpdateOpId === opId) {
        this.unacknowledgedSet.delete(key);
        return { modified: false };
      } else if (lastUpdateOpId !== void 0) {
        return { modified: false };
      }
    } else if (source === 1 /* REMOTE */) {
      this.unacknowledgedSet.delete(key);
    }
    const previousValue = this._map.get(key);
    let reverse;
    if (previousValue) {
      const thisId = nn(this._id);
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else {
      reverse = [{ type: 5 /* DELETE_CRDT */, id }];
    }
    child._setParentLink(this, key);
    child._attach(id, this._pool);
    this._map.set(key, child);
    this.invalidate();
    return {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      },
      reverse
    };
  }
  _detach() {
    super._detach();
    for (const item of this._map.values()) {
      item._detach();
    }
  }
  _detachChild(child) {
    const id = nn(this._id);
    const parentKey = nn(child._parentKey);
    const reverse = child._toOps(id, parentKey, this._pool);
    for (const [key, value] of this._map) {
      if (value === child) {
        this._map.delete(key);
        this.invalidate();
      }
    }
    child._detach();
    const storageUpdate = {
      node: this,
      type: "LiveMap",
      updates: { [parentKey]: { type: "delete" } }
    };
    return { modified: storageUpdate, reverse };
  }
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveMap if parent is missing");
    }
    return {
      type: 2 /* MAP */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  get(key) {
    const value = this._map.get(key);
    if (value === void 0) {
      return void 0;
    }
    return liveNodeToLson(value);
  }
  set(key, value) {
    const oldValue = this._map.get(key);
    if (oldValue) {
      oldValue._detach();
    }
    const item = lsonToLiveNode(value);
    item._setParentLink(this, key);
    this._map.set(key, item);
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      item._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      });
      const ops = item._toOps(this._id, key, this._pool);
      this.unacknowledgedSet.set(key, nn(ops[0].opId));
      this._pool.dispatch(
        item._toOps(this._id, key, this._pool),
        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],
        storageUpdates
      );
    }
  }
  get size() {
    return this._map.size;
  }
  has(key) {
    return this._map.has(key);
  }
  delete(key) {
    const item = this._map.get(key);
    if (item === void 0) {
      return false;
    }
    item._detach();
    this._map.delete(key);
    this.invalidate();
    if (this._pool && item._id) {
      const thisId = nn(this._id);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(thisId, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "delete" } }
      });
      this._pool.dispatch(
        [
          {
            type: 5 /* DELETE_CRDT */,
            id: item._id,
            opId: this._pool.generateOpId()
          }
        ],
        item._toOps(thisId, key),
        storageUpdates
      );
    }
    return true;
  }
  entries() {
    const innerIterator = this._map.entries();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const entry = iteratorValue.value;
        const key = entry[0];
        const value = liveNodeToLson(iteratorValue.value[1]);
        return {
          value: [key, value]
        };
      }
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  keys() {
    return this._map.keys();
  }
  values() {
    const innerIterator = this._map.values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const value = liveNodeToLson(iteratorValue.value);
        return { value };
      }
    };
  }
  forEach(callback) {
    for (const entry of this) {
      callback(entry[1], entry[0], this);
    }
  }
  toImmutable() {
    return super.toImmutable();
  }
  _toImmutable() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of this._map) {
      result.set(key, value.toImmutable());
    }
    return freeze(result);
  }
};

// src/LiveObject.ts
var LiveObject = class extends AbstractCrdt {
  constructor(obj = {}) {
    super();
    this._propToLastUpdate = /* @__PURE__ */ new Map();
    for (const key in obj) {
      const value = obj[key];
      if (value === void 0) {
        continue;
      } else if (isLiveNode(value)) {
        value._setParentLink(this, key);
      }
    }
    this._map = new Map(Object.entries(obj));
  }
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const opId = pool == null ? void 0 : pool.generateOpId();
    const ops = [];
    const op = parentId !== void 0 && parentKey !== void 0 ? {
      type: 4 /* CREATE_OBJECT */,
      id: this._id,
      opId,
      parentId,
      parentKey,
      data: {}
    } : { type: 4 /* CREATE_OBJECT */, id: this._id, opId, data: {} };
    ops.push(op);
    for (const [key, value] of this._map) {
      if (isLiveNode(value)) {
        ops.push(...value._toOps(this._id, key, pool));
      } else {
        op.data[key] = value;
      }
    }
    return ops;
  }
  static _deserialize([id, item], parentToChildren, pool) {
    const liveObj = new LiveObject(item.data);
    liveObj._attach(id, pool);
    return this._deserializeChildren(liveObj, parentToChildren, pool);
  }
  static _deserializeChildren(liveObj, parentToChildren, pool) {
    const children = parentToChildren.get(nn(liveObj._id));
    if (children === void 0) {
      return liveObj;
    }
    for (const [id, crdt] of children) {
      const child = deserializeToLson([id, crdt], parentToChildren, pool);
      if (isLiveStructure(child)) {
        child._setParentLink(liveObj, crdt.parentKey);
      }
      liveObj._map.set(crdt.parentKey, child);
      liveObj.invalidate();
    }
    return liveObj;
  }
  _attach(id, pool) {
    super._attach(id, pool);
    for (const [_key, value] of this._map) {
      if (isLiveNode(value)) {
        value._attach(pool.generateId(), pool);
      }
    }
  }
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, opId, parentKey: key } = op;
    const child = creationOpToLson(op);
    if (this._pool.getNode(id) !== void 0) {
      if (this._propToLastUpdate.get(key) === opId) {
        this._propToLastUpdate.delete(key);
      }
      return { modified: false };
    }
    if (source === 0 /* UNDOREDO_RECONNECT */) {
      this._propToLastUpdate.set(key, nn(opId));
    } else if (this._propToLastUpdate.get(key) === void 0) {
    } else if (this._propToLastUpdate.get(key) === opId) {
      this._propToLastUpdate.delete(key);
      return { modified: false };
    } else {
      return { modified: false };
    }
    const thisId = nn(this._id);
    const previousValue = this._map.get(key);
    let reverse;
    if (isLiveNode(previousValue)) {
      reverse = previousValue._toOps(thisId, key);
      previousValue._detach();
    } else if (previousValue === void 0) {
      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];
    } else {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          id: thisId,
          data: { [key]: previousValue }
        }
      ];
    }
    this._map.set(key, child);
    this.invalidate();
    if (isLiveStructure(child)) {
      child._setParentLink(this, key);
      child._attach(id, this._pool);
    }
    return {
      reverse,
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [key]: { type: "update" } }
      }
    };
  }
  _detachChild(child) {
    if (child) {
      const id = nn(this._id);
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(id, parentKey, this._pool);
      for (const [key, value] of this._map) {
        if (value === child) {
          this._map.delete(key);
          this.invalidate();
        }
      }
      child._detach();
      const storageUpdate = {
        node: this,
        type: "LiveObject",
        updates: {
          [parentKey]: { type: "delete" }
        }
      };
      return { modified: storageUpdate, reverse };
    }
    return { modified: false };
  }
  _detach() {
    super._detach();
    for (const value of this._map.values()) {
      if (isLiveNode(value)) {
        value._detach();
      }
    }
  }
  _apply(op, isLocal) {
    if (op.type === 3 /* UPDATE_OBJECT */) {
      return this._applyUpdate(op, isLocal);
    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {
      return this._applyDeleteObjectKey(op);
    }
    return super._apply(op, isLocal);
  }
  _serialize() {
    const data = {};
    for (const [key, value] of this._map) {
      if (!isLiveNode(value)) {
        data[key] = value;
      }
    }
    if (this.parent.type === "HasParent" && this.parent.node._id) {
      return {
        type: 0 /* OBJECT */,
        parentId: this.parent.node._id,
        parentKey: this.parent.key,
        data
      };
    } else {
      return {
        type: 0 /* OBJECT */,
        data
      };
    }
  }
  _applyUpdate(op, isLocal) {
    let isModified = false;
    const id = nn(this._id);
    const reverse = [];
    const reverseUpdate = {
      type: 3 /* UPDATE_OBJECT */,
      id,
      data: {}
    };
    reverse.push(reverseUpdate);
    for (const key in op.data) {
      const oldValue = this._map.get(key);
      if (isLiveNode(oldValue)) {
        reverse.push(...oldValue._toOps(id, key));
        oldValue._detach();
      } else if (oldValue !== void 0) {
        reverseUpdate.data[key] = oldValue;
      } else if (oldValue === void 0) {
        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });
      }
    }
    const updateDelta = {};
    for (const key in op.data) {
      const value = op.data[key];
      if (value === void 0) {
        continue;
      }
      if (isLocal) {
        this._propToLastUpdate.set(key, nn(op.opId));
      } else if (this._propToLastUpdate.get(key) === void 0) {
        isModified = true;
      } else if (this._propToLastUpdate.get(key) === op.opId) {
        this._propToLastUpdate.delete(key);
        continue;
      } else {
        continue;
      }
      const oldValue = this._map.get(key);
      if (isLiveNode(oldValue)) {
        oldValue._detach();
      }
      isModified = true;
      updateDelta[key] = { type: "update" };
      this._map.set(key, value);
      this.invalidate();
    }
    if (Object.keys(reverseUpdate.data).length !== 0) {
      reverse.unshift(reverseUpdate);
    }
    return isModified ? {
      modified: {
        node: this,
        type: "LiveObject",
        updates: updateDelta
      },
      reverse
    } : { modified: false };
  }
  _applyDeleteObjectKey(op) {
    const key = op.key;
    if (this._map.has(key) === false) {
      return { modified: false };
    }
    if (this._propToLastUpdate.get(key) !== void 0) {
      return { modified: false };
    }
    const oldValue = this._map.get(key);
    const id = nn(this._id);
    let reverse = [];
    if (isLiveNode(oldValue)) {
      reverse = oldValue._toOps(id, op.key);
      oldValue._detach();
    } else if (oldValue !== void 0) {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          id,
          data: { [key]: oldValue }
        }
      ];
    }
    this._map.delete(key);
    this.invalidate();
    return {
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [op.key]: { type: "delete" } }
      },
      reverse
    };
  }
  toObject() {
    return fromEntries(this._map);
  }
  set(key, value) {
    this.update({ [key]: value });
  }
  get(key) {
    return this._map.get(key);
  }
  delete(key) {
    const keyAsString = key;
    const oldValue = this._map.get(keyAsString);
    if (oldValue === void 0) {
      return;
    }
    if (this._pool === void 0 || this._id === void 0) {
      if (isLiveNode(oldValue)) {
        oldValue._detach();
      }
      this._map.delete(keyAsString);
      this.invalidate();
      return;
    }
    let reverse;
    if (isLiveNode(oldValue)) {
      oldValue._detach();
      reverse = oldValue._toOps(this._id, keyAsString);
    } else {
      reverse = [
        {
          type: 3 /* UPDATE_OBJECT */,
          data: { [keyAsString]: oldValue },
          id: this._id
        }
      ];
    }
    this._map.delete(keyAsString);
    this.invalidate();
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: { [key]: { type: "delete" } }
    });
    this._pool.dispatch(
      [
        {
          type: 6 /* DELETE_OBJECT_KEY */,
          key: keyAsString,
          id: this._id,
          opId: this._pool.generateOpId()
        }
      ],
      reverse,
      storageUpdates
    );
  }
  update(patch) {
    if (this._pool === void 0 || this._id === void 0) {
      for (const key in patch) {
        const newValue = patch[key];
        if (newValue === void 0) {
          continue;
        }
        const oldValue = this._map.get(key);
        if (isLiveNode(oldValue)) {
          oldValue._detach();
        }
        if (isLiveNode(newValue)) {
          newValue._setParentLink(this, key);
        }
        this._map.set(key, newValue);
        this.invalidate();
      }
      return;
    }
    const ops = [];
    const reverseOps = [];
    const opId = this._pool.generateOpId();
    const updatedProps = {};
    const reverseUpdateOp = {
      id: this._id,
      type: 3 /* UPDATE_OBJECT */,
      data: {}
    };
    const updateDelta = {};
    for (const key in patch) {
      const newValue = patch[key];
      if (newValue === void 0) {
        continue;
      }
      const oldValue = this._map.get(key);
      if (isLiveNode(oldValue)) {
        reverseOps.push(...oldValue._toOps(this._id, key));
        oldValue._detach();
      } else if (oldValue === void 0) {
        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });
      } else {
        reverseUpdateOp.data[key] = oldValue;
      }
      if (isLiveNode(newValue)) {
        newValue._setParentLink(this, key);
        newValue._attach(this._pool.generateId(), this._pool);
        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);
        const createCrdtOp = newAttachChildOps.find(
          (op) => op.parentId === this._id
        );
        if (createCrdtOp) {
          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));
        }
        ops.push(...newAttachChildOps);
      } else {
        updatedProps[key] = newValue;
        this._propToLastUpdate.set(key, opId);
      }
      this._map.set(key, newValue);
      this.invalidate();
      updateDelta[key] = { type: "update" };
    }
    if (Object.keys(reverseUpdateOp.data).length !== 0) {
      reverseOps.unshift(reverseUpdateOp);
    }
    if (Object.keys(updatedProps).length !== 0) {
      ops.unshift({
        opId,
        id: this._id,
        type: 3 /* UPDATE_OBJECT */,
        data: updatedProps
      });
    }
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: updateDelta
    });
    this._pool.dispatch(ops, reverseOps, storageUpdates);
  }
  toImmutable() {
    return super.toImmutable();
  }
  _toImmutable() {
    const result = {};
    for (const [key, val] of this._map) {
      result[key] = isLiveStructure(val) ? val.toImmutable() : val;
    }
    return process.env.NODE_ENV === "production" ? result : Object.freeze(result);
  }
};

// src/utils.ts
var freeze = process.env.NODE_ENV === "production" ? (x) => x : Object.freeze;
function compact(items) {
  return items.filter(
    (item) => item !== null && item !== void 0
  );
}
function compactObject(obj) {
  const newObj = __spreadValues({}, obj);
  Object.keys(obj).forEach((k) => {
    const key = k;
    if (newObj[key] === void 0) {
      delete newObj[key];
    }
  });
  return newObj;
}
function creationOpToLiveNode(op) {
  return lsonToLiveNode(creationOpToLson(op));
}
function creationOpToLson(op) {
  switch (op.type) {
    case 8 /* CREATE_REGISTER */:
      return op.data;
    case 4 /* CREATE_OBJECT */:
      return new LiveObject(op.data);
    case 7 /* CREATE_MAP */:
      return new LiveMap();
    case 2 /* CREATE_LIST */:
      return new LiveList();
    default:
      return assertNever(op, "Unknown creation Op");
  }
}
function isSameNodeOrChildOf(node, parent) {
  if (node === parent) {
    return true;
  }
  if (node.parent.type === "HasParent") {
    return isSameNodeOrChildOf(node.parent.node, parent);
  }
  return false;
}
function deserialize([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0 /* OBJECT */: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1 /* LIST */: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2 /* MAP */: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3 /* REGISTER */: {
      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function deserializeToLson([id, crdt], parentToChildren, pool) {
  switch (crdt.type) {
    case 0 /* OBJECT */: {
      return LiveObject._deserialize([id, crdt], parentToChildren, pool);
    }
    case 1 /* LIST */: {
      return LiveList._deserialize([id, crdt], parentToChildren, pool);
    }
    case 2 /* MAP */: {
      return LiveMap._deserialize([id, crdt], parentToChildren, pool);
    }
    case 3 /* REGISTER */: {
      return crdt.data;
    }
    default: {
      throw new Error("Unexpected CRDT type");
    }
  }
}
function isLiveStructure(value) {
  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);
}
function isLiveNode(value) {
  return isLiveStructure(value) || isLiveRegister(value);
}
function isLiveList(value) {
  return value instanceof LiveList;
}
function isLiveMap(value) {
  return value instanceof LiveMap;
}
function isLiveObject(value) {
  return value instanceof LiveObject;
}
function isLiveRegister(value) {
  return value instanceof LiveRegister;
}
function liveNodeToLson(obj) {
  if (obj instanceof LiveRegister) {
    return obj.data;
  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {
    return obj;
  } else {
    return assertNever(obj, "Unknown AbstractCrdt");
  }
}
function lsonToLiveNode(value) {
  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {
    return value;
  } else {
    return new LiveRegister(value);
  }
}
function getTreesDiffOperations(currentItems, newItems) {
  const ops = [];
  currentItems.forEach((_, id) => {
    if (!newItems.get(id)) {
      ops.push({
        type: 5 /* DELETE_CRDT */,
        id
      });
    }
  });
  newItems.forEach((crdt, id) => {
    const currentCrdt = currentItems.get(id);
    if (currentCrdt) {
      if (crdt.type === 0 /* OBJECT */) {
        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {
          ops.push({
            type: 3 /* UPDATE_OBJECT */,
            id,
            data: crdt.data
          });
        }
      }
      if (crdt.parentKey !== currentCrdt.parentKey) {
        ops.push({
          type: 1 /* SET_PARENT_KEY */,
          id,
          parentKey: nn(crdt.parentKey, "Parent key must not be missing")
        });
      }
    } else {
      switch (crdt.type) {
        case 3 /* REGISTER */:
          ops.push({
            type: 8 /* CREATE_REGISTER */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey,
            data: crdt.data
          });
          break;
        case 1 /* LIST */:
          ops.push({
            type: 2 /* CREATE_LIST */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
        case 0 /* OBJECT */:
          ops.push(
            crdt.parentId ? {
              type: 4 /* CREATE_OBJECT */,
              id,
              parentId: crdt.parentId,
              parentKey: crdt.parentKey,
              data: crdt.data
            } : { type: 4 /* CREATE_OBJECT */, id, data: crdt.data }
          );
          break;
        case 2 /* MAP */:
          ops.push({
            type: 7 /* CREATE_MAP */,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
      }
    }
  });
  return ops;
}
function mergeObjectStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return __spreadProps(__spreadValues({}, second), {
    updates
  });
}
function mergeMapStorageUpdates(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) {
    updates[key] = value;
  }
  return __spreadProps(__spreadValues({}, second), {
    updates
  });
}
function mergeListStorageUpdates(first, second) {
  const updates = first.updates;
  return __spreadProps(__spreadValues({}, second), {
    updates: updates.concat(second.updates)
  });
}
function mergeStorageUpdates(first, second) {
  if (!first) {
    return second;
  }
  if (first.type === "LiveObject" && second.type === "LiveObject") {
    return mergeObjectStorageUpdates(first, second);
  } else if (first.type === "LiveMap" && second.type === "LiveMap") {
    return mergeMapStorageUpdates(first, second);
  } else if (first.type === "LiveList" && second.type === "LiveList") {
    return mergeListStorageUpdates(first, second);
  } else {
  }
  return second;
}
function isPlain(value) {
  const type = typeof value;
  return value === void 0 || value === null || type === "string" || type === "boolean" || type === "number" || Array.isArray(value) || isPlainObject(value);
}
function isPlainObject(blob) {
  return blob !== null && typeof blob === "object" && Object.prototype.toString.call(blob) === "[object Object]";
}
function findNonSerializableValue(value, path = "") {
  if (!isPlain) {
    return {
      path: path || "root",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  for (const [key, nestedValue] of Object.entries(value)) {
    const nestedPath = path ? path + "." + key : key;
    if (!isPlain(nestedValue)) {
      return {
        path: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      const nonSerializableNestedValue = findNonSerializableValue(
        nestedValue,
        nestedPath
      );
      if (nonSerializableNestedValue) {
        return nonSerializableNestedValue;
      }
    }
  }
  return false;
}
function fromEntries(iterable) {
  const obj = {};
  for (const [key, val] of iterable) {
    obj[key] = val;
  }
  return obj;
}
function entries(obj) {
  return Object.entries(obj);
}
function tryParseJson(rawMessage) {
  try {
    return JSON.parse(rawMessage);
  } catch (e) {
    return void 0;
  }
}
function b64decode(b64value) {
  try {
    const formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
    const decodedValue = decodeURIComponent(
      atob(formattedValue).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join("")
    );
    return decodedValue;
  } catch (err) {
    return atob(b64value);
  }
}

// src/LiveList.ts
function compareNodePosition(itemA, itemB) {
  return comparePosition(
    itemA._getParentKeyOrThrow(),
    itemB._getParentKeyOrThrow()
  );
}
var LiveList = class extends AbstractCrdt {
  constructor(items = []) {
    super();
    this._items = [];
    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();
    this._unacknowledgedSets = /* @__PURE__ */ new Map();
    let position = void 0;
    for (let i = 0; i < items.length; i++) {
      const newPosition = makePosition(position);
      const item = lsonToLiveNode(items[i]);
      item._setParentLink(this, newPosition);
      this._items.push(item);
      position = newPosition;
    }
  }
  static _deserialize([id], parentToChildren, pool) {
    const list = new LiveList();
    list._attach(id, pool);
    const children = parentToChildren.get(id);
    if (children === void 0) {
      return list;
    }
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, pool);
      child._setParentLink(list, crdt.parentKey);
      list._insertAndSort(child);
    }
    return list;
  }
  _toOps(parentId, parentKey, pool) {
    if (this._id === void 0) {
      throw new Error("Cannot serialize item is not attached");
    }
    const ops = [];
    const op = {
      id: this._id,
      opId: pool == null ? void 0 : pool.generateOpId(),
      type: 2 /* CREATE_LIST */,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const item of this._items) {
      ops.push(...item._toOps(this._id, item._getParentKeyOrThrow(), pool));
    }
    return ops;
  }
  _insertAndSort(item) {
    this._items.push(item);
    this._sortItems();
  }
  _sortItems() {
    this._items.sort(compareNodePosition);
    this.invalidate();
  }
  _indexOfPosition(position) {
    return this._items.findIndex(
      (item) => item._getParentKeyOrThrow() === position
    );
  }
  _attach(id, pool) {
    super._attach(id, pool);
    for (const item of this._items) {
      item._attach(pool.generateId(), pool);
    }
  }
  _detach() {
    super._detach();
    for (const item of this._items) {
      item._detach();
    }
  }
  _applySetRemote(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    child._attach(id, this._pool);
    child._setParentLink(this, key);
    const deletedId = op.deletedId;
    const indexOfItemWithSamePosition = this._indexOfPosition(key);
    if (indexOfItemWithSamePosition !== -1) {
      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];
      if (itemWithSamePosition._id === deletedId) {
        itemWithSamePosition._detach();
        this._items[indexOfItemWithSamePosition] = child;
        return {
          modified: makeUpdate(this, [
            setDelta(indexOfItemWithSamePosition, child)
          ]),
          reverse: []
        };
      } else {
        this._implicitlyDeletedItems.add(itemWithSamePosition);
        this._items[indexOfItemWithSamePosition] = child;
        const delta = [
          setDelta(indexOfItemWithSamePosition, child)
        ];
        const deleteDelta2 = this._detachItemAssociatedToSetOperation(
          op.deletedId
        );
        if (deleteDelta2) {
          delta.push(deleteDelta2);
        }
        return {
          modified: makeUpdate(this, delta),
          reverse: []
        };
      }
    } else {
      const updates = [];
      const deleteDelta2 = this._detachItemAssociatedToSetOperation(
        op.deletedId
      );
      if (deleteDelta2) {
        updates.push(deleteDelta2);
      }
      this._insertAndSort(child);
      updates.push(insertDelta(this._indexOfPosition(key), child));
      return {
        reverse: [],
        modified: makeUpdate(this, updates)
      };
    }
  }
  _applySetAck(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const delta = [];
    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
    if (deletedDelta) {
      delta.push(deletedDelta);
    }
    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);
    if (unacknowledgedOpId !== void 0) {
      if (unacknowledgedOpId !== op.opId) {
        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };
      } else {
        this._unacknowledgedSets.delete(op.parentKey);
      }
    }
    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);
    const existingItem = this._items.find((item) => item._id === op.id);
    if (existingItem !== void 0) {
      if (existingItem._parentKey === op.parentKey) {
        return {
          modified: delta.length > 0 ? makeUpdate(this, delta) : false,
          reverse: []
        };
      }
      if (indexOfItemWithSamePosition !== -1) {
        this._implicitlyDeletedItems.add(
          this._items[indexOfItemWithSamePosition]
        );
        this._items.splice(indexOfItemWithSamePosition, 1);
        delta.push(deleteDelta(indexOfItemWithSamePosition));
      }
      const previousIndex = this._items.indexOf(existingItem);
      existingItem._setParentLink(this, op.parentKey);
      this._sortItems();
      const newIndex = this._items.indexOf(existingItem);
      if (newIndex !== previousIndex) {
        delta.push(moveDelta(previousIndex, newIndex, existingItem));
      }
      return {
        modified: delta.length > 0 ? makeUpdate(this, delta) : false,
        reverse: []
      };
    } else {
      const orphan = this._pool.getNode(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, op.parentKey);
        this._implicitlyDeletedItems.delete(orphan);
        this._insertAndSort(orphan);
        const recreatedItemIndex = this._items.indexOf(orphan);
        return {
          modified: makeUpdate(this, [
            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),
            ...delta
          ]),
          reverse: []
        };
      } else {
        if (indexOfItemWithSamePosition !== -1) {
          this._items.splice(indexOfItemWithSamePosition, 1);
        }
        const { newItem, newIndex } = this._createAttachItemAndSort(
          op,
          op.parentKey
        );
        return {
          modified: makeUpdate(this, [
            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),
            ...delta
          ]),
          reverse: []
        };
      }
    }
  }
  _detachItemAssociatedToSetOperation(deletedId) {
    if (deletedId === void 0 || this._pool === void 0) {
      return null;
    }
    const deletedItem = this._pool.getNode(deletedId);
    if (deletedItem === void 0) {
      return null;
    }
    const result = this._detachChild(deletedItem);
    if (result.modified === false) {
      return null;
    }
    return result.modified.updates[0];
  }
  _applyRemoteInsert(op) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    const key = op.parentKey;
    const existingItemIndex = this._indexOfPosition(key);
    if (existingItemIndex !== -1) {
      this._shiftItemPosition(existingItemIndex, key);
    }
    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
      reverse: []
    };
  }
  _applyInsertAck(op) {
    const existingItem = this._items.find((item) => item._id === op.id);
    const key = op.parentKey;
    const itemIndexAtPosition = this._indexOfPosition(key);
    if (existingItem) {
      if (existingItem._parentKey === key) {
        return {
          modified: false
        };
      } else {
        const oldPositionIndex = this._items.indexOf(existingItem);
        if (itemIndexAtPosition !== -1) {
          this._shiftItemPosition(itemIndexAtPosition, key);
        }
        existingItem._setParentLink(this, key);
        this._sortItems();
        const newIndex = this._indexOfPosition(key);
        if (newIndex === oldPositionIndex) {
          return { modified: false };
        }
        return {
          modified: makeUpdate(this, [
            moveDelta(oldPositionIndex, newIndex, existingItem)
          ]),
          reverse: []
        };
      }
    } else {
      const orphan = nn(this._pool).getNode(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, key);
        this._implicitlyDeletedItems.delete(orphan);
        this._insertAndSort(orphan);
        const newIndex = this._indexOfPosition(key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),
          reverse: []
        };
      } else {
        if (itemIndexAtPosition !== -1) {
          this._shiftItemPosition(itemIndexAtPosition, key);
        }
        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
          reverse: []
        };
      }
    }
  }
  _applyInsertUndoRedo(op) {
    var _a;
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {
      return { modified: false };
    }
    child._attach(id, nn(this._pool));
    child._setParentLink(this, key);
    const existingItemIndex = this._indexOfPosition(key);
    let newKey = key;
    if (existingItemIndex !== -1) {
      const before = this._items[existingItemIndex] ? this._items[existingItemIndex]._getParentKeyOrThrow() : void 0;
      const after = this._items[existingItemIndex + 1] ? this._items[existingItemIndex + 1]._getParentKeyOrThrow() : void 0;
      newKey = makePosition(before, after);
      child._setParentLink(this, newKey);
    }
    this._insertAndSort(child);
    const newIndex = this._indexOfPosition(newKey);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, child)]),
      reverse: [{ type: 5 /* DELETE_CRDT */, id }]
    };
  }
  _applySetUndoRedo(op) {
    var _a;
    const { id, parentKey: key } = op;
    const child = creationOpToLiveNode(op);
    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {
      return { modified: false };
    }
    this._unacknowledgedSets.set(key, nn(op.opId));
    const indexOfItemWithSameKey = this._indexOfPosition(key);
    child._attach(id, nn(this._pool));
    child._setParentLink(this, key);
    const newKey = key;
    if (indexOfItemWithSameKey !== -1) {
      const existingItem = this._items[indexOfItemWithSameKey];
      existingItem._detach();
      this._items[indexOfItemWithSameKey] = child;
      const reverse = existingItem._toOps(nn(this._id), key, this._pool);
      addIntentAndDeletedIdToOperation(reverse, op.id);
      const delta = [setDelta(indexOfItemWithSameKey, child)];
      const deletedDelta = this._detachItemAssociatedToSetOperation(
        op.deletedId
      );
      if (deletedDelta) {
        delta.push(deletedDelta);
      }
      return {
        modified: makeUpdate(this, delta),
        reverse
      };
    } else {
      this._insertAndSort(child);
      this._detachItemAssociatedToSetOperation(op.deletedId);
      const newIndex = this._indexOfPosition(newKey);
      return {
        reverse: [{ type: 5 /* DELETE_CRDT */, id }],
        modified: makeUpdate(this, [insertDelta(newIndex, child)])
      };
    }
  }
  _attachChild(op, source) {
    if (this._pool === void 0) {
      throw new Error("Can't attach child if managed pool is not present");
    }
    let result;
    if (op.intent === "set") {
      if (source === 1 /* REMOTE */) {
        result = this._applySetRemote(op);
      } else if (source === 2 /* ACK */) {
        result = this._applySetAck(op);
      } else {
        result = this._applySetUndoRedo(op);
      }
    } else {
      if (source === 1 /* REMOTE */) {
        result = this._applyRemoteInsert(op);
      } else if (source === 2 /* ACK */) {
        result = this._applyInsertAck(op);
      } else {
        result = this._applyInsertUndoRedo(op);
      }
    }
    if (result.modified !== false) {
      this.invalidate();
    }
    return result;
  }
  _detachChild(child) {
    if (child) {
      const parentKey = nn(child._parentKey);
      const reverse = child._toOps(nn(this._id), parentKey, this._pool);
      const indexToDelete = this._items.indexOf(child);
      if (indexToDelete === -1) {
        return {
          modified: false
        };
      }
      this._items.splice(indexToDelete, 1);
      this.invalidate();
      child._detach();
      return {
        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),
        reverse
      };
    }
    return { modified: false };
  }
  _applySetChildKeyRemote(newKey, child) {
    var _a;
    if (this._implicitlyDeletedItems.has(child)) {
      this._implicitlyDeletedItems.delete(child);
      child._setParentLink(this, newKey);
      this._insertAndSort(child);
      const newIndex = this._items.indexOf(child);
      return {
        modified: makeUpdate(this, [insertDelta(newIndex, child)]),
        reverse: []
      };
    }
    const previousKey = child._parentKey;
    if (newKey === previousKey) {
      return {
        modified: false
      };
    }
    const existingItemIndex = this._indexOfPosition(newKey);
    if (existingItemIndex === -1) {
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this._items.indexOf(child);
      if (newIndex === previousIndex) {
        return {
          modified: false
        };
      }
      return {
        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
        reverse: []
      };
    } else {
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()
        )
      );
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this._items.indexOf(child);
      if (newIndex === previousIndex) {
        return {
          modified: false
        };
      }
      return {
        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
        reverse: []
      };
    }
  }
  _applySetChildKeyAck(newKey, child) {
    var _a, _b;
    const previousKey = nn(child._parentKey);
    if (this._implicitlyDeletedItems.has(child)) {
      const existingItemIndex = this._indexOfPosition(newKey);
      this._implicitlyDeletedItems.delete(child);
      if (existingItemIndex !== -1) {
        this._items[existingItemIndex]._setParentLink(
          this,
          makePosition(
            newKey,
            (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()
          )
        );
      }
      child._setParentLink(this, newKey);
      this._insertAndSort(child);
      return {
        modified: false
      };
    } else {
      if (newKey === previousKey) {
        return {
          modified: false
        };
      }
      const previousIndex = this._items.indexOf(child);
      const existingItemIndex = this._indexOfPosition(newKey);
      if (existingItemIndex !== -1) {
        this._items[existingItemIndex]._setParentLink(
          this,
          makePosition(
            newKey,
            (_b = this._items[existingItemIndex + 1]) == null ? void 0 : _b._getParentKeyOrThrow()
          )
        );
      }
      child._setParentLink(this, newKey);
      this._sortItems();
      const newIndex = this._items.indexOf(child);
      if (previousIndex === newIndex) {
        return {
          modified: false
        };
      } else {
        return {
          modified: makeUpdate(this, [
            moveDelta(previousIndex, newIndex, child)
          ]),
          reverse: []
        };
      }
    }
  }
  _applySetChildKeyUndoRedo(newKey, child) {
    var _a;
    const previousKey = nn(child._parentKey);
    const previousIndex = this._items.indexOf(child);
    const existingItemIndex = this._indexOfPosition(newKey);
    if (existingItemIndex !== -1) {
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()
        )
      );
    }
    child._setParentLink(this, newKey);
    this._sortItems();
    const newIndex = this._items.indexOf(child);
    if (previousIndex === newIndex) {
      return {
        modified: false
      };
    }
    return {
      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),
      reverse: [
        {
          type: 1 /* SET_PARENT_KEY */,
          id: nn(child._id),
          parentKey: previousKey
        }
      ]
    };
  }
  _setChildKey(newKey, child, source) {
    if (source === 1 /* REMOTE */) {
      return this._applySetChildKeyRemote(newKey, child);
    } else if (source === 2 /* ACK */) {
      return this._applySetChildKeyAck(newKey, child);
    } else {
      return this._applySetChildKeyUndoRedo(newKey, child);
    }
  }
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  _serialize() {
    if (this.parent.type !== "HasParent") {
      throw new Error("Cannot serialize LiveList if parent is missing");
    }
    return {
      type: 1 /* LIST */,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  get length() {
    return this._items.length;
  }
  push(element) {
    return this.insert(element, this.length);
  }
  insert(element, index) {
    if (index < 0 || index > this._items.length) {
      throw new Error(
        `Cannot insert list item at index "${index}". index should be between 0 and ${this._items.length}`
      );
    }
    const before = this._items[index - 1] ? this._items[index - 1]._getParentKeyOrThrow() : void 0;
    const after = this._items[index] ? this._items[index]._getParentKeyOrThrow() : void 0;
    const position = makePosition(before, after);
    const value = lsonToLiveNode(element);
    value._setParentLink(this, position);
    this._insertAndSort(value);
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      this._pool.dispatch(
        value._toOps(this._id, position, this._pool),
        [{ type: 5 /* DELETE_CRDT */, id }],
        /* @__PURE__ */ new Map([
          [this._id, makeUpdate(this, [insertDelta(index, value)])]
        ])
      );
    }
  }
  move(index, targetIndex) {
    if (targetIndex < 0) {
      throw new Error("targetIndex cannot be less than 0");
    }
    if (targetIndex >= this._items.length) {
      throw new Error(
        "targetIndex cannot be greater or equal than the list length"
      );
    }
    if (index < 0) {
      throw new Error("index cannot be less than 0");
    }
    if (index >= this._items.length) {
      throw new Error("index cannot be greater or equal than the list length");
    }
    let beforePosition = null;
    let afterPosition = null;
    if (index < targetIndex) {
      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._getParentKeyOrThrow();
      beforePosition = this._items[targetIndex]._getParentKeyOrThrow();
    } else {
      afterPosition = this._items[targetIndex]._getParentKeyOrThrow();
      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._getParentKeyOrThrow();
    }
    const position = makePosition(beforePosition, afterPosition);
    const item = this._items[index];
    const previousPosition = item._getParentKeyOrThrow();
    item._setParentLink(this, position);
    this._sortItems();
    if (this._pool && this._id) {
      const storageUpdates = /* @__PURE__ */ new Map([
        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]
      ]);
      this._pool.dispatch(
        [
          {
            type: 1 /* SET_PARENT_KEY */,
            id: nn(item._id),
            opId: this._pool.generateOpId(),
            parentKey: position
          }
        ],
        [
          {
            type: 1 /* SET_PARENT_KEY */,
            id: nn(item._id),
            parentKey: previousPosition
          }
        ],
        storageUpdates
      );
    }
  }
  delete(index) {
    if (index < 0 || index >= this._items.length) {
      throw new Error(
        `Cannot delete list item at index "${index}". index should be between 0 and ${this._items.length - 1}`
      );
    }
    const item = this._items[index];
    item._detach();
    this._items.splice(index, 1);
    this.invalidate();
    if (this._pool) {
      const childRecordId = item._id;
      if (childRecordId) {
        const storageUpdates = /* @__PURE__ */ new Map();
        storageUpdates.set(
          nn(this._id),
          makeUpdate(this, [deleteDelta(index)])
        );
        this._pool.dispatch(
          [
            {
              id: childRecordId,
              opId: this._pool.generateOpId(),
              type: 5 /* DELETE_CRDT */
            }
          ],
          item._toOps(nn(this._id), item._getParentKeyOrThrow()),
          storageUpdates
        );
      }
    }
  }
  clear() {
    if (this._pool) {
      const ops = [];
      const reverseOps = [];
      const updateDelta = [];
      for (const item of this._items) {
        item._detach();
        const childId = item._id;
        if (childId) {
          ops.push({
            type: 5 /* DELETE_CRDT */,
            id: childId,
            opId: this._pool.generateOpId()
          });
          reverseOps.push(
            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())
          );
          updateDelta.push(deleteDelta(0));
        }
      }
      this._items = [];
      this.invalidate();
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    } else {
      for (const item of this._items) {
        item._detach();
      }
      this._items = [];
      this.invalidate();
    }
  }
  set(index, item) {
    if (index < 0 || index >= this._items.length) {
      throw new Error(
        `Cannot set list item at index "${index}". index should be between 0 and ${this._items.length - 1}`
      );
    }
    const existingItem = this._items[index];
    const position = existingItem._getParentKeyOrThrow();
    const existingId = existingItem._id;
    existingItem._detach();
    const value = lsonToLiveNode(item);
    value._setParentLink(this, position);
    this._items[index] = value;
    this.invalidate();
    if (this._pool && this._id) {
      const id = this._pool.generateId();
      value._attach(id, this._pool);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));
      const ops = value._toOps(this._id, position, this._pool);
      addIntentAndDeletedIdToOperation(ops, existingId);
      this._unacknowledgedSets.set(position, nn(ops[0].opId));
      const reverseOps = existingItem._toOps(this._id, position, void 0);
      addIntentAndDeletedIdToOperation(reverseOps, id);
      this._pool.dispatch(ops, reverseOps, storageUpdates);
    }
  }
  toArray() {
    return this._items.map(
      (entry) => liveNodeToLson(entry)
    );
  }
  every(predicate) {
    return this.toArray().every(predicate);
  }
  filter(predicate) {
    return this.toArray().filter(predicate);
  }
  find(predicate) {
    return this.toArray().find(predicate);
  }
  findIndex(predicate) {
    return this.toArray().findIndex(predicate);
  }
  forEach(callbackfn) {
    return this.toArray().forEach(callbackfn);
  }
  get(index) {
    if (index < 0 || index >= this._items.length) {
      return void 0;
    }
    return liveNodeToLson(this._items[index]);
  }
  indexOf(searchElement, fromIndex) {
    return this.toArray().indexOf(searchElement, fromIndex);
  }
  lastIndexOf(searchElement, fromIndex) {
    return this.toArray().lastIndexOf(searchElement, fromIndex);
  }
  map(callback) {
    return this._items.map(
      (entry, i) => callback(
        liveNodeToLson(entry),
        i
      )
    );
  }
  some(predicate) {
    return this.toArray().some(predicate);
  }
  [Symbol.iterator]() {
    return new LiveListIterator(this._items);
  }
  _createAttachItemAndSort(op, key) {
    const newItem = creationOpToLiveNode(op);
    newItem._attach(op.id, nn(this._pool));
    newItem._setParentLink(this, key);
    this._insertAndSort(newItem);
    const newIndex = this._indexOfPosition(key);
    return { newItem, newIndex };
  }
  _shiftItemPosition(index, key) {
    var _a;
    const shiftedPosition = makePosition(
      key,
      this._items.length > index + 1 ? (_a = this._items[index + 1]) == null ? void 0 : _a._getParentKeyOrThrow() : void 0
    );
    this._items[index]._setParentLink(this, shiftedPosition);
  }
  toImmutable() {
    return super.toImmutable();
  }
  _toImmutable() {
    const result = this._items.map((node) => node.toImmutable());
    return process.env.NODE_ENV === "production" ? result : Object.freeze(result);
  }
};
var LiveListIterator = class {
  constructor(items) {
    this._innerIterator = items[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const result = this._innerIterator.next();
    if (result.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const value = liveNodeToLson(result.value);
    return { value };
  }
};
function makeUpdate(liveList, deltaUpdates) {
  return {
    node: liveList,
    type: "LiveList",
    updates: deltaUpdates
  };
}
function setDelta(index, item) {
  return {
    index,
    type: "set",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function deleteDelta(index) {
  return {
    index,
    type: "delete"
  };
}
function insertDelta(index, item) {
  return {
    index,
    type: "insert",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function moveDelta(previousIndex, index, item) {
  return {
    index,
    type: "move",
    previousIndex,
    item: item instanceof LiveRegister ? item.data : item
  };
}
function addIntentAndDeletedIdToOperation(ops, deletedId) {
  if (ops.length === 0) {
    throw new Error(
      "Internal error. Serialized LiveStructure should have at least 1 operation"
    );
  }
  const firstOp = ops[0];
  firstOp.intent = "set";
  firstOp.deletedId = deletedId;
}

// src/AuthToken.ts
var SCOPES = [
  "websocket:presence",
  "websocket:storage",
  "room:read",
  "room:write",
  "rooms:read",
  "rooms:write"
];
function hasJwtMeta(data) {
  if (!isPlainObject(data)) {
    return false;
  }
  const { iat, exp } = data;
  return typeof iat === "number" && typeof exp === "number";
}
function isTokenExpired(token) {
  const now = Date.now() / 1e3;
  return now > token.exp - 300 || now < token.iat + 300;
}
function isScope(value) {
  return SCOPES.includes(value);
}
function isStringList(value) {
  return Array.isArray(value) && value.every((i) => typeof i === "string");
}
function isAppOnlyAuthToken(data) {
  return typeof data.appId === "string" && data.roomId === void 0 && isStringList(data.scopes);
}
function isRoomAuthToken(data) {
  return typeof data.appId === "string" && typeof data.roomId === "string" && typeof data.actor === "number" && (data.id === void 0 || typeof data.id === "string") && isStringList(data.scopes) && (data.maxConnectionsPerRoom === void 0 || typeof data.maxConnectionsPerRoom === "number");
}
function isAuthToken(data) {
  return isAppOnlyAuthToken(data) || isRoomAuthToken(data);
}
function parseJwtToken(token) {
  const tokenParts = token.split(".");
  if (tokenParts.length !== 3) {
    throw new Error("Authentication error: invalid JWT token");
  }
  const data = tryParseJson(b64decode(tokenParts[1]));
  if (data && hasJwtMeta(data)) {
    return data;
  } else {
    throw new Error("Authentication error: missing JWT metadata");
  }
}
function parseRoomAuthToken(tokenString) {
  const data = parseJwtToken(tokenString);
  if (data && isRoomAuthToken(data)) {
    const _a = data, {
      maxConnections: _legacyField
    } = _a, token = __objRest(_a, [
      "maxConnections"
    ]);
    return token;
  } else {
    throw new Error(
      "Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
    );
  }
}

// src/LegacyArray.ts
function asArrayWithLegacyMethods(arr) {
  Object.defineProperty(arr, "count", {
    value: arr.length,
    enumerable: false
  });
  Object.defineProperty(arr, "toArray", {
    value: () => arr,
    enumerable: false
  });
  return freeze(arr);
}

// src/types/Json.ts
function isJsonScalar(data) {
  return data === null || typeof data === "string" || typeof data === "number" || typeof data === "boolean";
}
function isJsonArray(data) {
  return Array.isArray(data);
}
function isJsonObject(data) {
  return !isJsonScalar(data) && !isJsonArray(data);
}
















































exports.__spreadValues = __spreadValues; exports.__spreadProps = __spreadProps; exports.__async = __async; exports.deprecate = deprecate; exports.deprecateIf = deprecateIf; exports.throwUsageError = throwUsageError; exports.errorIf = errorIf; exports.assertNever = assertNever; exports.nn = nn; exports.ClientMsgCode = ClientMsgCode; exports.OpCode = OpCode; exports.CrdtType = CrdtType; exports.isRootCrdt = isRootCrdt; exports.isChildCrdt = isChildCrdt; exports.ServerMsgCode = ServerMsgCode; exports.isRoomEventName = isRoomEventName; exports.WebsocketCloseCodes = WebsocketCloseCodes; exports.LiveRegister = LiveRegister; exports.makePosition = makePosition; exports.comparePosition = comparePosition; exports.LiveList = LiveList; exports.LiveMap = LiveMap; exports.LiveObject = LiveObject; exports.freeze = freeze; exports.compact = compact; exports.compactObject = compactObject; exports.isSameNodeOrChildOf = isSameNodeOrChildOf; exports.isLiveNode = isLiveNode; exports.isLiveList = isLiveList; exports.isLiveObject = isLiveObject; exports.getTreesDiffOperations = getTreesDiffOperations; exports.mergeStorageUpdates = mergeStorageUpdates; exports.isPlainObject = isPlainObject; exports.findNonSerializableValue = findNonSerializableValue; exports.tryParseJson = tryParseJson; exports.b64decode = b64decode; exports.isTokenExpired = isTokenExpired; exports.isScope = isScope; exports.isAppOnlyAuthToken = isAppOnlyAuthToken; exports.isRoomAuthToken = isRoomAuthToken; exports.isAuthToken = isAuthToken; exports.parseRoomAuthToken = parseRoomAuthToken; exports.asArrayWithLegacyMethods = asArrayWithLegacyMethods; exports.isJsonScalar = isJsonScalar; exports.isJsonArray = isJsonArray; exports.isJsonObject = isJsonObject;
