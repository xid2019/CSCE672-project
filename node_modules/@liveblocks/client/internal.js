"use strict";Object.defineProperty(exports, "__esModule", {value: true});




































var _chunkUV2F4F4Rjs = require('./chunk-UV2F4F4R.js');

// src/immutable.ts
function lsonObjectToJson(obj) {
  const result = {};
  for (const key in obj) {
    const val = obj[key];
    if (val !== void 0) {
      result[key] = lsonToJson(val);
    }
  }
  return result;
}
function liveObjectToJson(liveObject) {
  return lsonObjectToJson(liveObject.toObject());
}
function liveMapToJson(map) {
  const result = {};
  for (const [key, value] of map.entries()) {
    result[key] = lsonToJson(value);
  }
  return result;
}
function lsonListToJson(value) {
  return value.map(lsonToJson);
}
function liveListToJson(value) {
  return lsonListToJson(value.toArray());
}
function lsonToJson(value) {
  if (value instanceof _chunkUV2F4F4Rjs.LiveObject) {
    return liveObjectToJson(value);
  } else if (value instanceof _chunkUV2F4F4Rjs.LiveList) {
    return liveListToJson(value);
  } else if (value instanceof _chunkUV2F4F4Rjs.LiveMap) {
    return liveMapToJson(value);
  } else if (value instanceof _chunkUV2F4F4Rjs.LiveRegister) {
    return value.data;
  }
  if (Array.isArray(value)) {
    return lsonListToJson(value);
  } else if (_chunkUV2F4F4Rjs.isPlainObject.call(void 0, value)) {
    return lsonObjectToJson(value);
  }
  return value;
}
function deepLiveify(value) {
  if (Array.isArray(value)) {
    return new (0, _chunkUV2F4F4Rjs.LiveList)(value.map(deepLiveify));
  } else if (_chunkUV2F4F4Rjs.isPlainObject.call(void 0, value)) {
    const init = {};
    for (const key in value) {
      const val = value[key];
      if (val === void 0) {
        continue;
      }
      init[key] = deepLiveify(val);
    }
    return new (0, _chunkUV2F4F4Rjs.LiveObject)(init);
  } else {
    return value;
  }
}
function patchLiveList(liveList, prev, next) {
  let i = 0;
  let prevEnd = prev.length - 1;
  let nextEnd = next.length - 1;
  let prevNode = prev[0];
  let nextNode = next[0];
  outer: {
    while (prevNode === nextNode) {
      ++i;
      if (i > prevEnd || i > nextEnd) {
        break outer;
      }
      prevNode = prev[i];
      nextNode = next[i];
    }
    prevNode = prev[prevEnd];
    nextNode = next[nextEnd];
    while (prevNode === nextNode) {
      prevEnd--;
      nextEnd--;
      if (i > prevEnd || i > nextEnd) {
        break outer;
      }
      prevNode = prev[prevEnd];
      nextNode = next[nextEnd];
    }
  }
  if (i > prevEnd) {
    if (i <= nextEnd) {
      while (i <= nextEnd) {
        liveList.insert(deepLiveify(next[i]), i);
        i++;
      }
    }
  } else if (i > nextEnd) {
    let localI = i;
    while (localI <= prevEnd) {
      liveList.delete(i);
      localI++;
    }
  } else {
    while (i <= prevEnd && i <= nextEnd) {
      prevNode = prev[i];
      nextNode = next[i];
      const liveListNode = liveList.get(i);
      if (_chunkUV2F4F4Rjs.isLiveObject.call(void 0, liveListNode) && _chunkUV2F4F4Rjs.isPlainObject.call(void 0, prevNode) && _chunkUV2F4F4Rjs.isPlainObject.call(void 0, nextNode)) {
        patchLiveObject(liveListNode, prevNode, nextNode);
      } else {
        liveList.set(i, deepLiveify(nextNode));
      }
      i++;
    }
    while (i <= nextEnd) {
      liveList.insert(deepLiveify(next[i]), i);
      i++;
    }
    let localI = i;
    while (localI <= prevEnd) {
      liveList.delete(i);
      localI++;
    }
  }
}
function patchLiveObjectKey(liveObject, key, prev, next) {
  if (process.env.NODE_ENV !== "production") {
    const nonSerializableValue = _chunkUV2F4F4Rjs.findNonSerializableValue.call(void 0, next);
    if (nonSerializableValue) {
      console.error(
        `New state path: '${nonSerializableValue.path}' value: '${nonSerializableValue.value}' is not serializable.
Only serializable value can be synced with Liveblocks.`
      );
      return;
    }
  }
  const value = liveObject.get(key);
  if (next === void 0) {
    liveObject.delete(key);
  } else if (value === void 0) {
    liveObject.set(key, deepLiveify(next));
  } else if (prev === next) {
    return;
  } else if (_chunkUV2F4F4Rjs.isLiveList.call(void 0, value) && Array.isArray(prev) && Array.isArray(next)) {
    patchLiveList(value, prev, next);
  } else if (_chunkUV2F4F4Rjs.isLiveObject.call(void 0, value) && _chunkUV2F4F4Rjs.isPlainObject.call(void 0, prev) && _chunkUV2F4F4Rjs.isPlainObject.call(void 0, next)) {
    patchLiveObject(value, prev, next);
  } else {
    liveObject.set(key, deepLiveify(next));
  }
}
function patchLiveObject(root, prev, next) {
  const updates = {};
  for (const key in next) {
    patchLiveObjectKey(root, key, prev[key], next[key]);
  }
  for (const key in prev) {
    if (next[key] === void 0) {
      root.delete(key);
    }
  }
  if (Object.keys(updates).length > 0) {
    root.update(updates);
  }
}
function getParentsPath(node) {
  const path = [];
  while (node.parent.type === "HasParent") {
    if (_chunkUV2F4F4Rjs.isLiveList.call(void 0, node.parent.node)) {
      path.push(node.parent.node._indexOfPosition(node.parent.key));
    } else {
      path.push(node.parent.key);
    }
    node = node.parent.node;
  }
  return path;
}
function legacy_patchImmutableObject(state, updates) {
  return updates.reduce(
    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),
    state
  );
}
function legacy_patchImmutableObjectWithUpdate(state, update) {
  const path = getParentsPath(update.node);
  return legacy_patchImmutableNode(state, path, update);
}
function legacy_patchImmutableNode(state, path, update) {
  var _a, _b, _c, _d;
  const pathItem = path.pop();
  if (pathItem === void 0) {
    switch (update.type) {
      case "LiveObject": {
        if (state === null || typeof state !== "object" || Array.isArray(state)) {
          throw new Error(
            "Internal: received update on LiveObject but state was not an object"
          );
        }
        const newState = Object.assign({}, state);
        for (const key in update.updates) {
          if (((_a = update.updates[key]) == null ? void 0 : _a.type) === "update") {
            const val = update.node.get(key);
            if (val !== void 0) {
              newState[key] = lsonToJson(val);
            }
          } else if (((_b = update.updates[key]) == null ? void 0 : _b.type) === "delete") {
            delete newState[key];
          }
        }
        return newState;
      }
      case "LiveList": {
        if (!Array.isArray(state)) {
          throw new Error(
            "Internal: received update on LiveList but state was not an array"
          );
        }
        let newState = state.map((x) => x);
        for (const listUpdate of update.updates) {
          if (listUpdate.type === "set") {
            newState = newState.map(
              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item
            );
          } else if (listUpdate.type === "insert") {
            if (listUpdate.index === newState.length) {
              newState.push(lsonToJson(listUpdate.item));
            } else {
              newState = [
                ...newState.slice(0, listUpdate.index),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index)
              ];
            }
          } else if (listUpdate.type === "delete") {
            newState.splice(listUpdate.index, 1);
          } else if (listUpdate.type === "move") {
            if (listUpdate.previousIndex > listUpdate.index) {
              newState = [
                ...newState.slice(0, listUpdate.index),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index, listUpdate.previousIndex),
                ...newState.slice(listUpdate.previousIndex + 1)
              ];
            } else {
              newState = [
                ...newState.slice(0, listUpdate.previousIndex),
                ...newState.slice(
                  listUpdate.previousIndex + 1,
                  listUpdate.index + 1
                ),
                lsonToJson(listUpdate.item),
                ...newState.slice(listUpdate.index + 1)
              ];
            }
          }
        }
        return newState;
      }
      case "LiveMap": {
        if (state === null || typeof state !== "object" || Array.isArray(state)) {
          throw new Error(
            "Internal: received update on LiveMap but state was not an object"
          );
        }
        const newState = Object.assign({}, state);
        for (const key in update.updates) {
          if (((_c = update.updates[key]) == null ? void 0 : _c.type) === "update") {
            const value = update.node.get(key);
            if (value !== void 0) {
              newState[key] = lsonToJson(value);
            }
          } else if (((_d = update.updates[key]) == null ? void 0 : _d.type) === "delete") {
            delete newState[key];
          }
        }
        return newState;
      }
    }
  }
  if (Array.isArray(state)) {
    const newArray = [...state];
    newArray[pathItem] = legacy_patchImmutableNode(
      state[pathItem],
      path,
      update
    );
    return newArray;
  } else if (state !== null && typeof state === "object") {
    const node = state[pathItem];
    if (node === void 0) {
      return state;
    } else {
      return _chunkUV2F4F4Rjs.__spreadProps.call(void 0, _chunkUV2F4F4Rjs.__spreadValues.call(void 0, {}, state), {
        [pathItem]: legacy_patchImmutableNode(node, path, update)
      });
    }
  } else {
    return state;
  }
}































exports.ClientMsgCode = _chunkUV2F4F4Rjs.ClientMsgCode; exports.CrdtType = _chunkUV2F4F4Rjs.CrdtType; exports.OpCode = _chunkUV2F4F4Rjs.OpCode; exports.ServerMsgCode = _chunkUV2F4F4Rjs.ServerMsgCode; exports.WebsocketCloseCodes = _chunkUV2F4F4Rjs.WebsocketCloseCodes; exports.asArrayWithLegacyMethods = _chunkUV2F4F4Rjs.asArrayWithLegacyMethods; exports.assertNever = _chunkUV2F4F4Rjs.assertNever; exports.b64decode = _chunkUV2F4F4Rjs.b64decode; exports.comparePosition = _chunkUV2F4F4Rjs.comparePosition; exports.deprecate = _chunkUV2F4F4Rjs.deprecate; exports.deprecateIf = _chunkUV2F4F4Rjs.deprecateIf; exports.errorIf = _chunkUV2F4F4Rjs.errorIf; exports.freeze = _chunkUV2F4F4Rjs.freeze; exports.isAppOnlyAuthToken = _chunkUV2F4F4Rjs.isAppOnlyAuthToken; exports.isAuthToken = _chunkUV2F4F4Rjs.isAuthToken; exports.isChildCrdt = _chunkUV2F4F4Rjs.isChildCrdt; exports.isJsonArray = _chunkUV2F4F4Rjs.isJsonArray; exports.isJsonObject = _chunkUV2F4F4Rjs.isJsonObject; exports.isJsonScalar = _chunkUV2F4F4Rjs.isJsonScalar; exports.isPlainObject = _chunkUV2F4F4Rjs.isPlainObject; exports.isRoomAuthToken = _chunkUV2F4F4Rjs.isRoomAuthToken; exports.isRootCrdt = _chunkUV2F4F4Rjs.isRootCrdt; exports.isScope = _chunkUV2F4F4Rjs.isScope; exports.legacy_patchImmutableObject = legacy_patchImmutableObject; exports.lsonToJson = lsonToJson; exports.makePosition = _chunkUV2F4F4Rjs.makePosition; exports.nn = _chunkUV2F4F4Rjs.nn; exports.patchLiveObjectKey = patchLiveObjectKey; exports.throwUsageError = _chunkUV2F4F4Rjs.throwUsageError; exports.tryParseJson = _chunkUV2F4F4Rjs.tryParseJson;
