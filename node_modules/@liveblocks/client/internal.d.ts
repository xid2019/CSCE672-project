import { e as JsonObject, J as Json, B as BaseUserMeta, g as Lson, h as LsonObject, c as LiveObject, S as StorageUpdate } from './index-2601cea5.js';
export { j as LiveNode, k as Resolve, l as RoomInitializers, m as ToImmutable, T as ToJson, W as WebsocketCloseCodes, i as asArrayWithLegacyMethods, n as isJsonArray, o as isJsonObject, p as isJsonScalar } from './index-2601cea5.js';

declare enum OpCode {
    INIT = 0,
    SET_PARENT_KEY = 1,
    CREATE_LIST = 2,
    UPDATE_OBJECT = 3,
    CREATE_OBJECT = 4,
    DELETE_CRDT = 5,
    DELETE_OBJECT_KEY = 6,
    CREATE_MAP = 7,
    CREATE_REGISTER = 8
}
/**
 * These operations are the payload for {@link UpdateStorageServerMsg} messages
 * only.
 */
declare type Op = CreateOp | UpdateObjectOp | DeleteCrdtOp | SetParentKeyOp | DeleteObjectKeyOp;
declare type CreateOp = CreateRootObjectOp | CreateChildOp;
declare type CreateChildOp = CreateObjectOp | CreateRegisterOp | CreateMapOp | CreateListOp;
declare type UpdateObjectOp = {
    opId?: string;
    id: string;
    type: OpCode.UPDATE_OBJECT;
    data: Partial<JsonObject>;
};
declare type CreateObjectOp = {
    opId?: string;
    id: string;
    intent?: "set";
    deletedId?: string;
    type: OpCode.CREATE_OBJECT;
    parentId: string;
    parentKey: string;
    data: JsonObject;
};
declare type CreateRootObjectOp = {
    opId?: string;
    id: string;
    type: OpCode.CREATE_OBJECT;
    data: JsonObject;
    parentId?: never;
    parentKey?: never;
};
declare type CreateListOp = {
    opId?: string;
    id: string;
    intent?: "set";
    deletedId?: string;
    type: OpCode.CREATE_LIST;
    parentId: string;
    parentKey: string;
};
declare type CreateMapOp = {
    opId?: string;
    id: string;
    intent?: "set";
    deletedId?: string;
    type: OpCode.CREATE_MAP;
    parentId: string;
    parentKey: string;
};
declare type CreateRegisterOp = {
    opId?: string;
    id: string;
    intent?: "set";
    deletedId?: string;
    type: OpCode.CREATE_REGISTER;
    parentId: string;
    parentKey: string;
    data: Json;
};
declare type DeleteCrdtOp = {
    opId?: string;
    id: string;
    type: OpCode.DELETE_CRDT;
};
declare type SetParentKeyOp = {
    opId?: string;
    id: string;
    type: OpCode.SET_PARENT_KEY;
    parentKey: string;
};
declare type DeleteObjectKeyOp = {
    opId?: string;
    id: string;
    type: OpCode.DELETE_OBJECT_KEY;
    key: string;
};

declare enum ClientMsgCode {
    UPDATE_PRESENCE = 100,
    BROADCAST_EVENT = 103,
    FETCH_STORAGE = 200,
    UPDATE_STORAGE = 201
}
/**
 * Messages that can be sent from the client to the server.
 */
declare type ClientMsg<TPresence extends JsonObject, TRoomEvent extends Json> = BroadcastEventClientMsg<TRoomEvent> | UpdatePresenceClientMsg<TPresence> | UpdateStorageClientMsg | FetchStorageClientMsg;
declare type BroadcastEventClientMsg<TRoomEvent extends Json> = {
    type: ClientMsgCode.BROADCAST_EVENT;
    event: TRoomEvent;
};
declare type UpdatePresenceClientMsg<TPresence extends JsonObject> = {
    type: ClientMsgCode.UPDATE_PRESENCE;
    /**
     * Set this to any number to signify that this is a Full Presence™
     * update, not a patch.
     *
     * The numeric value itself no longer has specific meaning. Historically,
     * this field was intended so that clients could ignore these broadcasted
     * full presence messages, but it turned out that getting a full presence
     * "keyframe" from time to time was useful.
     *
     * So nowadays, the presence (pun intended) of this `targetActor` field
     * is a backward-compatible way of expressing that the `data` contains
     * all presence fields, and isn't a partial "patch".
     */
    targetActor: number;
    data: TPresence;
} | {
    type: ClientMsgCode.UPDATE_PRESENCE;
    /**
     * Absence of the `targetActor` field signifies that this is a Partial
     * Presence™ "patch".
     */
    targetActor?: undefined;
    data: Partial<TPresence>;
};
declare type UpdateStorageClientMsg = {
    type: ClientMsgCode.UPDATE_STORAGE;
    ops: Op[];
};
declare type FetchStorageClientMsg = {
    type: ClientMsgCode.FETCH_STORAGE;
};

declare type IdTuple<T> = [id: string, value: T];
declare enum CrdtType {
    OBJECT = 0,
    LIST = 1,
    MAP = 2,
    REGISTER = 3
}
declare type SerializedCrdt = SerializedRootObject | SerializedChild;
declare type SerializedChild = SerializedObject | SerializedList | SerializedMap | SerializedRegister;
declare type SerializedRootObject = {
    type: CrdtType.OBJECT;
    data: JsonObject;
    parentId?: never;
    parentKey?: never;
};
declare type SerializedObject = {
    type: CrdtType.OBJECT;
    parentId: string;
    parentKey: string;
    data: JsonObject;
};
declare type SerializedList = {
    type: CrdtType.LIST;
    parentId: string;
    parentKey: string;
};
declare type SerializedMap = {
    type: CrdtType.MAP;
    parentId: string;
    parentKey: string;
};
declare type SerializedRegister = {
    type: CrdtType.REGISTER;
    parentId: string;
    parentKey: string;
    data: Json;
};
declare function isRootCrdt(crdt: SerializedCrdt): crdt is SerializedRootObject;
declare function isChildCrdt(crdt: SerializedCrdt): crdt is SerializedChild;

/**
 * Lookup table for nodes (= SerializedCrdt values) by their IDs.
 */
declare type NodeMap = Map<string, // Node ID
SerializedCrdt>;
/**
 * Reverse lookup table for all child nodes (= list of SerializedCrdt values)
 * by their parent node's IDs.
 */
declare type ParentToChildNodeMap = Map<string, // Parent's node ID
IdTuple<SerializedChild>[]>;

declare enum ServerMsgCode {
    UPDATE_PRESENCE = 100,
    USER_JOINED = 101,
    USER_LEFT = 102,
    BROADCASTED_EVENT = 103,
    ROOM_STATE = 104,
    INITIAL_STORAGE_STATE = 200,
    UPDATE_STORAGE = 201
}
/**
 * Messages that can be sent from the server to the client.
 */
declare type ServerMsg<TPresence extends JsonObject, TUserMeta extends BaseUserMeta, TRoomEvent extends Json> = UpdatePresenceServerMsg<TPresence> | UserJoinServerMsg<TUserMeta> | UserLeftServerMsg | BroadcastedEventServerMsg<TRoomEvent> | RoomStateServerMsg<TUserMeta> | InitialDocumentStateServerMsg | UpdateStorageServerMsg;
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a User updated their presence. For example, when a user moves their cursor.
 *
 * In most cases, the data payload will only include the fields from the
 * Presence that have been changed since the last announcement. However, after
 * a new user joins a room, a "full presence" will be announced so the newly
 * connected user will get each other's user full presence at least once. In
 * those cases, the `targetActor` field indicates the newly connected client,
 * so all other existing clients can ignore this broadcasted message.
 */
declare type UpdatePresenceServerMsg<TPresence extends JsonObject> = {
    type: ServerMsgCode.UPDATE_PRESENCE;
    /**
     * The User whose Presence has changed.
     */
    actor: number;
    /**
     * When set, signifies that this is a Full Presence™ update, not a patch.
     *
     * The numeric value itself no longer has specific meaning. Historically,
     * this field was intended so that clients could ignore these broadcasted
     * full presence messages, but it turned out that getting a full presence
     * "keyframe" from time to time was useful.
     *
     * So nowadays, the presence (pun intended) of this `targetActor` field
     * is a backward-compatible way of expressing that the `data` contains
     * all presence fields, and isn't a partial "patch".
     */
    targetActor: number;
    /**
     * The partial or full Presence of a User. If the `targetActor` field is set,
     * this will be the full Presence, otherwise it only contain the fields that
     * have changed since the last broadcast.
     */
    data: TPresence;
} | {
    type: ServerMsgCode.UPDATE_PRESENCE;
    /**
     * The User whose Presence has changed.
     */
    actor: number;
    /**
     * Not set for partial presence updates.
     */
    targetActor?: undefined;
    /**
     * A partial Presence patch to apply to the User. It will only contain the
     * fields that have changed since the last broadcast.
     */
    data: Partial<TPresence>;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a new User has joined the Room.
 */
declare type UserJoinServerMsg<TUserMeta extends BaseUserMeta> = {
    type: ServerMsgCode.USER_JOINED;
    actor: number;
    /**
     * The id of the User that has been set in the authentication endpoint.
     * Useful to get additional information about the connected user.
     */
    id: TUserMeta["id"];
    /**
     * Additional user information that has been set in the authentication
     * endpoint.
     */
    info: TUserMeta["info"];
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a new User has left the Room.
 */
declare type UserLeftServerMsg = {
    type: ServerMsgCode.USER_LEFT;
    actor: number;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a User broadcasted an Event to everyone in the Room.
 */
declare type BroadcastedEventServerMsg<TRoomEvent extends Json> = {
    type: ServerMsgCode.BROADCASTED_EVENT;
    /**
     * The User who broadcasted the Event.
     */
    actor: number;
    /**
     * The arbitrary payload of the Event. This can be any JSON value. Clients
     * will have to manually verify/decode this event.
     */
    event: TRoomEvent;
};
/**
 * Sent by the WebSocket server to a single client in response to the client
 * joining the Room, to provide the initial state of the Room. The payload
 * includes a list of all other Users that already are in the Room.
 */
declare type RoomStateServerMsg<TUserMeta extends BaseUserMeta> = {
    type: ServerMsgCode.ROOM_STATE;
    users: {
        [actor: number]: TUserMeta;
    };
};
/**
 * Sent by the WebSocket server to a single client in response to the client
 * joining the Room, to provide the initial Storage state of the Room. The
 * payload includes the entire Storage document.
 */
declare type InitialDocumentStateServerMsg = {
    type: ServerMsgCode.INITIAL_STORAGE_STATE;
    items: IdTuple<SerializedCrdt>[];
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a change occurred in the Storage document.
 *
 * The payload of this message contains a list of Ops (aka incremental
 * mutations to make to the initially loaded document).
 */
declare type UpdateStorageServerMsg = {
    type: ServerMsgCode.UPDATE_STORAGE;
    ops: Op[];
};

/**
 * Helper function that can be used to implement exhaustive switch statements
 * with TypeScript. Example usage:
 *
 *    type Fruit = "🍎" | "🍌";
 *
 *    switch (fruit) {
 *      case "🍎":
 *      case "🍌":
 *        return doSomething();
 *
 *      default:
 *        return assertNever(fruit, "Unknown fruit");
 *    }
 *
 * If now the Fruit union is extended (i.e. add "🍒"), TypeScript will catch
 * this *statically*, rather than at runtime, and force you to handle the
 * 🍒 case.
 */
declare function assertNever(_value: never, errmsg: string): never;
/**
 * Asserts that a given value is non-nullable. This is similar to TypeScript's
 * `!` operator, but will throw an error at runtime (dev-mode only) indicating
 * an incorrect assumption.
 *
 * Instead of:
 *
 *     foo!.bar
 *
 * Use:
 *
 *     nn(foo).bar
 *
 */
declare function nn<T>(value: T, errmsg?: string): NonNullable<T>;

declare const SCOPES: readonly ["websocket:presence", "websocket:storage", "room:read", "room:write", "rooms:read", "rooms:write"];
declare type Scope = typeof SCOPES[number];
declare type AppOnlyAuthToken = {
    appId: string;
    roomId?: never;
    scopes: string[];
};
declare type RoomAuthToken = {
    appId: string;
    roomId: string;
    scopes: string[];
    actor: number;
    maxConnectionsPerRoom?: number;
    id?: string;
    info?: Json;
};
declare type AuthToken = AppOnlyAuthToken | RoomAuthToken;
declare function isScope(value: unknown): value is Scope;
declare function isAppOnlyAuthToken(data: JsonObject): data is AppOnlyAuthToken;
declare function isRoomAuthToken(data: JsonObject): data is RoomAuthToken;
declare function isAuthToken(data: JsonObject): data is AuthToken;

/**
 * Tools to help with the controlled deprecation of public APIs.
 *
 * First warn, then error, then remove eventually.
 */
/**
 * Displays a deprecation warning in the dev console. Only in dev mode, and
 * only once per message/key. In production, this is a no-op.
 */
declare function deprecate(message: string, key?: string): void;
/**
 * Conditionally displays a deprecation warning in the dev
 * console if the first argument is truthy. Only in dev mode, and
 * only once per message/key. In production, this is a no-op.
 */
declare function deprecateIf(condition: unknown, message: string, key?: string): void;
/**
 * Throws a deprecation error in the dev console.
 *
 * Only triggers in dev mode. In production, this is a no-op.
 */
declare function throwUsageError(message: string): void;
/**
 * Conditionally throws a usage error in the dev console if the first argument
 * is truthy. Use this to "escalate" usage patterns that in previous versions
 * we already warned about with deprecation warnings.
 *
 * Only has effect in dev mode. In production, this is a no-op.
 */
declare function errorIf(condition: unknown, message: string): void;

declare function lsonToJson(value: Lson): Json;
declare function patchLiveObjectKey<O extends LsonObject, K extends keyof O, V extends Lson>(liveObject: LiveObject<O>, key: K, prev?: V, next?: V): void;
declare function legacy_patchImmutableObject<S extends JsonObject>(state: S, updates: StorageUpdate[]): S;

declare function makePosition(before?: string, after?: string): string;
declare function comparePosition(posA: string, posB: string): number;

/**
 * Freezes the given argument, but only in development builds. In production
 * builds, this is a no-op for performance reasons.
 */
declare const freeze: typeof Object.freeze;
declare function isPlainObject(blob: unknown): blob is {
    [key: string]: unknown;
};
/**
 * Alternative to JSON.parse() that will not throw in production. If the passed
 * string cannot be parsed, this will return `undefined`.
 */
declare function tryParseJson(rawMessage: string): Json | undefined;
/**
 * Decode base64 string.
 */
declare function b64decode(b64value: string): string;

export { AppOnlyAuthToken, AuthToken, BroadcastEventClientMsg, BroadcastedEventServerMsg, ClientMsg, ClientMsgCode, CrdtType, CreateChildOp, CreateListOp, CreateMapOp, CreateObjectOp, CreateOp, CreateRegisterOp, CreateRootObjectOp, DeleteCrdtOp, DeleteObjectKeyOp, FetchStorageClientMsg, IdTuple, InitialDocumentStateServerMsg, NodeMap, Op, OpCode, ParentToChildNodeMap, RoomAuthToken, RoomStateServerMsg, Scope, SerializedChild, SerializedCrdt, SerializedList, SerializedMap, SerializedObject, SerializedRegister, SerializedRootObject, ServerMsg, ServerMsgCode, SetParentKeyOp, UpdateObjectOp, UpdatePresenceClientMsg, UpdatePresenceServerMsg, UpdateStorageClientMsg, UpdateStorageServerMsg, UserJoinServerMsg, UserLeftServerMsg, assertNever, b64decode, comparePosition, deprecate, deprecateIf, errorIf, freeze, isAppOnlyAuthToken, isAuthToken, isChildCrdt, isPlainObject, isRoomAuthToken, isRootCrdt, isScope, legacy_patchImmutableObject, lsonToJson, makePosition, nn, patchLiveObjectKey, throwUsageError, tryParseJson };
