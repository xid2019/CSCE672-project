{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n}; // src/deprecation.ts\n\n\nvar _emittedDeprecationWarnings = /* @__PURE__ */new Set();\n\nfunction deprecate(message) {\n  let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : message;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n\n      console.error(`DEPRECATION WARNING: ${message}`);\n    }\n  }\n}\n\nfunction deprecateIf(condition, message) {\n  let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : message;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\n\nfunction throwUsageError(message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    throw usageError;\n  }\n}\n\nfunction errorIf(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n} // src/assert.ts\n\n\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\n\nfunction assert(condition, errmsg) {\n  if (process.env.NODE_ENV !== \"production\" && !condition) {\n    const err = new Error(errmsg);\n    err.name = \"Assertion failure\";\n    throw err;\n  }\n}\n\nfunction nn(value) {\n  let errmsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Expected value to be non-nullable\";\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n} // src/types/ClientMsg.ts\n\n\nvar ClientMsgCode = /* @__PURE__ */(ClientMsgCode2 => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {}); // src/types/Op.ts\n\n\nvar OpCode = /* @__PURE__ */(OpCode2 => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {}); // src/types/SerializedCrdt.ts\n\n\nvar CrdtType = /* @__PURE__ */(CrdtType2 => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\n\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0\n  /* OBJECT */\n  && !isChildCrdt(crdt);\n}\n\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n} // src/types/ServerMsg.ts\n\n\nvar ServerMsgCode = /* @__PURE__ */(ServerMsgCode2 => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {}); // src/types/index.ts\n\n\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"connection\" || value === \"history\";\n}\n\nvar WebsocketCloseCodes = /* @__PURE__ */(WebsocketCloseCodes2 => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {}); // src/position.ts\n\n\nvar min = 32;\nvar max = 126;\n\nfunction makePosition(before, after) {\n  if (before !== void 0 && after !== void 0) {\n    return pos(makePositionFromCodes(posCodes(before), posCodes(after)));\n  } else if (before !== void 0) {\n    return getNextPosition(before);\n  } else if (after !== void 0) {\n    return getPreviousPosition(after);\n  }\n\n  return pos([min + 1]);\n}\n\nfunction getPreviousPosition(after) {\n  const result = [];\n  const afterCodes = posCodes(after);\n\n  for (let i = 0; i < afterCodes.length; i++) {\n    const code = afterCodes[i];\n\n    if (code <= min + 1) {\n      result.push(min);\n\n      if (afterCodes.length - 1 === i) {\n        result.push(max);\n        break;\n      }\n    } else {\n      result.push(code - 1);\n      break;\n    }\n  }\n\n  return pos(result);\n}\n\nfunction getNextPosition(before) {\n  const result = [];\n  const beforeCodes = posCodes(before);\n\n  for (let i = 0; i < beforeCodes.length; i++) {\n    const code = beforeCodes[i];\n\n    if (code === max) {\n      result.push(code);\n\n      if (beforeCodes.length - 1 === i) {\n        result.push(min + 1);\n        break;\n      }\n    } else {\n      result.push(code + 1);\n      break;\n    }\n  }\n\n  return pos(result);\n}\n\nfunction makePositionFromCodes(before, after) {\n  let index = 0;\n  const result = [];\n\n  while (true) {\n    const beforeDigit = before[index] || min;\n    const afterDigit = after[index] || max;\n\n    if (beforeDigit > afterDigit) {\n      throw new Error(`Impossible to generate position between ${before} and ${after}`);\n    }\n\n    if (beforeDigit === afterDigit) {\n      result.push(beforeDigit);\n      index++;\n      continue;\n    }\n\n    if (afterDigit - beforeDigit === 1) {\n      result.push(beforeDigit);\n      result.push(...makePositionFromCodes(before.slice(index + 1), []));\n      break;\n    }\n\n    const mid = afterDigit + beforeDigit >> 1;\n    result.push(mid);\n    break;\n  }\n\n  return result;\n}\n\nfunction posCodes(str) {\n  const codes = [];\n\n  for (let i = 0; i < str.length; i++) {\n    codes.push(str.charCodeAt(i));\n  }\n\n  return codes;\n}\n\nfunction pos(codes) {\n  return String.fromCharCode(...codes);\n}\n\nfunction comparePosition(posA, posB) {\n  const aCodes = posCodes(posA);\n  const bCodes = posCodes(posB);\n  const maxLength = Math.max(aCodes.length, bCodes.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const a = aCodes[i] === void 0 ? min : aCodes[i];\n    const b = bCodes[i] === void 0 ? min : bCodes[i];\n\n    if (a === b) {\n      continue;\n    } else {\n      return a - b;\n    }\n  }\n\n  throw new Error(`Impossible to compare similar position \"${posA}\" and \"${posB}\"`);\n} // src/AbstractCrdt.ts\n\n\nfunction crdtAsLiveNode(value) {\n  return value;\n}\n\nfunction HasParent(node, key) {\n  return Object.freeze({\n    type: \"HasParent\",\n    node,\n    key\n  });\n}\n\nvar NoParent = Object.freeze({\n  type: \"NoParent\"\n});\n\nfunction Orphaned(oldKey) {\n  return Object.freeze({\n    type: \"Orphaned\",\n    oldKey\n  });\n}\n\nvar AbstractCrdt = class {\n  constructor() {\n    this._parent = NoParent;\n  }\n\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  get _pool() {\n    return this.__pool;\n  }\n\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n\n  get _id() {\n    return this.__id;\n  }\n\n  get parent() {\n    return this._parent;\n  }\n\n  get _parentNode() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.node;\n\n      case \"NoParent\":\n        return null;\n\n      case \"Orphaned\":\n        return null;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        return null;\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5\n      /* DELETE_CRDT */\n      :\n        {\n          if (this.parent.type === \"HasParent\") {\n            return this.parent.node._detachChild(crdtAsLiveNode(this));\n          }\n\n          return {\n            modified: false\n          };\n        }\n    }\n\n    return {\n      modified: false\n    };\n  }\n\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n\n      case \"Orphaned\":\n      case \"NoParent\":\n        {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n\n    switch (this.parent.type) {\n      case \"HasParent\":\n        {\n          this._parent = Orphaned(this.parent.key);\n          break;\n        }\n\n      case \"NoParent\":\n        {\n          this._parent = NoParent;\n          break;\n        }\n\n      case \"Orphaned\":\n        {\n          this._parent = Orphaned(this.parent.oldKey);\n          break;\n        }\n\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n\n    this.__pool = void 0;\n  }\n\n  invalidate() {\n    if (this._cachedImmutable !== void 0) {\n      this._cachedImmutable = void 0;\n\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n\n    return this._cachedImmutable;\n  }\n\n}; // src/LiveRegister.ts\n\nvar LiveRegister = class extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  static _deserialize(_ref, _parentToChildren, pool) {\n    let [id, item] = _ref;\n    const register = new LiveRegister(item.data);\n\n    register._attach(id, pool);\n\n    return register;\n  }\n\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize register if parentId or parentKey is undefined\");\n    }\n\n    return [{\n      type: 8\n      /* CREATE_REGISTER */\n      ,\n      opId: pool == null ? void 0 : pool.generateOpId(),\n      id: this._id,\n      parentId,\n      parentKey,\n      data: this.data\n    }];\n  }\n\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n\n    return {\n      type: 3\n      /* REGISTER */\n      ,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n\n  _toImmutable() {\n    return this._data;\n  }\n\n}; // src/LiveMap.ts\n\nvar LiveMap = class extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */new Map();\n\n    if (entries2) {\n      const mappedEntries = [];\n\n      for (const entry of entries2) {\n        const value = lsonToLiveNode(entry[1]);\n\n        value._setParentLink(this, entry[0]);\n\n        mappedEntries.push([entry[0], value]);\n      }\n\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */new Map();\n    }\n  }\n\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool == null ? void 0 : pool.generateOpId(),\n      type: 7\n      /* CREATE_MAP */\n      ,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n\n    return ops;\n  }\n\n  static _deserialize(_ref2, parentToChildren, pool) {\n    let [id, _item] = _ref2;\n    const map = new LiveMap();\n\n    map._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n\n    if (children === void 0) {\n      return map;\n    }\n\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n\n      child._setParentLink(map, crdt.parentKey);\n\n      map._map.set(crdt.parentKey, child);\n\n      map.invalidate();\n    }\n\n    return map;\n  }\n\n  _attach(id, pool) {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const {\n      id,\n      parentKey,\n      opId\n    } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool.getNode(id) !== void 0) {\n      return {\n        modified: false\n      };\n    }\n\n    if (source === 2\n    /* ACK */\n    ) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return {\n          modified: false\n        };\n      } else if (lastUpdateOpId !== void 0) {\n        return {\n          modified: false\n        };\n      }\n    } else if (source === 1\n    /* REMOTE */\n    ) {\n      this.unacknowledgedSet.delete(key);\n    }\n\n    const previousValue = this._map.get(key);\n\n    let reverse;\n\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n\n      previousValue._detach();\n    } else {\n      reverse = [{\n        type: 5\n        /* DELETE_CRDT */\n        ,\n        id\n      }];\n    }\n\n    child._setParentLink(this, key);\n\n    child._attach(id, this._pool);\n\n    this._map.set(key, child);\n\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: {\n          [key]: {\n            type: \"update\"\n          }\n        }\n      },\n      reverse\n    };\n  }\n\n  _detach() {\n    super._detach();\n\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n\n    const reverse = child._toOps(id, parentKey, this._pool);\n\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n\n        this.invalidate();\n      }\n    }\n\n    child._detach();\n\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: {\n        [parentKey]: {\n          type: \"delete\"\n        }\n      }\n    };\n    return {\n      modified: storageUpdate,\n      reverse\n    };\n  }\n\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n\n    return {\n      type: 2\n      /* MAP */\n      ,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n\n  get(key) {\n    const value = this._map.get(key);\n\n    if (value === void 0) {\n      return void 0;\n    }\n\n    return liveNodeToLson(value);\n  }\n\n  set(key, value) {\n    const oldValue = this._map.get(key);\n\n    if (oldValue) {\n      oldValue._detach();\n    }\n\n    const item = lsonToLiveNode(value);\n\n    item._setParentLink(this, key);\n\n    this._map.set(key, item);\n\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n\n      item._attach(id, this._pool);\n\n      const storageUpdates = /* @__PURE__ */new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: {\n          [key]: {\n            type: \"update\"\n          }\n        }\n      });\n\n      const ops = item._toOps(this._id, key, this._pool);\n\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n\n      this._pool.dispatch(item._toOps(this._id, key, this._pool), oldValue ? oldValue._toOps(this._id, key) : [{\n        type: 5\n        /* DELETE_CRDT */\n        ,\n        id\n      }], storageUpdates);\n    }\n  }\n\n  get size() {\n    return this._map.size;\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  delete(key) {\n    const item = this._map.get(key);\n\n    if (item === void 0) {\n      return false;\n    }\n\n    item._detach();\n\n    this._map.delete(key);\n\n    this.invalidate();\n\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: {\n          [key]: {\n            type: \"delete\"\n          }\n        }\n      });\n\n      this._pool.dispatch([{\n        type: 5\n        /* DELETE_CRDT */\n        ,\n        id: item._id,\n        opId: this._pool.generateOpId()\n      }], item._toOps(thisId, key), storageUpdates);\n    }\n\n    return true;\n  }\n\n  entries() {\n    const innerIterator = this._map.entries();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n\n    };\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    const innerIterator = this._map.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n\n        const value = liveNodeToLson(iteratorValue.value);\n        return {\n          value\n        };\n      }\n\n    };\n  }\n\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n\n  toImmutable() {\n    return super.toImmutable();\n  }\n\n  _toImmutable() {\n    const result = /* @__PURE__ */new Map();\n\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n\n    return freeze(result);\n  }\n\n}; // src/LiveObject.ts\n\nvar LiveObject = class extends AbstractCrdt {\n  constructor() {\n    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._propToLastUpdate = /* @__PURE__ */new Map();\n\n    for (const key in obj) {\n      const value = obj[key];\n\n      if (value === void 0) {\n        continue;\n      } else if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n\n    this._map = new Map(Object.entries(obj));\n  }\n\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const opId = pool == null ? void 0 : pool.generateOpId();\n    const ops = [];\n    const op = parentId !== void 0 && parentKey !== void 0 ? {\n      type: 4\n      /* CREATE_OBJECT */\n      ,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    } : {\n      type: 4\n      /* CREATE_OBJECT */\n      ,\n      id: this._id,\n      opId,\n      data: {}\n    };\n    ops.push(op);\n\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n\n    return ops;\n  }\n\n  static _deserialize(_ref3, parentToChildren, pool) {\n    let [id, item] = _ref3;\n    const liveObj = new LiveObject(item.data);\n\n    liveObj._attach(id, pool);\n\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n\n    if (children === void 0) {\n      return liveObj;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n\n      liveObj._map.set(crdt.parentKey, child);\n\n      liveObj.invalidate();\n    }\n\n    return liveObj;\n  }\n\n  _attach(id, pool) {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const {\n      id,\n      opId,\n      parentKey: key\n    } = op;\n    const child = creationOpToLson(op);\n\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n\n      return {\n        modified: false\n      };\n    }\n\n    if (source === 0\n    /* UNDOREDO_RECONNECT */\n    ) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {} else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n\n      return {\n        modified: false\n      };\n    } else {\n      return {\n        modified: false\n      };\n    }\n\n    const thisId = nn(this._id);\n\n    const previousValue = this._map.get(key);\n\n    let reverse;\n\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{\n        type: 6\n        /* DELETE_OBJECT_KEY */\n        ,\n        id: thisId,\n        key\n      }];\n    } else {\n      reverse = [{\n        type: 3\n        /* UPDATE_OBJECT */\n        ,\n        id: thisId,\n        data: {\n          [key]: previousValue\n        }\n      }];\n    }\n\n    this._map.set(key, child);\n\n    this.invalidate();\n\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n\n      child._attach(id, this._pool);\n    }\n\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [key]: {\n            type: \"update\"\n          }\n        }\n      }\n    };\n  }\n\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n\n      const reverse = child._toOps(id, parentKey, this._pool);\n\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n\n          this.invalidate();\n        }\n      }\n\n      child._detach();\n\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: {\n            type: \"delete\"\n          }\n        }\n      };\n      return {\n        modified: storageUpdate,\n        reverse\n      };\n    }\n\n    return {\n      modified: false\n    };\n  }\n\n  _detach() {\n    super._detach();\n\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n\n  _apply(op, isLocal) {\n    if (op.type === 3\n    /* UPDATE_OBJECT */\n    ) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6\n    /* DELETE_OBJECT_KEY */\n    ) {\n      return this._applyDeleteObjectKey(op);\n    }\n\n    return super._apply(op, isLocal);\n  }\n\n  _serialize() {\n    const data = {};\n\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0\n        /* OBJECT */\n        ,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0\n        /* OBJECT */\n        ,\n        data\n      };\n    }\n  }\n\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3\n      /* UPDATE_OBJECT */\n      ,\n      id,\n      data: {}\n    };\n    reverse.push(reverseUpdate);\n\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({\n          type: 6\n          /* DELETE_OBJECT_KEY */\n          ,\n          id,\n          key\n        });\n      }\n    }\n\n    const updateDelta = {};\n\n    for (const key in op.data) {\n      const value = op.data[key];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n\n        continue;\n      } else {\n        continue;\n      }\n\n      const oldValue = this._map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n\n      isModified = true;\n      updateDelta[key] = {\n        type: \"update\"\n      };\n\n      this._map.set(key, value);\n\n      this.invalidate();\n    }\n\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : {\n      modified: false\n    };\n  }\n\n  _applyDeleteObjectKey(op) {\n    const key = op.key;\n\n    if (this._map.has(key) === false) {\n      return {\n        modified: false\n      };\n    }\n\n    if (this._propToLastUpdate.get(key) !== void 0) {\n      return {\n        modified: false\n      };\n    }\n\n    const oldValue = this._map.get(key);\n\n    const id = nn(this._id);\n    let reverse = [];\n\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [{\n        type: 3\n        /* UPDATE_OBJECT */\n        ,\n        id,\n        data: {\n          [key]: oldValue\n        }\n      }];\n    }\n\n    this._map.delete(key);\n\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [op.key]: {\n            type: \"delete\"\n          }\n        }\n      },\n      reverse\n    };\n  }\n\n  toObject() {\n    return fromEntries(this._map);\n  }\n\n  set(key, value) {\n    this.update({\n      [key]: value\n    });\n  }\n\n  get(key) {\n    return this._map.get(key);\n  }\n\n  delete(key) {\n    const keyAsString = key;\n\n    const oldValue = this._map.get(keyAsString);\n\n    if (oldValue === void 0) {\n      return;\n    }\n\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n\n      this._map.delete(keyAsString);\n\n      this.invalidate();\n      return;\n    }\n\n    let reverse;\n\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [{\n        type: 3\n        /* UPDATE_OBJECT */\n        ,\n        data: {\n          [keyAsString]: oldValue\n        },\n        id: this._id\n      }];\n    }\n\n    this._map.delete(keyAsString);\n\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: {\n        [key]: {\n          type: \"delete\"\n        }\n      }\n    });\n\n    this._pool.dispatch([{\n      type: 6\n      /* DELETE_OBJECT_KEY */\n      ,\n      key: keyAsString,\n      id: this._id,\n      opId: this._pool.generateOpId()\n    }], reverse, storageUpdates);\n  }\n\n  update(patch) {\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n\n        if (newValue === void 0) {\n          continue;\n        }\n\n        const oldValue = this._map.get(key);\n\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n\n        this._map.set(key, newValue);\n\n        this.invalidate();\n      }\n\n      return;\n    }\n\n    const ops = [];\n    const reverseOps = [];\n\n    const opId = this._pool.generateOpId();\n\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3\n      /* UPDATE_OBJECT */\n      ,\n      data: {}\n    };\n    const updateDelta = {};\n\n    for (const key in patch) {\n      const newValue = patch[key];\n\n      if (newValue === void 0) {\n        continue;\n      }\n\n      const oldValue = this._map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({\n          type: 6\n          /* DELETE_OBJECT_KEY */\n          ,\n          id: this._id,\n          key\n        });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n\n        newValue._attach(this._pool.generateId(), this._pool);\n\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n\n        const createCrdtOp = newAttachChildOps.find(op => op.parentId === this._id);\n\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n\n        this._propToLastUpdate.set(key, opId);\n      }\n\n      this._map.set(key, newValue);\n\n      this.invalidate();\n      updateDelta[key] = {\n        type: \"update\"\n      };\n    }\n\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3\n        /* UPDATE_OBJECT */\n        ,\n        data: updatedProps\n      });\n    }\n\n    const storageUpdates = /* @__PURE__ */new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n\n  toImmutable() {\n    return super.toImmutable();\n  }\n\n  _toImmutable() {\n    const result = {};\n\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n\n}; // src/utils.ts\n\nvar freeze = process.env.NODE_ENV === \"production\" ? x => x : Object.freeze;\n\nfunction compact(items) {\n  return items.filter(item => item !== null && item !== void 0);\n}\n\nfunction compactObject(obj) {\n  const newObj = __spreadValues({}, obj);\n\n  Object.keys(obj).forEach(k => {\n    const key = k;\n\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\n\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\n\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8\n    /* CREATE_REGISTER */\n    :\n      return op.data;\n\n    case 4\n    /* CREATE_OBJECT */\n    :\n      return new LiveObject(op.data);\n\n    case 7\n    /* CREATE_MAP */\n    :\n      return new LiveMap();\n\n    case 2\n    /* CREATE_LIST */\n    :\n      return new LiveList();\n\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\n\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n\n  return false;\n}\n\nfunction deserialize(_ref4, parentToChildren, pool) {\n  let [id, crdt] = _ref4;\n\n  switch (crdt.type) {\n    case 0\n    /* OBJECT */\n    :\n      {\n        return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n      }\n\n    case 1\n    /* LIST */\n    :\n      {\n        return LiveList._deserialize([id, crdt], parentToChildren, pool);\n      }\n\n    case 2\n    /* MAP */\n    :\n      {\n        return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n      }\n\n    case 3\n    /* REGISTER */\n    :\n      {\n        return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n      }\n\n    default:\n      {\n        throw new Error(\"Unexpected CRDT type\");\n      }\n  }\n}\n\nfunction deserializeToLson(_ref5, parentToChildren, pool) {\n  let [id, crdt] = _ref5;\n\n  switch (crdt.type) {\n    case 0\n    /* OBJECT */\n    :\n      {\n        return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n      }\n\n    case 1\n    /* LIST */\n    :\n      {\n        return LiveList._deserialize([id, crdt], parentToChildren, pool);\n      }\n\n    case 2\n    /* MAP */\n    :\n      {\n        return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n      }\n\n    case 3\n    /* REGISTER */\n    :\n      {\n        return crdt.data;\n      }\n\n    default:\n      {\n        throw new Error(\"Unexpected CRDT type\");\n      }\n  }\n}\n\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\n\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\n\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\n\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\n\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\n\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\n\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\n\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\n\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5\n        /* DELETE_CRDT */\n        ,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n\n    if (currentCrdt) {\n      if (crdt.type === 0\n      /* OBJECT */\n      ) {\n        if (currentCrdt.type !== 0\n        /* OBJECT */\n        || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3\n            /* UPDATE_OBJECT */\n            ,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1\n          /* SET_PARENT_KEY */\n          ,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3\n        /* REGISTER */\n        :\n          ops.push({\n            type: 8\n            /* CREATE_REGISTER */\n            ,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n\n        case 1\n        /* LIST */\n        :\n          ops.push({\n            type: 2\n            /* CREATE_LIST */\n            ,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n\n        case 0\n        /* OBJECT */\n        :\n          ops.push(crdt.parentId ? {\n            type: 4\n            /* CREATE_OBJECT */\n            ,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          } : {\n            type: 4\n            /* CREATE_OBJECT */\n            ,\n            id,\n            data: crdt.data\n          });\n          break;\n\n        case 2\n        /* MAP */\n        :\n          ops.push({\n            type: 7\n            /* CREATE_MAP */\n            ,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\n\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n\n  return __spreadProps(__spreadValues({}, second), {\n    updates\n  });\n}\n\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n\n  return __spreadProps(__spreadValues({}, second), {\n    updates\n  });\n}\n\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return __spreadProps(__spreadValues({}, second), {\n    updates: updates.concat(second.updates)\n  });\n}\n\nfunction mergeStorageUpdates(first, second) {\n  if (!first) {\n    return second;\n  }\n\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {}\n\n  return second;\n}\n\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\n\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\n\nfunction findNonSerializableValue(value) {\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(nestedValue, nestedPath);\n\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction fromEntries(iterable) {\n  const obj = {};\n\n  for (const [key, val] of iterable) {\n    obj[key] = val;\n  }\n\n  return obj;\n}\n\nfunction entries(obj) {\n  return Object.entries(obj);\n}\n\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\n\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(atob(formattedValue).split(\"\").map(function (c) {\n      return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(\"\"));\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n} // src/LiveList.ts\n\n\nfunction compareNodePosition(itemA, itemB) {\n  return comparePosition(itemA._getParentKeyOrThrow(), itemB._getParentKeyOrThrow());\n}\n\nvar LiveList = class extends AbstractCrdt {\n  constructor() {\n    let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */new Map();\n    let position = void 0;\n\n    for (let i = 0; i < items.length; i++) {\n      const newPosition = makePosition(position);\n      const item = lsonToLiveNode(items[i]);\n\n      item._setParentLink(this, newPosition);\n\n      this._items.push(item);\n\n      position = newPosition;\n    }\n  }\n\n  static _deserialize(_ref6, parentToChildren, pool) {\n    let [id] = _ref6;\n    const list = new LiveList();\n\n    list._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n\n    if (children === void 0) {\n      return list;\n    }\n\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n\n      child._setParentLink(list, crdt.parentKey);\n\n      list._insertAndSort(child);\n    }\n\n    return list;\n  }\n\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool == null ? void 0 : pool.generateOpId(),\n      type: 2\n      /* CREATE_LIST */\n      ,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n\n    for (const item of this._items) {\n      ops.push(...item._toOps(this._id, item._getParentKeyOrThrow(), pool));\n    }\n\n    return ops;\n  }\n\n  _insertAndSort(item) {\n    this._items.push(item);\n\n    this._sortItems();\n  }\n\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n\n    this.invalidate();\n  }\n\n  _indexOfPosition(position) {\n    return this._items.findIndex(item => item._getParentKeyOrThrow() === position);\n  }\n\n  _attach(id, pool) {\n    super._attach(id, pool);\n\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n\n  _detach() {\n    super._detach();\n\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const {\n      id,\n      parentKey: key\n    } = op;\n    const child = creationOpToLiveNode(op);\n\n    child._attach(id, this._pool);\n\n    child._setParentLink(this, key);\n\n    const deletedId = op.deletedId;\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [setDelta(indexOfItemWithSamePosition, child)]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [setDelta(indexOfItemWithSamePosition, child)];\n\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n\n      this._insertAndSort(child);\n\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const delta = [];\n\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? {\n          modified: false\n        } : {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n\n    const existingItem = this._items.find(item => item._id === op.id);\n\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(this._items[indexOfItemWithSamePosition]);\n\n        this._items.splice(indexOfItemWithSamePosition, 1);\n\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n\n      const previousIndex = this._items.indexOf(existingItem);\n\n      existingItem._setParentLink(this, op.parentKey);\n\n      this._sortItems();\n\n      const newIndex = this._items.indexOf(existingItem);\n\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n\n        this._implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const recreatedItemIndex = this._items.indexOf(orphan);\n\n        return {\n          modified: makeUpdate(this, [indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan), ...delta]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n\n        const {\n          newItem,\n          newIndex\n        } = this._createAttachItemAndSort(op, op.parentKey);\n\n        return {\n          modified: makeUpdate(this, [indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem), ...delta]),\n          reverse: []\n        };\n      }\n    }\n  }\n\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n\n    const deletedItem = this._pool.getNode(deletedId);\n\n    if (deletedItem === void 0) {\n      return null;\n    }\n\n    const result = this._detachChild(deletedItem);\n\n    if (result.modified === false) {\n      return null;\n    }\n\n    return result.modified.updates[0];\n  }\n\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const key = op.parentKey;\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n\n    const {\n      newItem,\n      newIndex\n    } = this._createAttachItemAndSort(op, key);\n\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n\n  _applyInsertAck(op) {\n    const existingItem = this._items.find(item => item._id === op.id);\n\n    const key = op.parentKey;\n\n    const itemIndexAtPosition = this._indexOfPosition(key);\n\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        existingItem._setParentLink(this, key);\n\n        this._sortItems();\n\n        const newIndex = this._indexOfPosition(key);\n\n        if (newIndex === oldPositionIndex) {\n          return {\n            modified: false\n          };\n        }\n\n        return {\n          modified: makeUpdate(this, [moveDelta(oldPositionIndex, newIndex, existingItem)]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n\n        this._implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const newIndex = this._indexOfPosition(key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        const {\n          newItem,\n          newIndex\n        } = this._createAttachItemAndSort(op, key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n\n  _applyInsertUndoRedo(op) {\n    var _a;\n\n    const {\n      id,\n      parentKey: key\n    } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {\n      return {\n        modified: false\n      };\n    }\n\n    child._attach(id, nn(this._pool));\n\n    child._setParentLink(this, key);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    let newKey = key;\n\n    if (existingItemIndex !== -1) {\n      const before = this._items[existingItemIndex] ? this._items[existingItemIndex]._getParentKeyOrThrow() : void 0;\n      const after = this._items[existingItemIndex + 1] ? this._items[existingItemIndex + 1]._getParentKeyOrThrow() : void 0;\n      newKey = makePosition(before, after);\n\n      child._setParentLink(this, newKey);\n    }\n\n    this._insertAndSort(child);\n\n    const newIndex = this._indexOfPosition(newKey);\n\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{\n        type: 5\n        /* DELETE_CRDT */\n        ,\n        id\n      }]\n    };\n  }\n\n  _applySetUndoRedo(op) {\n    var _a;\n\n    const {\n      id,\n      parentKey: key\n    } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {\n      return {\n        modified: false\n      };\n    }\n\n    this._unacknowledgedSets.set(key, nn(op.opId));\n\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n\n    child._attach(id, nn(this._pool));\n\n    child._setParentLink(this, key);\n\n    const newKey = key;\n\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n\n      existingItem._detach();\n\n      this._items[indexOfItemWithSameKey] = child;\n\n      const reverse = existingItem._toOps(nn(this._id), key, this._pool);\n\n      addIntentAndDeletedIdToOperation(reverse, op.id);\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n\n      const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n\n      const newIndex = this._indexOfPosition(newKey);\n\n      return {\n        reverse: [{\n          type: 5\n          /* DELETE_CRDT */\n          ,\n          id\n        }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    let result;\n\n    if (op.intent === \"set\") {\n      if (source === 1\n      /* REMOTE */\n      ) {\n        result = this._applySetRemote(op);\n      } else if (source === 2\n      /* ACK */\n      ) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1\n      /* REMOTE */\n      ) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2\n      /* ACK */\n      ) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n\n    return result;\n  }\n\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n\n      const indexToDelete = this._items.indexOf(child);\n\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n\n      this._items.splice(indexToDelete, 1);\n\n      this.invalidate();\n\n      child._detach();\n\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n\n    return {\n      modified: false\n    };\n  }\n\n  _applySetChildKeyRemote(newKey, child) {\n    var _a;\n\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n\n      child._setParentLink(this, newKey);\n\n      this._insertAndSort(child);\n\n      const newIndex = this._items.indexOf(child);\n\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n\n    const previousKey = child._parentKey;\n\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n\n      child._setParentLink(this, newKey);\n\n      this._sortItems();\n\n      const newIndex = this._items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()));\n\n      const previousIndex = this._items.indexOf(child);\n\n      child._setParentLink(this, newKey);\n\n      this._sortItems();\n\n      const newIndex = this._items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n\n  _applySetChildKeyAck(newKey, child) {\n    var _a, _b;\n\n    const previousKey = nn(child._parentKey);\n\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      this._implicitlyDeletedItems.delete(child);\n\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()));\n      }\n\n      child._setParentLink(this, newKey);\n\n      this._insertAndSort(child);\n\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n\n      const previousIndex = this._items.indexOf(child);\n\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_b = this._items[existingItemIndex + 1]) == null ? void 0 : _b._getParentKeyOrThrow()));\n      }\n\n      child._setParentLink(this, newKey);\n\n      this._sortItems();\n\n      const newIndex = this._items.indexOf(child);\n\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n          reverse: []\n        };\n      }\n    }\n  }\n\n  _applySetChildKeyUndoRedo(newKey, child) {\n    var _a;\n\n    const previousKey = nn(child._parentKey);\n\n    const previousIndex = this._items.indexOf(child);\n\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()));\n    }\n\n    child._setParentLink(this, newKey);\n\n    this._sortItems();\n\n    const newIndex = this._items.indexOf(child);\n\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [{\n        type: 1\n        /* SET_PARENT_KEY */\n        ,\n        id: nn(child._id),\n        parentKey: previousKey\n      }]\n    };\n  }\n\n  _setChildKey(newKey, child, source) {\n    if (source === 1\n    /* REMOTE */\n    ) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2\n    /* ACK */\n    ) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n\n    return {\n      type: 1\n      /* LIST */\n      ,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n\n  get length() {\n    return this._items.length;\n  }\n\n  push(element) {\n    return this.insert(element, this.length);\n  }\n\n  insert(element, index) {\n    if (index < 0 || index > this._items.length) {\n      throw new Error(`Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`);\n    }\n\n    const before = this._items[index - 1] ? this._items[index - 1]._getParentKeyOrThrow() : void 0;\n    const after = this._items[index] ? this._items[index]._getParentKeyOrThrow() : void 0;\n    const position = makePosition(before, after);\n    const value = lsonToLiveNode(element);\n\n    value._setParentLink(this, position);\n\n    this._insertAndSort(value);\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n\n      value._attach(id, this._pool);\n\n      this._pool.dispatch(value._toOps(this._id, position, this._pool), [{\n        type: 5\n        /* DELETE_CRDT */\n        ,\n        id\n      }], /* @__PURE__ */new Map([[this._id, makeUpdate(this, [insertDelta(index, value)])]]));\n    }\n  }\n\n  move(index, targetIndex) {\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n\n    if (targetIndex >= this._items.length) {\n      throw new Error(\"targetIndex cannot be greater or equal than the list length\");\n    }\n\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n\n    let beforePosition = null;\n    let afterPosition = null;\n\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._getParentKeyOrThrow();\n      beforePosition = this._items[targetIndex]._getParentKeyOrThrow();\n    } else {\n      afterPosition = this._items[targetIndex]._getParentKeyOrThrow();\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._getParentKeyOrThrow();\n    }\n\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n\n    const previousPosition = item._getParentKeyOrThrow();\n\n    item._setParentLink(this, position);\n\n    this._sortItems();\n\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */new Map([[this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]]);\n\n      this._pool.dispatch([{\n        type: 1\n        /* SET_PARENT_KEY */\n        ,\n        id: nn(item._id),\n        opId: this._pool.generateOpId(),\n        parentKey: position\n      }], [{\n        type: 1\n        /* SET_PARENT_KEY */\n        ,\n        id: nn(item._id),\n        parentKey: previousPosition\n      }], storageUpdates);\n    }\n  }\n\n  delete(index) {\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(`Cannot delete list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`);\n    }\n\n    const item = this._items[index];\n\n    item._detach();\n\n    this._items.splice(index, 1);\n\n    this.invalidate();\n\n    if (this._pool) {\n      const childRecordId = item._id;\n\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */new Map();\n        storageUpdates.set(nn(this._id), makeUpdate(this, [deleteDelta(index)]));\n\n        this._pool.dispatch([{\n          id: childRecordId,\n          opId: this._pool.generateOpId(),\n          type: 5\n          /* DELETE_CRDT */\n\n        }], item._toOps(nn(this._id), item._getParentKeyOrThrow()), storageUpdates);\n      }\n    }\n  }\n\n  clear() {\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n\n      for (const item of this._items) {\n        item._detach();\n\n        const childId = item._id;\n\n        if (childId) {\n          ops.push({\n            type: 5\n            /* DELETE_CRDT */\n            ,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(...item._toOps(nn(this._id), item._getParentKeyOrThrow()));\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n\n      this._items = [];\n      this.invalidate();\n    }\n  }\n\n  set(index, item) {\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(`Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`);\n    }\n\n    const existingItem = this._items[index];\n\n    const position = existingItem._getParentKeyOrThrow();\n\n    const existingId = existingItem._id;\n\n    existingItem._detach();\n\n    const value = lsonToLiveNode(item);\n\n    value._setParentLink(this, position);\n\n    this._items[index] = value;\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n\n      value._attach(id, this._pool);\n\n      const storageUpdates = /* @__PURE__ */new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n\n      const ops = value._toOps(this._id, position, this._pool);\n\n      addIntentAndDeletedIdToOperation(ops, existingId);\n\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n\n      const reverseOps = existingItem._toOps(this._id, position, void 0);\n\n      addIntentAndDeletedIdToOperation(reverseOps, id);\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n\n  toArray() {\n    return this._items.map(entry => liveNodeToLson(entry));\n  }\n\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n\n    return liveNodeToLson(this._items[index]);\n  }\n\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n\n  map(callback) {\n    return this._items.map((entry, i) => callback(liveNodeToLson(entry), i));\n  }\n\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n\n    newItem._attach(op.id, nn(this._pool));\n\n    newItem._setParentLink(this, key);\n\n    this._insertAndSort(newItem);\n\n    const newIndex = this._indexOfPosition(key);\n\n    return {\n      newItem,\n      newIndex\n    };\n  }\n\n  _shiftItemPosition(index, key) {\n    var _a;\n\n    const shiftedPosition = makePosition(key, this._items.length > index + 1 ? (_a = this._items[index + 1]) == null ? void 0 : _a._getParentKeyOrThrow() : void 0);\n\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n\n  toImmutable() {\n    return super.toImmutable();\n  }\n\n  _toImmutable() {\n    const result = this._items.map(node => node.toImmutable());\n\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  next() {\n    const result = this._innerIterator.next();\n\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n\n    const value = liveNodeToLson(result.value);\n    return {\n      value\n    };\n  }\n\n};\n\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\n\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\n\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\n\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\n\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\n\nfunction addIntentAndDeletedIdToOperation(ops, deletedId) {\n  if (ops.length === 0) {\n    throw new Error(\"Internal error. Serialized LiveStructure should have at least 1 operation\");\n  }\n\n  const firstOp = ops[0];\n  firstOp.intent = \"set\";\n  firstOp.deletedId = deletedId;\n} // src/AuthToken.ts\n\n\nvar SCOPES = [\"websocket:presence\", \"websocket:storage\", \"room:read\", \"room:write\", \"rooms:read\", \"rooms:write\"];\n\nfunction hasJwtMeta(data) {\n  if (!isPlainObject(data)) {\n    return false;\n  }\n\n  const {\n    iat,\n    exp\n  } = data;\n  return typeof iat === \"number\" && typeof exp === \"number\";\n}\n\nfunction isTokenExpired(token) {\n  const now = Date.now() / 1e3;\n  return now > token.exp - 300 || now < token.iat + 300;\n}\n\nfunction isScope(value) {\n  return SCOPES.includes(value);\n}\n\nfunction isStringList(value) {\n  return Array.isArray(value) && value.every(i => typeof i === \"string\");\n}\n\nfunction isAppOnlyAuthToken(data) {\n  return typeof data.appId === \"string\" && data.roomId === void 0 && isStringList(data.scopes);\n}\n\nfunction isRoomAuthToken(data) {\n  return typeof data.appId === \"string\" && typeof data.roomId === \"string\" && typeof data.actor === \"number\" && (data.id === void 0 || typeof data.id === \"string\") && isStringList(data.scopes) && (data.maxConnectionsPerRoom === void 0 || typeof data.maxConnectionsPerRoom === \"number\");\n}\n\nfunction isAuthToken(data) {\n  return isAppOnlyAuthToken(data) || isRoomAuthToken(data);\n}\n\nfunction parseJwtToken(token) {\n  const tokenParts = token.split(\".\");\n\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n\n  const data = tryParseJson(b64decode(tokenParts[1]));\n\n  if (data && hasJwtMeta(data)) {\n    return data;\n  } else {\n    throw new Error(\"Authentication error: missing JWT metadata\");\n  }\n}\n\nfunction parseRoomAuthToken(tokenString) {\n  const data = parseJwtToken(tokenString);\n\n  if (data && isRoomAuthToken(data)) {\n    const _a = data,\n          {\n      maxConnections: _legacyField\n    } = _a,\n          token = __objRest(_a, [\"maxConnections\"]);\n\n    return token;\n  } else {\n    throw new Error(\"Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\");\n  }\n} // src/LegacyArray.ts\n\n\nfunction asArrayWithLegacyMethods(arr) {\n  Object.defineProperty(arr, \"count\", {\n    value: arr.length,\n    enumerable: false\n  });\n  Object.defineProperty(arr, \"toArray\", {\n    value: () => arr,\n    enumerable: false\n  });\n  return freeze(arr);\n} // src/types/Json.ts\n\n\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\n\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\n\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\nexports.__spreadValues = __spreadValues;\nexports.__spreadProps = __spreadProps;\nexports.__async = __async;\nexports.deprecate = deprecate;\nexports.deprecateIf = deprecateIf;\nexports.throwUsageError = throwUsageError;\nexports.errorIf = errorIf;\nexports.assertNever = assertNever;\nexports.nn = nn;\nexports.ClientMsgCode = ClientMsgCode;\nexports.OpCode = OpCode;\nexports.CrdtType = CrdtType;\nexports.isRootCrdt = isRootCrdt;\nexports.isChildCrdt = isChildCrdt;\nexports.ServerMsgCode = ServerMsgCode;\nexports.isRoomEventName = isRoomEventName;\nexports.WebsocketCloseCodes = WebsocketCloseCodes;\nexports.LiveRegister = LiveRegister;\nexports.makePosition = makePosition;\nexports.comparePosition = comparePosition;\nexports.LiveList = LiveList;\nexports.LiveMap = LiveMap;\nexports.LiveObject = LiveObject;\nexports.freeze = freeze;\nexports.compact = compact;\nexports.compactObject = compactObject;\nexports.isSameNodeOrChildOf = isSameNodeOrChildOf;\nexports.isLiveNode = isLiveNode;\nexports.isLiveList = isLiveList;\nexports.isLiveObject = isLiveObject;\nexports.getTreesDiffOperations = getTreesDiffOperations;\nexports.mergeStorageUpdates = mergeStorageUpdates;\nexports.isPlainObject = isPlainObject;\nexports.findNonSerializableValue = findNonSerializableValue;\nexports.tryParseJson = tryParseJson;\nexports.b64decode = b64decode;\nexports.isTokenExpired = isTokenExpired;\nexports.isScope = isScope;\nexports.isAppOnlyAuthToken = isAppOnlyAuthToken;\nexports.isRoomAuthToken = isRoomAuthToken;\nexports.isAuthToken = isAuthToken;\nexports.parseRoomAuthToken = parseRoomAuthToken;\nexports.asArrayWithLegacyMethods = asArrayWithLegacyMethods;\nexports.isJsonScalar = isJsonScalar;\nexports.isJsonArray = isJsonArray;\nexports.isJsonObject = isJsonObject;","map":{"version":3,"sources":["/Users/dongxiaomu/Desktop/csce672/CSCE 672 project/CSCE672-project/node_modules/@liveblocks/client/chunk-UV2F4F4R.js"],"names":["Object","defineProperty","exports","value","__defProp","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__spreadProps","__objRest","source","exclude","target","indexOf","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","_emittedDeprecationWarnings","Set","deprecate","message","process","env","NODE_ENV","has","add","console","error","deprecateIf","condition","throwUsageError","usageError","Error","name","errorIf","assertNever","_value","errmsg","assert","err","nn","ClientMsgCode","ClientMsgCode2","OpCode","OpCode2","CrdtType","CrdtType2","isRootCrdt","crdt","type","isChildCrdt","parentId","parentKey","ServerMsgCode","ServerMsgCode2","isRoomEventName","WebsocketCloseCodes","WebsocketCloseCodes2","min","max","makePosition","before","after","pos","makePositionFromCodes","posCodes","getNextPosition","getPreviousPosition","result","afterCodes","i","length","code","push","beforeCodes","index","beforeDigit","afterDigit","slice","mid","str","codes","charCodeAt","String","fromCharCode","comparePosition","posA","posB","aCodes","bCodes","maxLength","Math","crdtAsLiveNode","HasParent","node","freeze","NoParent","Orphaned","oldKey","AbstractCrdt","constructor","_parent","_getParentKeyOrThrow","parent","_pool","__pool","roomId","_id","__id","_parentNode","_parentKey","_apply","op","_isLocal","_detachChild","modified","_setParentLink","newParentNode","newParentKey","_attach","id","pool","addNode","_detach","deleteNode","invalidate","_cachedImmutable","toImmutable","_toImmutable","LiveRegister","data","_data","_deserialize","_parentToChildren","item","register","_toOps","opId","generateOpId","_serialize","_attachChild","_op","_crdt","isLocal","LiveMap","entries2","unacknowledgedSet","Map","mappedEntries","entry","lsonToLiveNode","_map","ops","parentToChildren","_item","map","children","get","id2","child","deserialize","set","_key","isLiveNode","generateId","creationOpToLiveNode","getNode","lastUpdateOpId","delete","previousValue","reverse","thisId","updates","values","storageUpdate","liveNodeToLson","oldValue","storageUpdates","dispatch","size","entries","innerIterator","Symbol","iterator","iteratorValue","keys","forEach","callback","LiveObject","_propToLastUpdate","liveObj","_deserializeChildren","deserializeToLson","isLiveStructure","creationOpToLson","_applyUpdate","_applyDeleteObjectKey","isModified","reverseUpdate","updateDelta","unshift","toObject","fromEntries","update","keyAsString","patch","newValue","reverseOps","updatedProps","reverseUpdateOp","newAttachChildOps","createCrdtOp","find","val","compact","items","filter","compactObject","newObj","k","LiveList","isSameNodeOrChildOf","isLiveList","isLiveMap","isLiveObject","isLiveRegister","getTreesDiffOperations","currentItems","newItems","_","currentCrdt","JSON","stringify","mergeObjectStorageUpdates","first","second","mergeMapStorageUpdates","mergeListStorageUpdates","concat","mergeStorageUpdates","isPlain","Array","isArray","isPlainObject","blob","toString","findNonSerializableValue","path","nestedValue","nestedPath","nonSerializableNestedValue","iterable","tryParseJson","rawMessage","parse","b64decode","b64value","formattedValue","replace","decodedValue","decodeURIComponent","atob","split","c","join","compareNodePosition","itemA","itemB","_items","_implicitlyDeletedItems","WeakSet","_unacknowledgedSets","position","newPosition","list","_insertAndSort","_sortItems","sort","_indexOfPosition","findIndex","_applySetRemote","deletedId","indexOfItemWithSamePosition","itemWithSamePosition","makeUpdate","setDelta","delta","deleteDelta2","_detachItemAssociatedToSetOperation","insertDelta","_applySetAck","deletedDelta","unacknowledgedOpId","existingItem","splice","deleteDelta","previousIndex","newIndex","moveDelta","orphan","recreatedItemIndex","newItem","_createAttachItemAndSort","deletedItem","_applyRemoteInsert","existingItemIndex","_shiftItemPosition","_applyInsertAck","itemIndexAtPosition","oldPositionIndex","_applyInsertUndoRedo","_a","newKey","_applySetUndoRedo","indexOfItemWithSameKey","addIntentAndDeletedIdToOperation","intent","indexToDelete","_applySetChildKeyRemote","previousKey","_applySetChildKeyAck","_b","_applySetChildKeyUndoRedo","_setChildKey","element","insert","move","targetIndex","beforePosition","afterPosition","previousPosition","childRecordId","clear","childId","existingId","toArray","every","predicate","callbackfn","searchElement","fromIndex","lastIndexOf","some","LiveListIterator","shiftedPosition","_innerIterator","liveList","deltaUpdates","firstOp","SCOPES","hasJwtMeta","iat","exp","isTokenExpired","token","now","Date","isScope","includes","isStringList","isAppOnlyAuthToken","appId","scopes","isRoomAuthToken","actor","maxConnectionsPerRoom","isAuthToken","parseJwtToken","tokenParts","parseRoomAuthToken","tokenString","maxConnections","_legacyField","asArrayWithLegacyMethods","arr","isJsonScalar","isJsonArray","isJsonObject"],"mappings":"AAAA;;AAAaA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAACC,EAAAA,KAAK,EAAE;AAAR,CAA7C;AAA4D,IAAIC,SAAS,GAAGJ,MAAM,CAACC,cAAvB;AACzE,IAAII,UAAU,GAAGL,MAAM,CAACM,gBAAxB;AACA,IAAIC,iBAAiB,GAAGP,MAAM,CAACQ,yBAA/B;AACA,IAAIC,mBAAmB,GAAGT,MAAM,CAACU,qBAAjC;AACA,IAAIC,YAAY,GAAGX,MAAM,CAACY,SAAP,CAAiBC,cAApC;AACA,IAAIC,YAAY,GAAGd,MAAM,CAACY,SAAP,CAAiBG,oBAApC;;AACA,IAAIC,eAAe,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWf,KAAX,KAAqBe,GAAG,IAAID,GAAP,GAAab,SAAS,CAACa,GAAD,EAAMC,GAAN,EAAW;AAAEC,EAAAA,UAAU,EAAE,IAAd;AAAoBC,EAAAA,YAAY,EAAE,IAAlC;AAAwCC,EAAAA,QAAQ,EAAE,IAAlD;AAAwDlB,EAAAA;AAAxD,CAAX,CAAtB,GAAoGc,GAAG,CAACC,GAAD,CAAH,GAAWf,KAA1J;;AACA,IAAImB,cAAc,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC7B,OAAK,IAAIC,IAAT,IAAiBD,CAAC,KAAKA,CAAC,GAAG,EAAT,CAAlB,EACE,IAAIb,YAAY,CAACe,IAAb,CAAkBF,CAAlB,EAAqBC,IAArB,CAAJ,EACET,eAAe,CAACO,CAAD,EAAIE,IAAJ,EAAUD,CAAC,CAACC,IAAD,CAAX,CAAf;;AACJ,MAAIhB,mBAAJ,EACE,KAAK,IAAIgB,IAAT,IAAiBhB,mBAAmB,CAACe,CAAD,CAApC,EAAyC;AACvC,QAAIV,YAAY,CAACY,IAAb,CAAkBF,CAAlB,EAAqBC,IAArB,CAAJ,EACET,eAAe,CAACO,CAAD,EAAIE,IAAJ,EAAUD,CAAC,CAACC,IAAD,CAAX,CAAf;AACH;AACH,SAAOF,CAAP;AACD,CAVD;;AAWA,IAAII,aAAa,GAAG,CAACJ,CAAD,EAAIC,CAAJ,KAAUnB,UAAU,CAACkB,CAAD,EAAIhB,iBAAiB,CAACiB,CAAD,CAArB,CAAxC;;AACA,IAAII,SAAS,GAAG,CAACC,MAAD,EAASC,OAAT,KAAqB;AACnC,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIN,IAAT,IAAiBI,MAAjB,EACE,IAAIlB,YAAY,CAACe,IAAb,CAAkBG,MAAlB,EAA0BJ,IAA1B,KAAmCK,OAAO,CAACE,OAAR,CAAgBP,IAAhB,IAAwB,CAA/D,EACEM,MAAM,CAACN,IAAD,CAAN,GAAeI,MAAM,CAACJ,IAAD,CAArB;;AACJ,MAAII,MAAM,IAAI,IAAV,IAAkBpB,mBAAtB,EACE,KAAK,IAAIgB,IAAT,IAAiBhB,mBAAmB,CAACoB,MAAD,CAApC,EAA8C;AAC5C,QAAIC,OAAO,CAACE,OAAR,CAAgBP,IAAhB,IAAwB,CAAxB,IAA6BX,YAAY,CAACY,IAAb,CAAkBG,MAAlB,EAA0BJ,IAA1B,CAAjC,EACEM,MAAM,CAACN,IAAD,CAAN,GAAeI,MAAM,CAACJ,IAAD,CAArB;AACH;AACH,SAAOM,MAAP;AACD,CAXD;;AAYA,IAAIE,OAAO,GAAG,CAACC,MAAD,EAASC,WAAT,EAAsBC,SAAtB,KAAoC;AAChD,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,QAAIC,SAAS,GAAIrC,KAAD,IAAW;AACzB,UAAI;AACFsC,QAAAA,IAAI,CAACL,SAAS,CAACM,IAAV,CAAevC,KAAf,CAAD,CAAJ;AACD,OAFD,CAEE,OAAOwC,CAAP,EAAU;AACVJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AACD;AACF,KAND;;AAOA,QAAIC,QAAQ,GAAIzC,KAAD,IAAW;AACxB,UAAI;AACFsC,QAAAA,IAAI,CAACL,SAAS,CAACS,KAAV,CAAgB1C,KAAhB,CAAD,CAAJ;AACD,OAFD,CAEE,OAAOwC,CAAP,EAAU;AACVJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AACD;AACF,KAND;;AAOA,QAAIF,IAAI,GAAIK,CAAD,IAAOA,CAAC,CAACC,IAAF,GAAST,OAAO,CAACQ,CAAC,CAAC3C,KAAH,CAAhB,GAA4BkC,OAAO,CAACC,OAAR,CAAgBQ,CAAC,CAAC3C,KAAlB,EAAyB6C,IAAzB,CAA8BR,SAA9B,EAAyCI,QAAzC,CAA9C;;AACAH,IAAAA,IAAI,CAAC,CAACL,SAAS,GAAGA,SAAS,CAACa,KAAV,CAAgBf,MAAhB,EAAwBC,WAAxB,CAAb,EAAmDO,IAAnD,EAAD,CAAJ;AACD,GAjBM,CAAP;AAkBD,CAnBD,C,CAqBA;;;AACA,IAAIQ,2BAA2B,GAAG,eAAgB,IAAIC,GAAJ,EAAlD;;AACA,SAASC,SAAT,CAAmBC,OAAnB,EAA2C;AAAA,MAAfnC,GAAe,uEAATmC,OAAS;;AACzC,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAI,CAACN,2BAA2B,CAACO,GAA5B,CAAgCvC,GAAhC,CAAL,EAA2C;AACzCgC,MAAAA,2BAA2B,CAACQ,GAA5B,CAAgCxC,GAAhC;;AACAyC,MAAAA,OAAO,CAACC,KAAR,CAAe,wBAAuBP,OAAQ,EAA9C;AACD;AACF;AACF;;AACD,SAASQ,WAAT,CAAqBC,SAArB,EAAgCT,OAAhC,EAAwD;AAAA,MAAfnC,GAAe,uEAATmC,OAAS;;AACtD,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAIM,SAAJ,EAAe;AACbV,MAAAA,SAAS,CAACC,OAAD,EAAUnC,GAAV,CAAT;AACD;AACF;AACF;;AACD,SAAS6C,eAAT,CAAyBV,OAAzB,EAAkC;AAChC,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,UAAMQ,UAAU,GAAG,IAAIC,KAAJ,CAAUZ,OAAV,CAAnB;AACAW,IAAAA,UAAU,CAACE,IAAX,GAAkB,aAAlB;AACA,UAAMF,UAAN;AACD;AACF;;AACD,SAASG,OAAT,CAAiBL,SAAjB,EAA4BT,OAA5B,EAAqC;AACnC,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAIM,SAAJ,EAAe;AACbC,MAAAA,eAAe,CAACV,OAAD,CAAf;AACD;AACF;AACF,C,CAED;;;AACA,SAASe,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAAqC;AACnC,QAAM,IAAIL,KAAJ,CAAUK,MAAV,CAAN;AACD;;AACD,SAASC,MAAT,CAAgBT,SAAhB,EAA2BQ,MAA3B,EAAmC;AACjC,MAAIhB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyC,CAACM,SAA9C,EAAyD;AACvD,UAAMU,GAAG,GAAG,IAAIP,KAAJ,CAAUK,MAAV,CAAZ;AACAE,IAAAA,GAAG,CAACN,IAAJ,GAAW,mBAAX;AACA,UAAMM,GAAN;AACD;AACF;;AACD,SAASC,EAAT,CAAYtE,KAAZ,EAAiE;AAAA,MAA9CmE,MAA8C,uEAArC,mCAAqC;AAC/DC,EAAAA,MAAM,CAACpE,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAlC,EAAqCmE,MAArC,CAAN;AACA,SAAOnE,KAAP;AACD,C,CAED;;;AACA,IAAIuE,aAAa,GAAG,eAAgB,CAAEC,cAAD,IAAoB;AACvDA,EAAAA,cAAc,CAACA,cAAc,CAAC,iBAAD,CAAd,GAAoC,GAArC,CAAd,GAA0D,iBAA1D;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,iBAAD,CAAd,GAAoC,GAArC,CAAd,GAA0D,iBAA1D;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,eAAD,CAAd,GAAkC,GAAnC,CAAd,GAAwD,eAAxD;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,gBAAD,CAAd,GAAmC,GAApC,CAAd,GAAyD,gBAAzD;AACA,SAAOA,cAAP;AACD,CANmC,EAMjCD,aAAa,IAAI,EANgB,CAApC,C,CAQA;;;AACA,IAAIE,MAAM,GAAG,eAAgB,CAAEC,OAAD,IAAa;AACzCA,EAAAA,OAAO,CAACA,OAAO,CAAC,MAAD,CAAP,GAAkB,CAAnB,CAAP,GAA+B,MAA/B;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,gBAAD,CAAP,GAA4B,CAA7B,CAAP,GAAyC,gBAAzC;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,aAAD,CAAP,GAAyB,CAA1B,CAAP,GAAsC,aAAtC;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,eAAD,CAAP,GAA2B,CAA5B,CAAP,GAAwC,eAAxC;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,eAAD,CAAP,GAA2B,CAA5B,CAAP,GAAwC,eAAxC;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,aAAD,CAAP,GAAyB,CAA1B,CAAP,GAAsC,aAAtC;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,mBAAD,CAAP,GAA+B,CAAhC,CAAP,GAA4C,mBAA5C;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,YAAD,CAAP,GAAwB,CAAzB,CAAP,GAAqC,YAArC;AACAA,EAAAA,OAAO,CAACA,OAAO,CAAC,iBAAD,CAAP,GAA6B,CAA9B,CAAP,GAA0C,iBAA1C;AACA,SAAOA,OAAP;AACD,CAX4B,EAW1BD,MAAM,IAAI,EAXgB,CAA7B,C,CAaA;;;AACA,IAAIE,QAAQ,GAAG,eAAgB,CAAEC,SAAD,IAAe;AAC7CA,EAAAA,SAAS,CAACA,SAAS,CAAC,QAAD,CAAT,GAAsB,CAAvB,CAAT,GAAqC,QAArC;AACAA,EAAAA,SAAS,CAACA,SAAS,CAAC,MAAD,CAAT,GAAoB,CAArB,CAAT,GAAmC,MAAnC;AACAA,EAAAA,SAAS,CAACA,SAAS,CAAC,KAAD,CAAT,GAAmB,CAApB,CAAT,GAAkC,KAAlC;AACAA,EAAAA,SAAS,CAACA,SAAS,CAAC,UAAD,CAAT,GAAwB,CAAzB,CAAT,GAAuC,UAAvC;AACA,SAAOA,SAAP;AACD,CAN8B,EAM5BD,QAAQ,IAAI,EANgB,CAA/B;;AAOA,SAASE,UAAT,CAAoBC,IAApB,EAA0B;AACxB,SAAOA,IAAI,CAACC,IAAL,KAAc;AAAE;AAAhB,KAAgC,CAACC,WAAW,CAACF,IAAD,CAAnD;AACD;;AACD,SAASE,WAAT,CAAqBF,IAArB,EAA2B;AACzB,SAAOA,IAAI,CAACG,QAAL,KAAkB,KAAK,CAAvB,IAA4BH,IAAI,CAACI,SAAL,KAAmB,KAAK,CAA3D;AACD,C,CAED;;;AACA,IAAIC,aAAa,GAAG,eAAgB,CAAEC,cAAD,IAAoB;AACvDA,EAAAA,cAAc,CAACA,cAAc,CAAC,iBAAD,CAAd,GAAoC,GAArC,CAAd,GAA0D,iBAA1D;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,aAAD,CAAd,GAAgC,GAAjC,CAAd,GAAsD,aAAtD;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,WAAD,CAAd,GAA8B,GAA/B,CAAd,GAAoD,WAApD;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,mBAAD,CAAd,GAAsC,GAAvC,CAAd,GAA4D,mBAA5D;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,YAAD,CAAd,GAA+B,GAAhC,CAAd,GAAqD,YAArD;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,uBAAD,CAAd,GAA0C,GAA3C,CAAd,GAAgE,uBAAhE;AACAA,EAAAA,cAAc,CAACA,cAAc,CAAC,gBAAD,CAAd,GAAmC,GAApC,CAAd,GAAyD,gBAAzD;AACA,SAAOA,cAAP;AACD,CATmC,EASjCD,aAAa,IAAI,EATgB,CAApC,C,CAWA;;;AACA,SAASE,eAAT,CAAyBrF,KAAzB,EAAgC;AAC9B,SAAOA,KAAK,KAAK,aAAV,IAA2BA,KAAK,KAAK,QAArC,IAAiDA,KAAK,KAAK,OAA3D,IAAsEA,KAAK,KAAK,OAAhF,IAA2FA,KAAK,KAAK,YAArG,IAAqHA,KAAK,KAAK,SAAtI;AACD;;AACD,IAAIsF,mBAAmB,GAAG,eAAgB,CAAEC,oBAAD,IAA0B;AACnEA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,gBAAD,CAApB,GAAyC,IAA1C,CAApB,GAAsE,gBAAtE;AACAA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,wBAAD,CAApB,GAAiD,GAAlD,CAApB,GAA6E,wBAA7E;AACAA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,aAAD,CAApB,GAAsC,IAAvC,CAApB,GAAmE,aAAnE;AACAA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,oCAAD,CAApB,GAA6D,IAA9D,CAApB,GAA0F,oCAA1F;AACAA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,sCAAD,CAApB,GAA+D,IAAhE,CAApB,GAA4F,sCAA5F;AACAA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,wCAAD,CAApB,GAAiE,IAAlE,CAApB,GAA8F,wCAA9F;AACAA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,+CAAD,CAApB,GAAwE,IAAzE,CAApB,GAAqG,+CAArG;AACAA,EAAAA,oBAAoB,CAACA,oBAAoB,CAAC,qBAAD,CAApB,GAA8C,IAA/C,CAApB,GAA2E,qBAA3E;AACA,SAAOA,oBAAP;AACD,CAVyC,EAUvCD,mBAAmB,IAAI,EAVgB,CAA1C,C,CAYA;;;AACA,IAAIE,GAAG,GAAG,EAAV;AACA,IAAIC,GAAG,GAAG,GAAV;;AACA,SAASC,YAAT,CAAsBC,MAAtB,EAA8BC,KAA9B,EAAqC;AACnC,MAAID,MAAM,KAAK,KAAK,CAAhB,IAAqBC,KAAK,KAAK,KAAK,CAAxC,EAA2C;AACzC,WAAOC,GAAG,CAACC,qBAAqB,CAACC,QAAQ,CAACJ,MAAD,CAAT,EAAmBI,QAAQ,CAACH,KAAD,CAA3B,CAAtB,CAAV;AACD,GAFD,MAEO,IAAID,MAAM,KAAK,KAAK,CAApB,EAAuB;AAC5B,WAAOK,eAAe,CAACL,MAAD,CAAtB;AACD,GAFM,MAEA,IAAIC,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAC3B,WAAOK,mBAAmB,CAACL,KAAD,CAA1B;AACD;;AACD,SAAOC,GAAG,CAAC,CAACL,GAAG,GAAG,CAAP,CAAD,CAAV;AACD;;AACD,SAASS,mBAAT,CAA6BL,KAA7B,EAAoC;AAClC,QAAMM,MAAM,GAAG,EAAf;AACA,QAAMC,UAAU,GAAGJ,QAAQ,CAACH,KAAD,CAA3B;;AACA,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACE,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,UAAME,IAAI,GAAGH,UAAU,CAACC,CAAD,CAAvB;;AACA,QAAIE,IAAI,IAAId,GAAG,GAAG,CAAlB,EAAqB;AACnBU,MAAAA,MAAM,CAACK,IAAP,CAAYf,GAAZ;;AACA,UAAIW,UAAU,CAACE,MAAX,GAAoB,CAApB,KAA0BD,CAA9B,EAAiC;AAC/BF,QAAAA,MAAM,CAACK,IAAP,CAAYd,GAAZ;AACA;AACD;AACF,KAND,MAMO;AACLS,MAAAA,MAAM,CAACK,IAAP,CAAYD,IAAI,GAAG,CAAnB;AACA;AACD;AACF;;AACD,SAAOT,GAAG,CAACK,MAAD,CAAV;AACD;;AACD,SAASF,eAAT,CAAyBL,MAAzB,EAAiC;AAC/B,QAAMO,MAAM,GAAG,EAAf;AACA,QAAMM,WAAW,GAAGT,QAAQ,CAACJ,MAAD,CAA5B;;AACA,OAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,WAAW,CAACH,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,UAAME,IAAI,GAAGE,WAAW,CAACJ,CAAD,CAAxB;;AACA,QAAIE,IAAI,KAAKb,GAAb,EAAkB;AAChBS,MAAAA,MAAM,CAACK,IAAP,CAAYD,IAAZ;;AACA,UAAIE,WAAW,CAACH,MAAZ,GAAqB,CAArB,KAA2BD,CAA/B,EAAkC;AAChCF,QAAAA,MAAM,CAACK,IAAP,CAAYf,GAAG,GAAG,CAAlB;AACA;AACD;AACF,KAND,MAMO;AACLU,MAAAA,MAAM,CAACK,IAAP,CAAYD,IAAI,GAAG,CAAnB;AACA;AACD;AACF;;AACD,SAAOT,GAAG,CAACK,MAAD,CAAV;AACD;;AACD,SAASJ,qBAAT,CAA+BH,MAA/B,EAAuCC,KAAvC,EAA8C;AAC5C,MAAIa,KAAK,GAAG,CAAZ;AACA,QAAMP,MAAM,GAAG,EAAf;;AACA,SAAO,IAAP,EAAa;AACX,UAAMQ,WAAW,GAAGf,MAAM,CAACc,KAAD,CAAN,IAAiBjB,GAArC;AACA,UAAMmB,UAAU,GAAGf,KAAK,CAACa,KAAD,CAAL,IAAgBhB,GAAnC;;AACA,QAAIiB,WAAW,GAAGC,UAAlB,EAA8B;AAC5B,YAAM,IAAI7C,KAAJ,CACH,2CAA0C6B,MAAO,QAAOC,KAAM,EAD3D,CAAN;AAGD;;AACD,QAAIc,WAAW,KAAKC,UAApB,EAAgC;AAC9BT,MAAAA,MAAM,CAACK,IAAP,CAAYG,WAAZ;AACAD,MAAAA,KAAK;AACL;AACD;;AACD,QAAIE,UAAU,GAAGD,WAAb,KAA6B,CAAjC,EAAoC;AAClCR,MAAAA,MAAM,CAACK,IAAP,CAAYG,WAAZ;AACAR,MAAAA,MAAM,CAACK,IAAP,CAAY,GAAGT,qBAAqB,CAACH,MAAM,CAACiB,KAAP,CAAaH,KAAK,GAAG,CAArB,CAAD,EAA0B,EAA1B,CAApC;AACA;AACD;;AACD,UAAMI,GAAG,GAAGF,UAAU,GAAGD,WAAb,IAA4B,CAAxC;AACAR,IAAAA,MAAM,CAACK,IAAP,CAAYM,GAAZ;AACA;AACD;;AACD,SAAOX,MAAP;AACD;;AACD,SAASH,QAAT,CAAkBe,GAAlB,EAAuB;AACrB,QAAMC,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,GAAG,CAACT,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACnCW,IAAAA,KAAK,CAACR,IAAN,CAAWO,GAAG,CAACE,UAAJ,CAAeZ,CAAf,CAAX;AACD;;AACD,SAAOW,KAAP;AACD;;AACD,SAASlB,GAAT,CAAakB,KAAb,EAAoB;AAClB,SAAOE,MAAM,CAACC,YAAP,CAAoB,GAAGH,KAAvB,CAAP;AACD;;AACD,SAASI,eAAT,CAAyBC,IAAzB,EAA+BC,IAA/B,EAAqC;AACnC,QAAMC,MAAM,GAAGvB,QAAQ,CAACqB,IAAD,CAAvB;AACA,QAAMG,MAAM,GAAGxB,QAAQ,CAACsB,IAAD,CAAvB;AACA,QAAMG,SAAS,GAAGC,IAAI,CAAChC,GAAL,CAAS6B,MAAM,CAACjB,MAAhB,EAAwBkB,MAAM,CAAClB,MAA/B,CAAlB;;AACA,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoB,SAApB,EAA+BpB,CAAC,EAAhC,EAAoC;AAClC,UAAMhF,CAAC,GAAGkG,MAAM,CAAClB,CAAD,CAAN,KAAc,KAAK,CAAnB,GAAuBZ,GAAvB,GAA6B8B,MAAM,CAAClB,CAAD,CAA7C;AACA,UAAM/E,CAAC,GAAGkG,MAAM,CAACnB,CAAD,CAAN,KAAc,KAAK,CAAnB,GAAuBZ,GAAvB,GAA6B+B,MAAM,CAACnB,CAAD,CAA7C;;AACA,QAAIhF,CAAC,KAAKC,CAAV,EAAa;AACX;AACD,KAFD,MAEO;AACL,aAAOD,CAAC,GAAGC,CAAX;AACD;AACF;;AACD,QAAM,IAAIyC,KAAJ,CACH,2CAA0CsD,IAAK,UAASC,IAAK,GAD1D,CAAN;AAGD,C,CAED;;;AACA,SAASK,cAAT,CAAwB1H,KAAxB,EAA+B;AAC7B,SAAOA,KAAP;AACD;;AACD,SAAS2H,SAAT,CAAmBC,IAAnB,EAAyB7G,GAAzB,EAA8B;AAC5B,SAAOlB,MAAM,CAACgI,MAAP,CAAc;AAAE9C,IAAAA,IAAI,EAAE,WAAR;AAAqB6C,IAAAA,IAArB;AAA2B7G,IAAAA;AAA3B,GAAd,CAAP;AACD;;AACD,IAAI+G,QAAQ,GAAGjI,MAAM,CAACgI,MAAP,CAAc;AAAE9C,EAAAA,IAAI,EAAE;AAAR,CAAd,CAAf;;AACA,SAASgD,QAAT,CAAkBC,MAAlB,EAA0B;AACxB,SAAOnI,MAAM,CAACgI,MAAP,CAAc;AAAE9C,IAAAA,IAAI,EAAE,UAAR;AAAoBiD,IAAAA;AAApB,GAAd,CAAP;AACD;;AACD,IAAIC,YAAY,GAAG,MAAM;AACvBC,EAAAA,WAAW,GAAG;AACZ,SAAKC,OAAL,GAAeL,QAAf;AACD;;AACDM,EAAAA,oBAAoB,GAAG;AACrB,YAAQ,KAAKC,MAAL,CAAYtD,IAApB;AACE,WAAK,WAAL;AACE,eAAO,KAAKsD,MAAL,CAAYtH,GAAnB;;AACF,WAAK,UAAL;AACE,cAAM,IAAI+C,KAAJ,CAAU,uBAAV,CAAN;;AACF,WAAK,UAAL;AACE,eAAO,KAAKuE,MAAL,CAAYL,MAAnB;;AACF;AACE,eAAO/D,WAAW,CAAC,KAAKoE,MAAN,EAAc,eAAd,CAAlB;AARJ;AAUD;;AACQ,MAALC,KAAK,GAAG;AACV,WAAO,KAAKC,MAAZ;AACD;;AACS,MAANC,MAAM,GAAG;AACX,WAAO,KAAKD,MAAL,GAAc,KAAKA,MAAL,CAAYC,MAA1B,GAAmC,IAA1C;AACD;;AACM,MAAHC,GAAG,GAAG;AACR,WAAO,KAAKC,IAAZ;AACD;;AACS,MAANL,MAAM,GAAG;AACX,WAAO,KAAKF,OAAZ;AACD;;AACc,MAAXQ,WAAW,GAAG;AAChB,YAAQ,KAAKN,MAAL,CAAYtD,IAApB;AACE,WAAK,WAAL;AACE,eAAO,KAAKsD,MAAL,CAAYT,IAAnB;;AACF,WAAK,UAAL;AACE,eAAO,IAAP;;AACF,WAAK,UAAL;AACE,eAAO,IAAP;;AACF;AACE,eAAO3D,WAAW,CAAC,KAAKoE,MAAN,EAAc,eAAd,CAAlB;AARJ;AAUD;;AACa,MAAVO,UAAU,GAAG;AACf,YAAQ,KAAKP,MAAL,CAAYtD,IAApB;AACE,WAAK,WAAL;AACE,eAAO,KAAKsD,MAAL,CAAYtH,GAAnB;;AACF,WAAK,UAAL;AACE,eAAO,IAAP;;AACF,WAAK,UAAL;AACE,eAAO,KAAKsH,MAAL,CAAYL,MAAnB;;AACF;AACE,eAAO/D,WAAW,CAAC,KAAKoE,MAAN,EAAc,eAAd,CAAlB;AARJ;AAUD;;AACDQ,EAAAA,MAAM,CAACC,EAAD,EAAKC,QAAL,EAAe;AACnB,YAAQD,EAAE,CAAC/D,IAAX;AACE,WAAK;AAAE;AAAP;AAA0B;AACxB,cAAI,KAAKsD,MAAL,CAAYtD,IAAZ,KAAqB,WAAzB,EAAsC;AACpC,mBAAO,KAAKsD,MAAL,CAAYT,IAAZ,CAAiBoB,YAAjB,CAA8BtB,cAAc,CAAC,IAAD,CAA5C,CAAP;AACD;;AACD,iBAAO;AAAEuB,YAAAA,QAAQ,EAAE;AAAZ,WAAP;AACD;AANH;;AAQA,WAAO;AAAEA,MAAAA,QAAQ,EAAE;AAAZ,KAAP;AACD;;AACDC,EAAAA,cAAc,CAACC,aAAD,EAAgBC,YAAhB,EAA8B;AAC1C,YAAQ,KAAKf,MAAL,CAAYtD,IAApB;AACE,WAAK,WAAL;AACE,YAAI,KAAKsD,MAAL,CAAYT,IAAZ,KAAqBuB,aAAzB,EAAwC;AACtC,gBAAM,IAAIrF,KAAJ,CAAU,8CAAV,CAAN;AACD,SAFD,MAEO;AACL,eAAKqE,OAAL,GAAeR,SAAS,CAACwB,aAAD,EAAgBC,YAAhB,CAAxB;AACA;AACD;;AACH,WAAK,UAAL;AACA,WAAK,UAAL;AAAiB;AACf,eAAKjB,OAAL,GAAeR,SAAS,CAACwB,aAAD,EAAgBC,YAAhB,CAAxB;AACA;AACD;;AACD;AACE,eAAOnF,WAAW,CAAC,KAAKoE,MAAN,EAAc,eAAd,CAAlB;AAdJ;AAgBD;;AACDgB,EAAAA,OAAO,CAACC,EAAD,EAAKC,IAAL,EAAW;AAChB,QAAI,KAAKb,IAAL,IAAa,KAAKH,MAAtB,EAA8B;AAC5B,YAAM,IAAIzE,KAAJ,CAAU,sCAAV,CAAN;AACD;;AACDyF,IAAAA,IAAI,CAACC,OAAL,CAAaF,EAAb,EAAiB5B,cAAc,CAAC,IAAD,CAA/B;AACA,SAAKgB,IAAL,GAAYY,EAAZ;AACA,SAAKf,MAAL,GAAcgB,IAAd;AACD;;AACDE,EAAAA,OAAO,GAAG;AACR,QAAI,KAAKlB,MAAL,IAAe,KAAKG,IAAxB,EAA8B;AAC5B,WAAKH,MAAL,CAAYmB,UAAZ,CAAuB,KAAKhB,IAA5B;AACD;;AACD,YAAQ,KAAKL,MAAL,CAAYtD,IAApB;AACE,WAAK,WAAL;AAAkB;AAChB,eAAKoD,OAAL,GAAeJ,QAAQ,CAAC,KAAKM,MAAL,CAAYtH,GAAb,CAAvB;AACA;AACD;;AACD,WAAK,UAAL;AAAiB;AACf,eAAKoH,OAAL,GAAeL,QAAf;AACA;AACD;;AACD,WAAK,UAAL;AAAiB;AACf,eAAKK,OAAL,GAAeJ,QAAQ,CAAC,KAAKM,MAAL,CAAYL,MAAb,CAAvB;AACA;AACD;;AACD;AACE/D,QAAAA,WAAW,CAAC,KAAKoE,MAAN,EAAc,eAAd,CAAX;AAdJ;;AAgBA,SAAKE,MAAL,GAAc,KAAK,CAAnB;AACD;;AACDoB,EAAAA,UAAU,GAAG;AACX,QAAI,KAAKC,gBAAL,KAA0B,KAAK,CAAnC,EAAsC;AACpC,WAAKA,gBAAL,GAAwB,KAAK,CAA7B;;AACA,UAAI,KAAKvB,MAAL,CAAYtD,IAAZ,KAAqB,WAAzB,EAAsC;AACpC,aAAKsD,MAAL,CAAYT,IAAZ,CAAiB+B,UAAjB;AACD;AACF;AACF;;AACDE,EAAAA,WAAW,GAAG;AACZ,QAAI,KAAKD,gBAAL,KAA0B,KAAK,CAAnC,EAAsC;AACpC,WAAKA,gBAAL,GAAwB,KAAKE,YAAL,EAAxB;AACD;;AACD,WAAO,KAAKF,gBAAZ;AACD;;AA5HsB,CAAzB,C,CA+HA;;AACA,IAAIG,YAAY,GAAG,cAAc9B,YAAd,CAA2B;AAC5CC,EAAAA,WAAW,CAAC8B,IAAD,EAAO;AAChB;AACA,SAAKC,KAAL,GAAaD,IAAb;AACD;;AACO,MAAJA,IAAI,GAAG;AACT,WAAO,KAAKC,KAAZ;AACD;;AACkB,SAAZC,YAAY,OAAaC,iBAAb,EAAgCZ,IAAhC,EAAsC;AAAA,QAArC,CAACD,EAAD,EAAKc,IAAL,CAAqC;AACvD,UAAMC,QAAQ,GAAG,IAAIN,YAAJ,CAAiBK,IAAI,CAACJ,IAAtB,CAAjB;;AACAK,IAAAA,QAAQ,CAAChB,OAAT,CAAiBC,EAAjB,EAAqBC,IAArB;;AACA,WAAOc,QAAP;AACD;;AACDC,EAAAA,MAAM,CAACrF,QAAD,EAAWC,SAAX,EAAsBqE,IAAtB,EAA4B;AAChC,QAAI,KAAKd,GAAL,KAAa,KAAK,CAAtB,EAAyB;AACvB,YAAM,IAAI3E,KAAJ,CACJ,iEADI,CAAN;AAGD;;AACD,WAAO,CACL;AACEiB,MAAAA,IAAI,EAAE;AAAE;AADV;AAEEwF,MAAAA,IAAI,EAAEhB,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACiB,YAAL,EAFhC;AAGElB,MAAAA,EAAE,EAAE,KAAKb,GAHX;AAIExD,MAAAA,QAJF;AAKEC,MAAAA,SALF;AAME8E,MAAAA,IAAI,EAAE,KAAKA;AANb,KADK,CAAP;AAUD;;AACDS,EAAAA,UAAU,GAAG;AACX,QAAI,KAAKpC,MAAL,CAAYtD,IAAZ,KAAqB,WAAzB,EAAsC;AACpC,YAAM,IAAIjB,KAAJ,CAAU,oDAAV,CAAN;AACD;;AACD,WAAO;AACLiB,MAAAA,IAAI,EAAE;AAAE;AADH;AAELE,MAAAA,QAAQ,EAAEX,EAAE,CAAC,KAAK+D,MAAL,CAAYT,IAAZ,CAAiBa,GAAlB,EAAuB,iCAAvB,CAFP;AAGLvD,MAAAA,SAAS,EAAE,KAAKmD,MAAL,CAAYtH,GAHlB;AAILiJ,MAAAA,IAAI,EAAE,KAAKA;AAJN,KAAP;AAMD;;AACDU,EAAAA,YAAY,CAACC,GAAD,EAAM;AAChB,UAAM,IAAI7G,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACDkF,EAAAA,YAAY,CAAC4B,KAAD,EAAQ;AAClB,UAAM,IAAI9G,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD+E,EAAAA,MAAM,CAACC,EAAD,EAAK+B,OAAL,EAAc;AAClB,WAAO,MAAMhC,MAAN,CAAaC,EAAb,EAAiB+B,OAAjB,CAAP;AACD;;AACDf,EAAAA,YAAY,GAAG;AACb,WAAO,KAAKG,KAAZ;AACD;;AApD2C,CAA9C,C,CAuDA;;AACA,IAAIa,OAAO,GAAG,cAAc7C,YAAd,CAA2B;AACvCC,EAAAA,WAAW,CAAC6C,QAAD,EAAW;AACpB;AACA,SAAKC,iBAAL,GAAyB,eAAgB,IAAIC,GAAJ,EAAzC;;AACA,QAAIF,QAAJ,EAAc;AACZ,YAAMG,aAAa,GAAG,EAAtB;;AACA,WAAK,MAAMC,KAAX,IAAoBJ,QAApB,EAA8B;AAC5B,cAAM/K,KAAK,GAAGoL,cAAc,CAACD,KAAK,CAAC,CAAD,CAAN,CAA5B;;AACAnL,QAAAA,KAAK,CAACkJ,cAAN,CAAqB,IAArB,EAA2BiC,KAAK,CAAC,CAAD,CAAhC;;AACAD,QAAAA,aAAa,CAAC3E,IAAd,CAAmB,CAAC4E,KAAK,CAAC,CAAD,CAAN,EAAWnL,KAAX,CAAnB;AACD;;AACD,WAAKqL,IAAL,GAAY,IAAIJ,GAAJ,CAAQC,aAAR,CAAZ;AACD,KARD,MAQO;AACL,WAAKG,IAAL,GAAY,eAAgB,IAAIJ,GAAJ,EAA5B;AACD;AACF;;AACDX,EAAAA,MAAM,CAACrF,QAAD,EAAWC,SAAX,EAAsBqE,IAAtB,EAA4B;AAChC,QAAI,KAAKd,GAAL,KAAa,KAAK,CAAtB,EAAyB;AACvB,YAAM,IAAI3E,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,UAAMwH,GAAG,GAAG,EAAZ;AACA,UAAMxC,EAAE,GAAG;AACTQ,MAAAA,EAAE,EAAE,KAAKb,GADA;AAET8B,MAAAA,IAAI,EAAEhB,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACiB,YAAL,EAFrB;AAGTzF,MAAAA,IAAI,EAAE;AAAE;AAHC;AAITE,MAAAA,QAJS;AAKTC,MAAAA;AALS,KAAX;AAOAoG,IAAAA,GAAG,CAAC/E,IAAJ,CAASuC,EAAT;;AACA,SAAK,MAAM,CAAC/H,GAAD,EAAMf,KAAN,CAAX,IAA2B,KAAKqL,IAAhC,EAAsC;AACpCC,MAAAA,GAAG,CAAC/E,IAAJ,CAAS,GAAGvG,KAAK,CAACsK,MAAN,CAAa,KAAK7B,GAAlB,EAAuB1H,GAAvB,EAA4BwI,IAA5B,CAAZ;AACD;;AACD,WAAO+B,GAAP;AACD;;AACkB,SAAZpB,YAAY,QAAcqB,gBAAd,EAAgChC,IAAhC,EAAsC;AAAA,QAArC,CAACD,EAAD,EAAKkC,KAAL,CAAqC;AACvD,UAAMC,GAAG,GAAG,IAAIX,OAAJ,EAAZ;;AACAW,IAAAA,GAAG,CAACpC,OAAJ,CAAYC,EAAZ,EAAgBC,IAAhB;;AACA,UAAMmC,QAAQ,GAAGH,gBAAgB,CAACI,GAAjB,CAAqBrC,EAArB,CAAjB;;AACA,QAAIoC,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvB,aAAOD,GAAP;AACD;;AACD,SAAK,MAAM,CAACG,GAAD,EAAM9G,IAAN,CAAX,IAA0B4G,QAA1B,EAAoC;AAClC,YAAMG,KAAK,GAAGC,WAAW,CAAC,CAACF,GAAD,EAAM9G,IAAN,CAAD,EAAcyG,gBAAd,EAAgChC,IAAhC,CAAzB;;AACAsC,MAAAA,KAAK,CAAC3C,cAAN,CAAqBuC,GAArB,EAA0B3G,IAAI,CAACI,SAA/B;;AACAuG,MAAAA,GAAG,CAACJ,IAAJ,CAASU,GAAT,CAAajH,IAAI,CAACI,SAAlB,EAA6B2G,KAA7B;;AACAJ,MAAAA,GAAG,CAAC9B,UAAJ;AACD;;AACD,WAAO8B,GAAP;AACD;;AACDpC,EAAAA,OAAO,CAACC,EAAD,EAAKC,IAAL,EAAW;AAChB,UAAMF,OAAN,CAAcC,EAAd,EAAkBC,IAAlB;;AACA,SAAK,MAAM,CAACyC,IAAD,EAAOhM,KAAP,CAAX,IAA4B,KAAKqL,IAAjC,EAAuC;AACrC,UAAIY,UAAU,CAACjM,KAAD,CAAd,EAAuB;AACrBA,QAAAA,KAAK,CAACqJ,OAAN,CAAcE,IAAI,CAAC2C,UAAL,EAAd,EAAiC3C,IAAjC;AACD;AACF;AACF;;AACDmB,EAAAA,YAAY,CAAC5B,EAAD,EAAKpH,MAAL,EAAa;AACvB,QAAI,KAAK4G,KAAL,KAAe,KAAK,CAAxB,EAA2B;AACzB,YAAM,IAAIxE,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,UAAM;AAAEwF,MAAAA,EAAF;AAAMpE,MAAAA,SAAN;AAAiBqF,MAAAA;AAAjB,QAA0BzB,EAAhC;AACA,UAAM/H,GAAG,GAAGmE,SAAZ;AACA,UAAM2G,KAAK,GAAGM,oBAAoB,CAACrD,EAAD,CAAlC;;AACA,QAAI,KAAKR,KAAL,CAAW8D,OAAX,CAAmB9C,EAAnB,MAA2B,KAAK,CAApC,EAAuC;AACrC,aAAO;AAAEL,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD;;AACD,QAAIvH,MAAM,KAAK;AAAE;AAAjB,MAA4B;AAC1B,YAAM2K,cAAc,GAAG,KAAKrB,iBAAL,CAAuBW,GAAvB,CAA2B5K,GAA3B,CAAvB;;AACA,UAAIsL,cAAc,KAAK9B,IAAvB,EAA6B;AAC3B,aAAKS,iBAAL,CAAuBsB,MAAvB,CAA8BvL,GAA9B;AACA,eAAO;AAAEkI,UAAAA,QAAQ,EAAE;AAAZ,SAAP;AACD,OAHD,MAGO,IAAIoD,cAAc,KAAK,KAAK,CAA5B,EAA+B;AACpC,eAAO;AAAEpD,UAAAA,QAAQ,EAAE;AAAZ,SAAP;AACD;AACF,KARD,MAQO,IAAIvH,MAAM,KAAK;AAAE;AAAjB,MAA+B;AACpC,WAAKsJ,iBAAL,CAAuBsB,MAAvB,CAA8BvL,GAA9B;AACD;;AACD,UAAMwL,aAAa,GAAG,KAAKlB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAtB;;AACA,QAAIyL,OAAJ;;AACA,QAAID,aAAJ,EAAmB;AACjB,YAAME,MAAM,GAAGnI,EAAE,CAAC,KAAKmE,GAAN,CAAjB;AACA+D,MAAAA,OAAO,GAAGD,aAAa,CAACjC,MAAd,CAAqBmC,MAArB,EAA6B1L,GAA7B,CAAV;;AACAwL,MAAAA,aAAa,CAAC9C,OAAd;AACD,KAJD,MAIO;AACL+C,MAAAA,OAAO,GAAG,CAAC;AAAEzH,QAAAA,IAAI,EAAE;AAAE;AAAV;AAA6BuE,QAAAA;AAA7B,OAAD,CAAV;AACD;;AACDuC,IAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BnI,GAA3B;;AACA8K,IAAAA,KAAK,CAACxC,OAAN,CAAcC,EAAd,EAAkB,KAAKhB,KAAvB;;AACA,SAAK+C,IAAL,CAAUU,GAAV,CAAchL,GAAd,EAAmB8K,KAAnB;;AACA,SAAKlC,UAAL;AACA,WAAO;AACLV,MAAAA,QAAQ,EAAE;AACRrB,QAAAA,IAAI,EAAE,IADE;AAER7C,QAAAA,IAAI,EAAE,SAFE;AAGR2H,QAAAA,OAAO,EAAE;AAAE,WAAC3L,GAAD,GAAO;AAAEgE,YAAAA,IAAI,EAAE;AAAR;AAAT;AAHD,OADL;AAMLyH,MAAAA;AANK,KAAP;AAQD;;AACD/C,EAAAA,OAAO,GAAG;AACR,UAAMA,OAAN;;AACA,SAAK,MAAMW,IAAX,IAAmB,KAAKiB,IAAL,CAAUsB,MAAV,EAAnB,EAAuC;AACrCvC,MAAAA,IAAI,CAACX,OAAL;AACD;AACF;;AACDT,EAAAA,YAAY,CAAC6C,KAAD,EAAQ;AAClB,UAAMvC,EAAE,GAAGhF,EAAE,CAAC,KAAKmE,GAAN,CAAb;AACA,UAAMvD,SAAS,GAAGZ,EAAE,CAACuH,KAAK,CAACjD,UAAP,CAApB;;AACA,UAAM4D,OAAO,GAAGX,KAAK,CAACvB,MAAN,CAAahB,EAAb,EAAiBpE,SAAjB,EAA4B,KAAKoD,KAAjC,CAAhB;;AACA,SAAK,MAAM,CAACvH,GAAD,EAAMf,KAAN,CAAX,IAA2B,KAAKqL,IAAhC,EAAsC;AACpC,UAAIrL,KAAK,KAAK6L,KAAd,EAAqB;AACnB,aAAKR,IAAL,CAAUiB,MAAV,CAAiBvL,GAAjB;;AACA,aAAK4I,UAAL;AACD;AACF;;AACDkC,IAAAA,KAAK,CAACpC,OAAN;;AACA,UAAMmD,aAAa,GAAG;AACpBhF,MAAAA,IAAI,EAAE,IADc;AAEpB7C,MAAAA,IAAI,EAAE,SAFc;AAGpB2H,MAAAA,OAAO,EAAE;AAAE,SAACxH,SAAD,GAAa;AAAEH,UAAAA,IAAI,EAAE;AAAR;AAAf;AAHW,KAAtB;AAKA,WAAO;AAAEkE,MAAAA,QAAQ,EAAE2D,aAAZ;AAA2BJ,MAAAA;AAA3B,KAAP;AACD;;AACD/B,EAAAA,UAAU,GAAG;AACX,QAAI,KAAKpC,MAAL,CAAYtD,IAAZ,KAAqB,WAAzB,EAAsC;AACpC,YAAM,IAAIjB,KAAJ,CAAU,+CAAV,CAAN;AACD;;AACD,WAAO;AACLiB,MAAAA,IAAI,EAAE;AAAE;AADH;AAELE,MAAAA,QAAQ,EAAEX,EAAE,CAAC,KAAK+D,MAAL,CAAYT,IAAZ,CAAiBa,GAAlB,EAAuB,iCAAvB,CAFP;AAGLvD,MAAAA,SAAS,EAAE,KAAKmD,MAAL,CAAYtH;AAHlB,KAAP;AAKD;;AACD4K,EAAAA,GAAG,CAAC5K,GAAD,EAAM;AACP,UAAMf,KAAK,GAAG,KAAKqL,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAd;;AACA,QAAIf,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpB,aAAO,KAAK,CAAZ;AACD;;AACD,WAAO6M,cAAc,CAAC7M,KAAD,CAArB;AACD;;AACD+L,EAAAA,GAAG,CAAChL,GAAD,EAAMf,KAAN,EAAa;AACd,UAAM8M,QAAQ,GAAG,KAAKzB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAjB;;AACA,QAAI+L,QAAJ,EAAc;AACZA,MAAAA,QAAQ,CAACrD,OAAT;AACD;;AACD,UAAMW,IAAI,GAAGgB,cAAc,CAACpL,KAAD,CAA3B;;AACAoK,IAAAA,IAAI,CAAClB,cAAL,CAAoB,IAApB,EAA0BnI,GAA1B;;AACA,SAAKsK,IAAL,CAAUU,GAAV,CAAchL,GAAd,EAAmBqJ,IAAnB;;AACA,SAAKT,UAAL;;AACA,QAAI,KAAKrB,KAAL,IAAc,KAAKG,GAAvB,EAA4B;AAC1B,YAAMa,EAAE,GAAG,KAAKhB,KAAL,CAAW4D,UAAX,EAAX;;AACA9B,MAAAA,IAAI,CAACf,OAAL,CAAaC,EAAb,EAAiB,KAAKhB,KAAtB;;AACA,YAAMyE,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,EAAvC;AACA8B,MAAAA,cAAc,CAAChB,GAAf,CAAmB,KAAKtD,GAAxB,EAA6B;AAC3Bb,QAAAA,IAAI,EAAE,IADqB;AAE3B7C,QAAAA,IAAI,EAAE,SAFqB;AAG3B2H,QAAAA,OAAO,EAAE;AAAE,WAAC3L,GAAD,GAAO;AAAEgE,YAAAA,IAAI,EAAE;AAAR;AAAT;AAHkB,OAA7B;;AAKA,YAAMuG,GAAG,GAAGlB,IAAI,CAACE,MAAL,CAAY,KAAK7B,GAAjB,EAAsB1H,GAAtB,EAA2B,KAAKuH,KAAhC,CAAZ;;AACA,WAAK0C,iBAAL,CAAuBe,GAAvB,CAA2BhL,GAA3B,EAAgCuD,EAAE,CAACgH,GAAG,CAAC,CAAD,CAAH,CAAOf,IAAR,CAAlC;;AACA,WAAKjC,KAAL,CAAW0E,QAAX,CACE5C,IAAI,CAACE,MAAL,CAAY,KAAK7B,GAAjB,EAAsB1H,GAAtB,EAA2B,KAAKuH,KAAhC,CADF,EAEEwE,QAAQ,GAAGA,QAAQ,CAACxC,MAAT,CAAgB,KAAK7B,GAArB,EAA0B1H,GAA1B,CAAH,GAAoC,CAAC;AAAEgE,QAAAA,IAAI,EAAE;AAAE;AAAV;AAA6BuE,QAAAA;AAA7B,OAAD,CAF9C,EAGEyD,cAHF;AAKD;AACF;;AACO,MAAJE,IAAI,GAAG;AACT,WAAO,KAAK5B,IAAL,CAAU4B,IAAjB;AACD;;AACD3J,EAAAA,GAAG,CAACvC,GAAD,EAAM;AACP,WAAO,KAAKsK,IAAL,CAAU/H,GAAV,CAAcvC,GAAd,CAAP;AACD;;AACDuL,EAAAA,MAAM,CAACvL,GAAD,EAAM;AACV,UAAMqJ,IAAI,GAAG,KAAKiB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAb;;AACA,QAAIqJ,IAAI,KAAK,KAAK,CAAlB,EAAqB;AACnB,aAAO,KAAP;AACD;;AACDA,IAAAA,IAAI,CAACX,OAAL;;AACA,SAAK4B,IAAL,CAAUiB,MAAV,CAAiBvL,GAAjB;;AACA,SAAK4I,UAAL;;AACA,QAAI,KAAKrB,KAAL,IAAc8B,IAAI,CAAC3B,GAAvB,EAA4B;AAC1B,YAAMgE,MAAM,GAAGnI,EAAE,CAAC,KAAKmE,GAAN,CAAjB;AACA,YAAMsE,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,EAAvC;AACA8B,MAAAA,cAAc,CAAChB,GAAf,CAAmBU,MAAnB,EAA2B;AACzB7E,QAAAA,IAAI,EAAE,IADmB;AAEzB7C,QAAAA,IAAI,EAAE,SAFmB;AAGzB2H,QAAAA,OAAO,EAAE;AAAE,WAAC3L,GAAD,GAAO;AAAEgE,YAAAA,IAAI,EAAE;AAAR;AAAT;AAHgB,OAA3B;;AAKA,WAAKuD,KAAL,CAAW0E,QAAX,CACE,CACE;AACEjI,QAAAA,IAAI,EAAE;AAAE;AADV;AAEEuE,QAAAA,EAAE,EAAEc,IAAI,CAAC3B,GAFX;AAGE8B,QAAAA,IAAI,EAAE,KAAKjC,KAAL,CAAWkC,YAAX;AAHR,OADF,CADF,EAQEJ,IAAI,CAACE,MAAL,CAAYmC,MAAZ,EAAoB1L,GAApB,CARF,EASEgM,cATF;AAWD;;AACD,WAAO,IAAP;AACD;;AACDG,EAAAA,OAAO,GAAG;AACR,UAAMC,aAAa,GAAG,KAAK9B,IAAL,CAAU6B,OAAV,EAAtB;;AACA,WAAO;AACL,OAACE,MAAM,CAACC,QAAR,IAAoB;AAClB,eAAO,IAAP;AACD,OAHI;;AAIL9K,MAAAA,IAAI,GAAG;AACL,cAAM+K,aAAa,GAAGH,aAAa,CAAC5K,IAAd,EAAtB;;AACA,YAAI+K,aAAa,CAAC1K,IAAlB,EAAwB;AACtB,iBAAO;AACLA,YAAAA,IAAI,EAAE,IADD;AAEL5C,YAAAA,KAAK,EAAE,KAAK;AAFP,WAAP;AAID;;AACD,cAAMmL,KAAK,GAAGmC,aAAa,CAACtN,KAA5B;AACA,cAAMe,GAAG,GAAGoK,KAAK,CAAC,CAAD,CAAjB;AACA,cAAMnL,KAAK,GAAG6M,cAAc,CAACS,aAAa,CAACtN,KAAd,CAAoB,CAApB,CAAD,CAA5B;AACA,eAAO;AACLA,UAAAA,KAAK,EAAE,CAACe,GAAD,EAAMf,KAAN;AADF,SAAP;AAGD;;AAlBI,KAAP;AAoBD;;AACe,GAAfoN,MAAM,CAACC,QAAQ,IAAI;AAClB,WAAO,KAAKH,OAAL,EAAP;AACD;;AACDK,EAAAA,IAAI,GAAG;AACL,WAAO,KAAKlC,IAAL,CAAUkC,IAAV,EAAP;AACD;;AACDZ,EAAAA,MAAM,GAAG;AACP,UAAMQ,aAAa,GAAG,KAAK9B,IAAL,CAAUsB,MAAV,EAAtB;;AACA,WAAO;AACL,OAACS,MAAM,CAACC,QAAR,IAAoB;AAClB,eAAO,IAAP;AACD,OAHI;;AAIL9K,MAAAA,IAAI,GAAG;AACL,cAAM+K,aAAa,GAAGH,aAAa,CAAC5K,IAAd,EAAtB;;AACA,YAAI+K,aAAa,CAAC1K,IAAlB,EAAwB;AACtB,iBAAO;AACLA,YAAAA,IAAI,EAAE,IADD;AAEL5C,YAAAA,KAAK,EAAE,KAAK;AAFP,WAAP;AAID;;AACD,cAAMA,KAAK,GAAG6M,cAAc,CAACS,aAAa,CAACtN,KAAf,CAA5B;AACA,eAAO;AAAEA,UAAAA;AAAF,SAAP;AACD;;AAdI,KAAP;AAgBD;;AACDwN,EAAAA,OAAO,CAACC,QAAD,EAAW;AAChB,SAAK,MAAMtC,KAAX,IAAoB,IAApB,EAA0B;AACxBsC,MAAAA,QAAQ,CAACtC,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqB,IAArB,CAAR;AACD;AACF;;AACDtB,EAAAA,WAAW,GAAG;AACZ,WAAO,MAAMA,WAAN,EAAP;AACD;;AACDC,EAAAA,YAAY,GAAG;AACb,UAAM5D,MAAM,GAAG,eAAgB,IAAI+E,GAAJ,EAA/B;;AACA,SAAK,MAAM,CAAClK,GAAD,EAAMf,KAAN,CAAX,IAA2B,KAAKqL,IAAhC,EAAsC;AACpCnF,MAAAA,MAAM,CAAC6F,GAAP,CAAWhL,GAAX,EAAgBf,KAAK,CAAC6J,WAAN,EAAhB;AACD;;AACD,WAAOhC,MAAM,CAAC3B,MAAD,CAAb;AACD;;AA1QsC,CAAzC,C,CA6QA;;AACA,IAAIwH,UAAU,GAAG,cAAczF,YAAd,CAA2B;AAC1CC,EAAAA,WAAW,GAAW;AAAA,QAAVpH,GAAU,uEAAJ,EAAI;AACpB;AACA,SAAK6M,iBAAL,GAAyB,eAAgB,IAAI1C,GAAJ,EAAzC;;AACA,SAAK,MAAMlK,GAAX,IAAkBD,GAAlB,EAAuB;AACrB,YAAMd,KAAK,GAAGc,GAAG,CAACC,GAAD,CAAjB;;AACA,UAAIf,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpB;AACD,OAFD,MAEO,IAAIiM,UAAU,CAACjM,KAAD,CAAd,EAAuB;AAC5BA,QAAAA,KAAK,CAACkJ,cAAN,CAAqB,IAArB,EAA2BnI,GAA3B;AACD;AACF;;AACD,SAAKsK,IAAL,GAAY,IAAIJ,GAAJ,CAAQpL,MAAM,CAACqN,OAAP,CAAepM,GAAf,CAAR,CAAZ;AACD;;AACDwJ,EAAAA,MAAM,CAACrF,QAAD,EAAWC,SAAX,EAAsBqE,IAAtB,EAA4B;AAChC,QAAI,KAAKd,GAAL,KAAa,KAAK,CAAtB,EAAyB;AACvB,YAAM,IAAI3E,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,UAAMyG,IAAI,GAAGhB,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACiB,YAAL,EAArC;AACA,UAAMc,GAAG,GAAG,EAAZ;AACA,UAAMxC,EAAE,GAAG7D,QAAQ,KAAK,KAAK,CAAlB,IAAuBC,SAAS,KAAK,KAAK,CAA1C,GAA8C;AACvDH,MAAAA,IAAI,EAAE;AAAE;AAD+C;AAEvDuE,MAAAA,EAAE,EAAE,KAAKb,GAF8C;AAGvD8B,MAAAA,IAHuD;AAIvDtF,MAAAA,QAJuD;AAKvDC,MAAAA,SALuD;AAMvD8E,MAAAA,IAAI,EAAE;AANiD,KAA9C,GAOP;AAAEjF,MAAAA,IAAI,EAAE;AAAE;AAAV;AAA+BuE,MAAAA,EAAE,EAAE,KAAKb,GAAxC;AAA6C8B,MAAAA,IAA7C;AAAmDP,MAAAA,IAAI,EAAE;AAAzD,KAPJ;AAQAsB,IAAAA,GAAG,CAAC/E,IAAJ,CAASuC,EAAT;;AACA,SAAK,MAAM,CAAC/H,GAAD,EAAMf,KAAN,CAAX,IAA2B,KAAKqL,IAAhC,EAAsC;AACpC,UAAIY,UAAU,CAACjM,KAAD,CAAd,EAAuB;AACrBsL,QAAAA,GAAG,CAAC/E,IAAJ,CAAS,GAAGvG,KAAK,CAACsK,MAAN,CAAa,KAAK7B,GAAlB,EAAuB1H,GAAvB,EAA4BwI,IAA5B,CAAZ;AACD,OAFD,MAEO;AACLT,QAAAA,EAAE,CAACkB,IAAH,CAAQjJ,GAAR,IAAef,KAAf;AACD;AACF;;AACD,WAAOsL,GAAP;AACD;;AACkB,SAAZpB,YAAY,QAAaqB,gBAAb,EAA+BhC,IAA/B,EAAqC;AAAA,QAApC,CAACD,EAAD,EAAKc,IAAL,CAAoC;AACtD,UAAMwD,OAAO,GAAG,IAAIF,UAAJ,CAAetD,IAAI,CAACJ,IAApB,CAAhB;;AACA4D,IAAAA,OAAO,CAACvE,OAAR,CAAgBC,EAAhB,EAAoBC,IAApB;;AACA,WAAO,KAAKsE,oBAAL,CAA0BD,OAA1B,EAAmCrC,gBAAnC,EAAqDhC,IAArD,CAAP;AACD;;AAC0B,SAApBsE,oBAAoB,CAACD,OAAD,EAAUrC,gBAAV,EAA4BhC,IAA5B,EAAkC;AAC3D,UAAMmC,QAAQ,GAAGH,gBAAgB,CAACI,GAAjB,CAAqBrH,EAAE,CAACsJ,OAAO,CAACnF,GAAT,CAAvB,CAAjB;;AACA,QAAIiD,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvB,aAAOkC,OAAP;AACD;;AACD,SAAK,MAAM,CAACtE,EAAD,EAAKxE,IAAL,CAAX,IAAyB4G,QAAzB,EAAmC;AACjC,YAAMG,KAAK,GAAGiC,iBAAiB,CAAC,CAACxE,EAAD,EAAKxE,IAAL,CAAD,EAAayG,gBAAb,EAA+BhC,IAA/B,CAA/B;;AACA,UAAIwE,eAAe,CAAClC,KAAD,CAAnB,EAA4B;AAC1BA,QAAAA,KAAK,CAAC3C,cAAN,CAAqB0E,OAArB,EAA8B9I,IAAI,CAACI,SAAnC;AACD;;AACD0I,MAAAA,OAAO,CAACvC,IAAR,CAAaU,GAAb,CAAiBjH,IAAI,CAACI,SAAtB,EAAiC2G,KAAjC;;AACA+B,MAAAA,OAAO,CAACjE,UAAR;AACD;;AACD,WAAOiE,OAAP;AACD;;AACDvE,EAAAA,OAAO,CAACC,EAAD,EAAKC,IAAL,EAAW;AAChB,UAAMF,OAAN,CAAcC,EAAd,EAAkBC,IAAlB;;AACA,SAAK,MAAM,CAACyC,IAAD,EAAOhM,KAAP,CAAX,IAA4B,KAAKqL,IAAjC,EAAuC;AACrC,UAAIY,UAAU,CAACjM,KAAD,CAAd,EAAuB;AACrBA,QAAAA,KAAK,CAACqJ,OAAN,CAAcE,IAAI,CAAC2C,UAAL,EAAd,EAAiC3C,IAAjC;AACD;AACF;AACF;;AACDmB,EAAAA,YAAY,CAAC5B,EAAD,EAAKpH,MAAL,EAAa;AACvB,QAAI,KAAK4G,KAAL,KAAe,KAAK,CAAxB,EAA2B;AACzB,YAAM,IAAIxE,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,UAAM;AAAEwF,MAAAA,EAAF;AAAMiB,MAAAA,IAAN;AAAYrF,MAAAA,SAAS,EAAEnE;AAAvB,QAA+B+H,EAArC;AACA,UAAM+C,KAAK,GAAGmC,gBAAgB,CAAClF,EAAD,CAA9B;;AACA,QAAI,KAAKR,KAAL,CAAW8D,OAAX,CAAmB9C,EAAnB,MAA2B,KAAK,CAApC,EAAuC;AACrC,UAAI,KAAKqE,iBAAL,CAAuBhC,GAAvB,CAA2B5K,GAA3B,MAAoCwJ,IAAxC,EAA8C;AAC5C,aAAKoD,iBAAL,CAAuBrB,MAAvB,CAA8BvL,GAA9B;AACD;;AACD,aAAO;AAAEkI,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD;;AACD,QAAIvH,MAAM,KAAK;AAAE;AAAjB,MAA2C;AACzC,WAAKiM,iBAAL,CAAuB5B,GAAvB,CAA2BhL,GAA3B,EAAgCuD,EAAE,CAACiG,IAAD,CAAlC;AACD,KAFD,MAEO,IAAI,KAAKoD,iBAAL,CAAuBhC,GAAvB,CAA2B5K,GAA3B,MAAoC,KAAK,CAA7C,EAAgD,CACtD,CADM,MACA,IAAI,KAAK4M,iBAAL,CAAuBhC,GAAvB,CAA2B5K,GAA3B,MAAoCwJ,IAAxC,EAA8C;AACnD,WAAKoD,iBAAL,CAAuBrB,MAAvB,CAA8BvL,GAA9B;;AACA,aAAO;AAAEkI,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD,KAHM,MAGA;AACL,aAAO;AAAEA,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD;;AACD,UAAMwD,MAAM,GAAGnI,EAAE,CAAC,KAAKmE,GAAN,CAAjB;;AACA,UAAM8D,aAAa,GAAG,KAAKlB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAtB;;AACA,QAAIyL,OAAJ;;AACA,QAAIP,UAAU,CAACM,aAAD,CAAd,EAA+B;AAC7BC,MAAAA,OAAO,GAAGD,aAAa,CAACjC,MAAd,CAAqBmC,MAArB,EAA6B1L,GAA7B,CAAV;;AACAwL,MAAAA,aAAa,CAAC9C,OAAd;AACD,KAHD,MAGO,IAAI8C,aAAa,KAAK,KAAK,CAA3B,EAA8B;AACnCC,MAAAA,OAAO,GAAG,CAAC;AAAEzH,QAAAA,IAAI,EAAE;AAAE;AAAV;AAAmCuE,QAAAA,EAAE,EAAEmD,MAAvC;AAA+C1L,QAAAA;AAA/C,OAAD,CAAV;AACD,KAFM,MAEA;AACLyL,MAAAA,OAAO,GAAG,CACR;AACEzH,QAAAA,IAAI,EAAE;AAAE;AADV;AAEEuE,QAAAA,EAAE,EAAEmD,MAFN;AAGEzC,QAAAA,IAAI,EAAE;AAAE,WAACjJ,GAAD,GAAOwL;AAAT;AAHR,OADQ,CAAV;AAOD;;AACD,SAAKlB,IAAL,CAAUU,GAAV,CAAchL,GAAd,EAAmB8K,KAAnB;;AACA,SAAKlC,UAAL;;AACA,QAAIoE,eAAe,CAAClC,KAAD,CAAnB,EAA4B;AAC1BA,MAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BnI,GAA3B;;AACA8K,MAAAA,KAAK,CAACxC,OAAN,CAAcC,EAAd,EAAkB,KAAKhB,KAAvB;AACD;;AACD,WAAO;AACLkE,MAAAA,OADK;AAELvD,MAAAA,QAAQ,EAAE;AACRrB,QAAAA,IAAI,EAAE,IADE;AAER7C,QAAAA,IAAI,EAAE,YAFE;AAGR2H,QAAAA,OAAO,EAAE;AAAE,WAAC3L,GAAD,GAAO;AAAEgE,YAAAA,IAAI,EAAE;AAAR;AAAT;AAHD;AAFL,KAAP;AAQD;;AACDiE,EAAAA,YAAY,CAAC6C,KAAD,EAAQ;AAClB,QAAIA,KAAJ,EAAW;AACT,YAAMvC,EAAE,GAAGhF,EAAE,CAAC,KAAKmE,GAAN,CAAb;AACA,YAAMvD,SAAS,GAAGZ,EAAE,CAACuH,KAAK,CAACjD,UAAP,CAApB;;AACA,YAAM4D,OAAO,GAAGX,KAAK,CAACvB,MAAN,CAAahB,EAAb,EAAiBpE,SAAjB,EAA4B,KAAKoD,KAAjC,CAAhB;;AACA,WAAK,MAAM,CAACvH,GAAD,EAAMf,KAAN,CAAX,IAA2B,KAAKqL,IAAhC,EAAsC;AACpC,YAAIrL,KAAK,KAAK6L,KAAd,EAAqB;AACnB,eAAKR,IAAL,CAAUiB,MAAV,CAAiBvL,GAAjB;;AACA,eAAK4I,UAAL;AACD;AACF;;AACDkC,MAAAA,KAAK,CAACpC,OAAN;;AACA,YAAMmD,aAAa,GAAG;AACpBhF,QAAAA,IAAI,EAAE,IADc;AAEpB7C,QAAAA,IAAI,EAAE,YAFc;AAGpB2H,QAAAA,OAAO,EAAE;AACP,WAACxH,SAAD,GAAa;AAAEH,YAAAA,IAAI,EAAE;AAAR;AADN;AAHW,OAAtB;AAOA,aAAO;AAAEkE,QAAAA,QAAQ,EAAE2D,aAAZ;AAA2BJ,QAAAA;AAA3B,OAAP;AACD;;AACD,WAAO;AAAEvD,MAAAA,QAAQ,EAAE;AAAZ,KAAP;AACD;;AACDQ,EAAAA,OAAO,GAAG;AACR,UAAMA,OAAN;;AACA,SAAK,MAAMzJ,KAAX,IAAoB,KAAKqL,IAAL,CAAUsB,MAAV,EAApB,EAAwC;AACtC,UAAIV,UAAU,CAACjM,KAAD,CAAd,EAAuB;AACrBA,QAAAA,KAAK,CAACyJ,OAAN;AACD;AACF;AACF;;AACDZ,EAAAA,MAAM,CAACC,EAAD,EAAK+B,OAAL,EAAc;AAClB,QAAI/B,EAAE,CAAC/D,IAAH,KAAY;AAAE;AAAlB,MAAuC;AACrC,aAAO,KAAKkJ,YAAL,CAAkBnF,EAAlB,EAAsB+B,OAAtB,CAAP;AACD,KAFD,MAEO,IAAI/B,EAAE,CAAC/D,IAAH,KAAY;AAAE;AAAlB,MAA2C;AAChD,aAAO,KAAKmJ,qBAAL,CAA2BpF,EAA3B,CAAP;AACD;;AACD,WAAO,MAAMD,MAAN,CAAaC,EAAb,EAAiB+B,OAAjB,CAAP;AACD;;AACDJ,EAAAA,UAAU,GAAG;AACX,UAAMT,IAAI,GAAG,EAAb;;AACA,SAAK,MAAM,CAACjJ,GAAD,EAAMf,KAAN,CAAX,IAA2B,KAAKqL,IAAhC,EAAsC;AACpC,UAAI,CAACY,UAAU,CAACjM,KAAD,CAAf,EAAwB;AACtBgK,QAAAA,IAAI,CAACjJ,GAAD,CAAJ,GAAYf,KAAZ;AACD;AACF;;AACD,QAAI,KAAKqI,MAAL,CAAYtD,IAAZ,KAAqB,WAArB,IAAoC,KAAKsD,MAAL,CAAYT,IAAZ,CAAiBa,GAAzD,EAA8D;AAC5D,aAAO;AACL1D,QAAAA,IAAI,EAAE;AAAE;AADH;AAELE,QAAAA,QAAQ,EAAE,KAAKoD,MAAL,CAAYT,IAAZ,CAAiBa,GAFtB;AAGLvD,QAAAA,SAAS,EAAE,KAAKmD,MAAL,CAAYtH,GAHlB;AAILiJ,QAAAA;AAJK,OAAP;AAMD,KAPD,MAOO;AACL,aAAO;AACLjF,QAAAA,IAAI,EAAE;AAAE;AADH;AAELiF,QAAAA;AAFK,OAAP;AAID;AACF;;AACDiE,EAAAA,YAAY,CAACnF,EAAD,EAAK+B,OAAL,EAAc;AACxB,QAAIsD,UAAU,GAAG,KAAjB;AACA,UAAM7E,EAAE,GAAGhF,EAAE,CAAC,KAAKmE,GAAN,CAAb;AACA,UAAM+D,OAAO,GAAG,EAAhB;AACA,UAAM4B,aAAa,GAAG;AACpBrJ,MAAAA,IAAI,EAAE;AAAE;AADY;AAEpBuE,MAAAA,EAFoB;AAGpBU,MAAAA,IAAI,EAAE;AAHc,KAAtB;AAKAwC,IAAAA,OAAO,CAACjG,IAAR,CAAa6H,aAAb;;AACA,SAAK,MAAMrN,GAAX,IAAkB+H,EAAE,CAACkB,IAArB,EAA2B;AACzB,YAAM8C,QAAQ,GAAG,KAAKzB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAjB;;AACA,UAAIkL,UAAU,CAACa,QAAD,CAAd,EAA0B;AACxBN,QAAAA,OAAO,CAACjG,IAAR,CAAa,GAAGuG,QAAQ,CAACxC,MAAT,CAAgBhB,EAAhB,EAAoBvI,GAApB,CAAhB;;AACA+L,QAAAA,QAAQ,CAACrD,OAAT;AACD,OAHD,MAGO,IAAIqD,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAC9BsB,QAAAA,aAAa,CAACpE,IAAd,CAAmBjJ,GAAnB,IAA0B+L,QAA1B;AACD,OAFM,MAEA,IAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAC9BN,QAAAA,OAAO,CAACjG,IAAR,CAAa;AAAExB,UAAAA,IAAI,EAAE;AAAE;AAAV;AAAmCuE,UAAAA,EAAnC;AAAuCvI,UAAAA;AAAvC,SAAb;AACD;AACF;;AACD,UAAMsN,WAAW,GAAG,EAApB;;AACA,SAAK,MAAMtN,GAAX,IAAkB+H,EAAE,CAACkB,IAArB,EAA2B;AACzB,YAAMhK,KAAK,GAAG8I,EAAE,CAACkB,IAAH,CAAQjJ,GAAR,CAAd;;AACA,UAAIf,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpB;AACD;;AACD,UAAI6K,OAAJ,EAAa;AACX,aAAK8C,iBAAL,CAAuB5B,GAAvB,CAA2BhL,GAA3B,EAAgCuD,EAAE,CAACwE,EAAE,CAACyB,IAAJ,CAAlC;AACD,OAFD,MAEO,IAAI,KAAKoD,iBAAL,CAAuBhC,GAAvB,CAA2B5K,GAA3B,MAAoC,KAAK,CAA7C,EAAgD;AACrDoN,QAAAA,UAAU,GAAG,IAAb;AACD,OAFM,MAEA,IAAI,KAAKR,iBAAL,CAAuBhC,GAAvB,CAA2B5K,GAA3B,MAAoC+H,EAAE,CAACyB,IAA3C,EAAiD;AACtD,aAAKoD,iBAAL,CAAuBrB,MAAvB,CAA8BvL,GAA9B;;AACA;AACD,OAHM,MAGA;AACL;AACD;;AACD,YAAM+L,QAAQ,GAAG,KAAKzB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAjB;;AACA,UAAIkL,UAAU,CAACa,QAAD,CAAd,EAA0B;AACxBA,QAAAA,QAAQ,CAACrD,OAAT;AACD;;AACD0E,MAAAA,UAAU,GAAG,IAAb;AACAE,MAAAA,WAAW,CAACtN,GAAD,CAAX,GAAmB;AAAEgE,QAAAA,IAAI,EAAE;AAAR,OAAnB;;AACA,WAAKsG,IAAL,CAAUU,GAAV,CAAchL,GAAd,EAAmBf,KAAnB;;AACA,WAAK2J,UAAL;AACD;;AACD,QAAI9J,MAAM,CAAC0N,IAAP,CAAYa,aAAa,CAACpE,IAA1B,EAAgC3D,MAAhC,KAA2C,CAA/C,EAAkD;AAChDmG,MAAAA,OAAO,CAAC8B,OAAR,CAAgBF,aAAhB;AACD;;AACD,WAAOD,UAAU,GAAG;AAClBlF,MAAAA,QAAQ,EAAE;AACRrB,QAAAA,IAAI,EAAE,IADE;AAER7C,QAAAA,IAAI,EAAE,YAFE;AAGR2H,QAAAA,OAAO,EAAE2B;AAHD,OADQ;AAMlB7B,MAAAA;AANkB,KAAH,GAOb;AAAEvD,MAAAA,QAAQ,EAAE;AAAZ,KAPJ;AAQD;;AACDiF,EAAAA,qBAAqB,CAACpF,EAAD,EAAK;AACxB,UAAM/H,GAAG,GAAG+H,EAAE,CAAC/H,GAAf;;AACA,QAAI,KAAKsK,IAAL,CAAU/H,GAAV,CAAcvC,GAAd,MAAuB,KAA3B,EAAkC;AAChC,aAAO;AAAEkI,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD;;AACD,QAAI,KAAK0E,iBAAL,CAAuBhC,GAAvB,CAA2B5K,GAA3B,MAAoC,KAAK,CAA7C,EAAgD;AAC9C,aAAO;AAAEkI,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD;;AACD,UAAM6D,QAAQ,GAAG,KAAKzB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAjB;;AACA,UAAMuI,EAAE,GAAGhF,EAAE,CAAC,KAAKmE,GAAN,CAAb;AACA,QAAI+D,OAAO,GAAG,EAAd;;AACA,QAAIP,UAAU,CAACa,QAAD,CAAd,EAA0B;AACxBN,MAAAA,OAAO,GAAGM,QAAQ,CAACxC,MAAT,CAAgBhB,EAAhB,EAAoBR,EAAE,CAAC/H,GAAvB,CAAV;;AACA+L,MAAAA,QAAQ,CAACrD,OAAT;AACD,KAHD,MAGO,IAAIqD,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAC9BN,MAAAA,OAAO,GAAG,CACR;AACEzH,QAAAA,IAAI,EAAE;AAAE;AADV;AAEEuE,QAAAA,EAFF;AAGEU,QAAAA,IAAI,EAAE;AAAE,WAACjJ,GAAD,GAAO+L;AAAT;AAHR,OADQ,CAAV;AAOD;;AACD,SAAKzB,IAAL,CAAUiB,MAAV,CAAiBvL,GAAjB;;AACA,SAAK4I,UAAL;AACA,WAAO;AACLV,MAAAA,QAAQ,EAAE;AACRrB,QAAAA,IAAI,EAAE,IADE;AAER7C,QAAAA,IAAI,EAAE,YAFE;AAGR2H,QAAAA,OAAO,EAAE;AAAE,WAAC5D,EAAE,CAAC/H,GAAJ,GAAU;AAAEgE,YAAAA,IAAI,EAAE;AAAR;AAAZ;AAHD,OADL;AAMLyH,MAAAA;AANK,KAAP;AAQD;;AACD+B,EAAAA,QAAQ,GAAG;AACT,WAAOC,WAAW,CAAC,KAAKnD,IAAN,CAAlB;AACD;;AACDU,EAAAA,GAAG,CAAChL,GAAD,EAAMf,KAAN,EAAa;AACd,SAAKyO,MAAL,CAAY;AAAE,OAAC1N,GAAD,GAAOf;AAAT,KAAZ;AACD;;AACD2L,EAAAA,GAAG,CAAC5K,GAAD,EAAM;AACP,WAAO,KAAKsK,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAP;AACD;;AACDuL,EAAAA,MAAM,CAACvL,GAAD,EAAM;AACV,UAAM2N,WAAW,GAAG3N,GAApB;;AACA,UAAM+L,QAAQ,GAAG,KAAKzB,IAAL,CAAUM,GAAV,CAAc+C,WAAd,CAAjB;;AACA,QAAI5B,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvB;AACD;;AACD,QAAI,KAAKxE,KAAL,KAAe,KAAK,CAApB,IAAyB,KAAKG,GAAL,KAAa,KAAK,CAA/C,EAAkD;AAChD,UAAIwD,UAAU,CAACa,QAAD,CAAd,EAA0B;AACxBA,QAAAA,QAAQ,CAACrD,OAAT;AACD;;AACD,WAAK4B,IAAL,CAAUiB,MAAV,CAAiBoC,WAAjB;;AACA,WAAK/E,UAAL;AACA;AACD;;AACD,QAAI6C,OAAJ;;AACA,QAAIP,UAAU,CAACa,QAAD,CAAd,EAA0B;AACxBA,MAAAA,QAAQ,CAACrD,OAAT;;AACA+C,MAAAA,OAAO,GAAGM,QAAQ,CAACxC,MAAT,CAAgB,KAAK7B,GAArB,EAA0BiG,WAA1B,CAAV;AACD,KAHD,MAGO;AACLlC,MAAAA,OAAO,GAAG,CACR;AACEzH,QAAAA,IAAI,EAAE;AAAE;AADV;AAEEiF,QAAAA,IAAI,EAAE;AAAE,WAAC0E,WAAD,GAAe5B;AAAjB,SAFR;AAGExD,QAAAA,EAAE,EAAE,KAAKb;AAHX,OADQ,CAAV;AAOD;;AACD,SAAK4C,IAAL,CAAUiB,MAAV,CAAiBoC,WAAjB;;AACA,SAAK/E,UAAL;AACA,UAAMoD,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,EAAvC;AACA8B,IAAAA,cAAc,CAAChB,GAAf,CAAmB,KAAKtD,GAAxB,EAA6B;AAC3Bb,MAAAA,IAAI,EAAE,IADqB;AAE3B7C,MAAAA,IAAI,EAAE,YAFqB;AAG3B2H,MAAAA,OAAO,EAAE;AAAE,SAAC3L,GAAD,GAAO;AAAEgE,UAAAA,IAAI,EAAE;AAAR;AAAT;AAHkB,KAA7B;;AAKA,SAAKuD,KAAL,CAAW0E,QAAX,CACE,CACE;AACEjI,MAAAA,IAAI,EAAE;AAAE;AADV;AAEEhE,MAAAA,GAAG,EAAE2N,WAFP;AAGEpF,MAAAA,EAAE,EAAE,KAAKb,GAHX;AAIE8B,MAAAA,IAAI,EAAE,KAAKjC,KAAL,CAAWkC,YAAX;AAJR,KADF,CADF,EASEgC,OATF,EAUEO,cAVF;AAYD;;AACD0B,EAAAA,MAAM,CAACE,KAAD,EAAQ;AACZ,QAAI,KAAKrG,KAAL,KAAe,KAAK,CAApB,IAAyB,KAAKG,GAAL,KAAa,KAAK,CAA/C,EAAkD;AAChD,WAAK,MAAM1H,GAAX,IAAkB4N,KAAlB,EAAyB;AACvB,cAAMC,QAAQ,GAAGD,KAAK,CAAC5N,GAAD,CAAtB;;AACA,YAAI6N,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvB;AACD;;AACD,cAAM9B,QAAQ,GAAG,KAAKzB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAjB;;AACA,YAAIkL,UAAU,CAACa,QAAD,CAAd,EAA0B;AACxBA,UAAAA,QAAQ,CAACrD,OAAT;AACD;;AACD,YAAIwC,UAAU,CAAC2C,QAAD,CAAd,EAA0B;AACxBA,UAAAA,QAAQ,CAAC1F,cAAT,CAAwB,IAAxB,EAA8BnI,GAA9B;AACD;;AACD,aAAKsK,IAAL,CAAUU,GAAV,CAAchL,GAAd,EAAmB6N,QAAnB;;AACA,aAAKjF,UAAL;AACD;;AACD;AACD;;AACD,UAAM2B,GAAG,GAAG,EAAZ;AACA,UAAMuD,UAAU,GAAG,EAAnB;;AACA,UAAMtE,IAAI,GAAG,KAAKjC,KAAL,CAAWkC,YAAX,EAAb;;AACA,UAAMsE,YAAY,GAAG,EAArB;AACA,UAAMC,eAAe,GAAG;AACtBzF,MAAAA,EAAE,EAAE,KAAKb,GADa;AAEtB1D,MAAAA,IAAI,EAAE;AAAE;AAFc;AAGtBiF,MAAAA,IAAI,EAAE;AAHgB,KAAxB;AAKA,UAAMqE,WAAW,GAAG,EAApB;;AACA,SAAK,MAAMtN,GAAX,IAAkB4N,KAAlB,EAAyB;AACvB,YAAMC,QAAQ,GAAGD,KAAK,CAAC5N,GAAD,CAAtB;;AACA,UAAI6N,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvB;AACD;;AACD,YAAM9B,QAAQ,GAAG,KAAKzB,IAAL,CAAUM,GAAV,CAAc5K,GAAd,CAAjB;;AACA,UAAIkL,UAAU,CAACa,QAAD,CAAd,EAA0B;AACxB+B,QAAAA,UAAU,CAACtI,IAAX,CAAgB,GAAGuG,QAAQ,CAACxC,MAAT,CAAgB,KAAK7B,GAArB,EAA0B1H,GAA1B,CAAnB;;AACA+L,QAAAA,QAAQ,CAACrD,OAAT;AACD,OAHD,MAGO,IAAIqD,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAC9B+B,QAAAA,UAAU,CAACtI,IAAX,CAAgB;AAAExB,UAAAA,IAAI,EAAE;AAAE;AAAV;AAAmCuE,UAAAA,EAAE,EAAE,KAAKb,GAA5C;AAAiD1H,UAAAA;AAAjD,SAAhB;AACD,OAFM,MAEA;AACLgO,QAAAA,eAAe,CAAC/E,IAAhB,CAAqBjJ,GAArB,IAA4B+L,QAA5B;AACD;;AACD,UAAIb,UAAU,CAAC2C,QAAD,CAAd,EAA0B;AACxBA,QAAAA,QAAQ,CAAC1F,cAAT,CAAwB,IAAxB,EAA8BnI,GAA9B;;AACA6N,QAAAA,QAAQ,CAACvF,OAAT,CAAiB,KAAKf,KAAL,CAAW4D,UAAX,EAAjB,EAA0C,KAAK5D,KAA/C;;AACA,cAAM0G,iBAAiB,GAAGJ,QAAQ,CAACtE,MAAT,CAAgB,KAAK7B,GAArB,EAA0B1H,GAA1B,EAA+B,KAAKuH,KAApC,CAA1B;;AACA,cAAM2G,YAAY,GAAGD,iBAAiB,CAACE,IAAlB,CAClBpG,EAAD,IAAQA,EAAE,CAAC7D,QAAH,KAAgB,KAAKwD,GADV,CAArB;;AAGA,YAAIwG,YAAJ,EAAkB;AAChB,eAAKtB,iBAAL,CAAuB5B,GAAvB,CAA2BhL,GAA3B,EAAgCuD,EAAE,CAAC2K,YAAY,CAAC1E,IAAd,CAAlC;AACD;;AACDe,QAAAA,GAAG,CAAC/E,IAAJ,CAAS,GAAGyI,iBAAZ;AACD,OAXD,MAWO;AACLF,QAAAA,YAAY,CAAC/N,GAAD,CAAZ,GAAoB6N,QAApB;;AACA,aAAKjB,iBAAL,CAAuB5B,GAAvB,CAA2BhL,GAA3B,EAAgCwJ,IAAhC;AACD;;AACD,WAAKc,IAAL,CAAUU,GAAV,CAAchL,GAAd,EAAmB6N,QAAnB;;AACA,WAAKjF,UAAL;AACA0E,MAAAA,WAAW,CAACtN,GAAD,CAAX,GAAmB;AAAEgE,QAAAA,IAAI,EAAE;AAAR,OAAnB;AACD;;AACD,QAAIlF,MAAM,CAAC0N,IAAP,CAAYwB,eAAe,CAAC/E,IAA5B,EAAkC3D,MAAlC,KAA6C,CAAjD,EAAoD;AAClDwI,MAAAA,UAAU,CAACP,OAAX,CAAmBS,eAAnB;AACD;;AACD,QAAIlP,MAAM,CAAC0N,IAAP,CAAYuB,YAAZ,EAA0BzI,MAA1B,KAAqC,CAAzC,EAA4C;AAC1CiF,MAAAA,GAAG,CAACgD,OAAJ,CAAY;AACV/D,QAAAA,IADU;AAEVjB,QAAAA,EAAE,EAAE,KAAKb,GAFC;AAGV1D,QAAAA,IAAI,EAAE;AAAE;AAHE;AAIViF,QAAAA,IAAI,EAAE8E;AAJI,OAAZ;AAMD;;AACD,UAAM/B,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,EAAvC;AACA8B,IAAAA,cAAc,CAAChB,GAAf,CAAmB,KAAKtD,GAAxB,EAA6B;AAC3Bb,MAAAA,IAAI,EAAE,IADqB;AAE3B7C,MAAAA,IAAI,EAAE,YAFqB;AAG3B2H,MAAAA,OAAO,EAAE2B;AAHkB,KAA7B;;AAKA,SAAK/F,KAAL,CAAW0E,QAAX,CAAoB1B,GAApB,EAAyBuD,UAAzB,EAAqC9B,cAArC;AACD;;AACDlD,EAAAA,WAAW,GAAG;AACZ,WAAO,MAAMA,WAAN,EAAP;AACD;;AACDC,EAAAA,YAAY,GAAG;AACb,UAAM5D,MAAM,GAAG,EAAf;;AACA,SAAK,MAAM,CAACnF,GAAD,EAAMoO,GAAN,CAAX,IAAyB,KAAK9D,IAA9B,EAAoC;AAClCnF,MAAAA,MAAM,CAACnF,GAAD,CAAN,GAAcgN,eAAe,CAACoB,GAAD,CAAf,GAAuBA,GAAG,CAACtF,WAAJ,EAAvB,GAA2CsF,GAAzD;AACD;;AACD,WAAOhM,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC6C,MAAxC,GAAiDrG,MAAM,CAACgI,MAAP,CAAc3B,MAAd,CAAxD;AACD;;AAlayC,CAA5C,C,CAqaA;;AACA,IAAI2B,MAAM,GAAG1E,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAyCV,CAAD,IAAOA,CAA/C,GAAmD9C,MAAM,CAACgI,MAAvE;;AACA,SAASuH,OAAT,CAAiBC,KAAjB,EAAwB;AACtB,SAAOA,KAAK,CAACC,MAAN,CACJlF,IAAD,IAAUA,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CADpC,CAAP;AAGD;;AACD,SAASmF,aAAT,CAAuBzO,GAAvB,EAA4B;AAC1B,QAAM0O,MAAM,GAAGrO,cAAc,CAAC,EAAD,EAAKL,GAAL,CAA7B;;AACAjB,EAAAA,MAAM,CAAC0N,IAAP,CAAYzM,GAAZ,EAAiB0M,OAAjB,CAA0BiC,CAAD,IAAO;AAC9B,UAAM1O,GAAG,GAAG0O,CAAZ;;AACA,QAAID,MAAM,CAACzO,GAAD,CAAN,KAAgB,KAAK,CAAzB,EAA4B;AAC1B,aAAOyO,MAAM,CAACzO,GAAD,CAAb;AACD;AACF,GALD;AAMA,SAAOyO,MAAP;AACD;;AACD,SAASrD,oBAAT,CAA8BrD,EAA9B,EAAkC;AAChC,SAAOsC,cAAc,CAAC4C,gBAAgB,CAAClF,EAAD,CAAjB,CAArB;AACD;;AACD,SAASkF,gBAAT,CAA0BlF,EAA1B,EAA8B;AAC5B,UAAQA,EAAE,CAAC/D,IAAX;AACE,SAAK;AAAE;AAAP;AACE,aAAO+D,EAAE,CAACkB,IAAV;;AACF,SAAK;AAAE;AAAP;AACE,aAAO,IAAI0D,UAAJ,CAAe5E,EAAE,CAACkB,IAAlB,CAAP;;AACF,SAAK;AAAE;AAAP;AACE,aAAO,IAAIc,OAAJ,EAAP;;AACF,SAAK;AAAE;AAAP;AACE,aAAO,IAAI4E,QAAJ,EAAP;;AACF;AACE,aAAOzL,WAAW,CAAC6E,EAAD,EAAK,qBAAL,CAAlB;AAVJ;AAYD;;AACD,SAAS6G,mBAAT,CAA6B/H,IAA7B,EAAmCS,MAAnC,EAA2C;AACzC,MAAIT,IAAI,KAAKS,MAAb,EAAqB;AACnB,WAAO,IAAP;AACD;;AACD,MAAIT,IAAI,CAACS,MAAL,CAAYtD,IAAZ,KAAqB,WAAzB,EAAsC;AACpC,WAAO4K,mBAAmB,CAAC/H,IAAI,CAACS,MAAL,CAAYT,IAAb,EAAmBS,MAAnB,CAA1B;AACD;;AACD,SAAO,KAAP;AACD;;AACD,SAASyD,WAAT,QAAiCP,gBAAjC,EAAmDhC,IAAnD,EAAyD;AAAA,MAApC,CAACD,EAAD,EAAKxE,IAAL,CAAoC;;AACvD,UAAQA,IAAI,CAACC,IAAb;AACE,SAAK;AAAE;AAAP;AAAqB;AACnB,eAAO2I,UAAU,CAACxD,YAAX,CAAwB,CAACZ,EAAD,EAAKxE,IAAL,CAAxB,EAAoCyG,gBAApC,EAAsDhC,IAAtD,CAAP;AACD;;AACD,SAAK;AAAE;AAAP;AAAmB;AACjB,eAAOmG,QAAQ,CAACxF,YAAT,CAAsB,CAACZ,EAAD,EAAKxE,IAAL,CAAtB,EAAkCyG,gBAAlC,EAAoDhC,IAApD,CAAP;AACD;;AACD,SAAK;AAAE;AAAP;AAAkB;AAChB,eAAOuB,OAAO,CAACZ,YAAR,CAAqB,CAACZ,EAAD,EAAKxE,IAAL,CAArB,EAAiCyG,gBAAjC,EAAmDhC,IAAnD,CAAP;AACD;;AACD,SAAK;AAAE;AAAP;AAAuB;AACrB,eAAOQ,YAAY,CAACG,YAAb,CAA0B,CAACZ,EAAD,EAAKxE,IAAL,CAA1B,EAAsCyG,gBAAtC,EAAwDhC,IAAxD,CAAP;AACD;;AACD;AAAS;AACP,cAAM,IAAIzF,KAAJ,CAAU,sBAAV,CAAN;AACD;AAfH;AAiBD;;AACD,SAASgK,iBAAT,QAAuCvC,gBAAvC,EAAyDhC,IAAzD,EAA+D;AAAA,MAApC,CAACD,EAAD,EAAKxE,IAAL,CAAoC;;AAC7D,UAAQA,IAAI,CAACC,IAAb;AACE,SAAK;AAAE;AAAP;AAAqB;AACnB,eAAO2I,UAAU,CAACxD,YAAX,CAAwB,CAACZ,EAAD,EAAKxE,IAAL,CAAxB,EAAoCyG,gBAApC,EAAsDhC,IAAtD,CAAP;AACD;;AACD,SAAK;AAAE;AAAP;AAAmB;AACjB,eAAOmG,QAAQ,CAACxF,YAAT,CAAsB,CAACZ,EAAD,EAAKxE,IAAL,CAAtB,EAAkCyG,gBAAlC,EAAoDhC,IAApD,CAAP;AACD;;AACD,SAAK;AAAE;AAAP;AAAkB;AAChB,eAAOuB,OAAO,CAACZ,YAAR,CAAqB,CAACZ,EAAD,EAAKxE,IAAL,CAArB,EAAiCyG,gBAAjC,EAAmDhC,IAAnD,CAAP;AACD;;AACD,SAAK;AAAE;AAAP;AAAuB;AACrB,eAAOzE,IAAI,CAACkF,IAAZ;AACD;;AACD;AAAS;AACP,cAAM,IAAIlG,KAAJ,CAAU,sBAAV,CAAN;AACD;AAfH;AAiBD;;AACD,SAASiK,eAAT,CAAyB/N,KAAzB,EAAgC;AAC9B,SAAO4P,UAAU,CAAC5P,KAAD,CAAV,IAAqB6P,SAAS,CAAC7P,KAAD,CAA9B,IAAyC8P,YAAY,CAAC9P,KAAD,CAA5D;AACD;;AACD,SAASiM,UAAT,CAAoBjM,KAApB,EAA2B;AACzB,SAAO+N,eAAe,CAAC/N,KAAD,CAAf,IAA0B+P,cAAc,CAAC/P,KAAD,CAA/C;AACD;;AACD,SAAS4P,UAAT,CAAoB5P,KAApB,EAA2B;AACzB,SAAOA,KAAK,YAAY0P,QAAxB;AACD;;AACD,SAASG,SAAT,CAAmB7P,KAAnB,EAA0B;AACxB,SAAOA,KAAK,YAAY8K,OAAxB;AACD;;AACD,SAASgF,YAAT,CAAsB9P,KAAtB,EAA6B;AAC3B,SAAOA,KAAK,YAAY0N,UAAxB;AACD;;AACD,SAASqC,cAAT,CAAwB/P,KAAxB,EAA+B;AAC7B,SAAOA,KAAK,YAAY+J,YAAxB;AACD;;AACD,SAAS8C,cAAT,CAAwB/L,GAAxB,EAA6B;AAC3B,MAAIA,GAAG,YAAYiJ,YAAnB,EAAiC;AAC/B,WAAOjJ,GAAG,CAACkJ,IAAX;AACD,GAFD,MAEO,IAAIlJ,GAAG,YAAY4O,QAAf,IAA2B5O,GAAG,YAAYgK,OAA1C,IAAqDhK,GAAG,YAAY4M,UAAxE,EAAoF;AACzF,WAAO5M,GAAP;AACD,GAFM,MAEA;AACL,WAAOmD,WAAW,CAACnD,GAAD,EAAM,sBAAN,CAAlB;AACD;AACF;;AACD,SAASsK,cAAT,CAAwBpL,KAAxB,EAA+B;AAC7B,MAAIA,KAAK,YAAY0N,UAAjB,IAA+B1N,KAAK,YAAY8K,OAAhD,IAA2D9K,KAAK,YAAY0P,QAAhF,EAA0F;AACxF,WAAO1P,KAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAI+J,YAAJ,CAAiB/J,KAAjB,CAAP;AACD;AACF;;AACD,SAASgQ,sBAAT,CAAgCC,YAAhC,EAA8CC,QAA9C,EAAwD;AACtD,QAAM5E,GAAG,GAAG,EAAZ;AACA2E,EAAAA,YAAY,CAACzC,OAAb,CAAqB,CAAC2C,CAAD,EAAI7G,EAAJ,KAAW;AAC9B,QAAI,CAAC4G,QAAQ,CAACvE,GAAT,CAAarC,EAAb,CAAL,EAAuB;AACrBgC,MAAAA,GAAG,CAAC/E,IAAJ,CAAS;AACPxB,QAAAA,IAAI,EAAE;AAAE;AADD;AAEPuE,QAAAA;AAFO,OAAT;AAID;AACF,GAPD;AAQA4G,EAAAA,QAAQ,CAAC1C,OAAT,CAAiB,CAAC1I,IAAD,EAAOwE,EAAP,KAAc;AAC7B,UAAM8G,WAAW,GAAGH,YAAY,CAACtE,GAAb,CAAiBrC,EAAjB,CAApB;;AACA,QAAI8G,WAAJ,EAAiB;AACf,UAAItL,IAAI,CAACC,IAAL,KAAc;AAAE;AAApB,QAAkC;AAChC,YAAIqL,WAAW,CAACrL,IAAZ,KAAqB;AAAE;AAAvB,WAAuCsL,IAAI,CAACC,SAAL,CAAexL,IAAI,CAACkF,IAApB,MAA8BqG,IAAI,CAACC,SAAL,CAAeF,WAAW,CAACpG,IAA3B,CAAzE,EAA2G;AACzGsB,UAAAA,GAAG,CAAC/E,IAAJ,CAAS;AACPxB,YAAAA,IAAI,EAAE;AAAE;AADD;AAEPuE,YAAAA,EAFO;AAGPU,YAAAA,IAAI,EAAElF,IAAI,CAACkF;AAHJ,WAAT;AAKD;AACF;;AACD,UAAIlF,IAAI,CAACI,SAAL,KAAmBkL,WAAW,CAAClL,SAAnC,EAA8C;AAC5CoG,QAAAA,GAAG,CAAC/E,IAAJ,CAAS;AACPxB,UAAAA,IAAI,EAAE;AAAE;AADD;AAEPuE,UAAAA,EAFO;AAGPpE,UAAAA,SAAS,EAAEZ,EAAE,CAACQ,IAAI,CAACI,SAAN,EAAiB,gCAAjB;AAHN,SAAT;AAKD;AACF,KAjBD,MAiBO;AACL,cAAQJ,IAAI,CAACC,IAAb;AACE,aAAK;AAAE;AAAP;AACEuG,UAAAA,GAAG,CAAC/E,IAAJ,CAAS;AACPxB,YAAAA,IAAI,EAAE;AAAE;AADD;AAEPuE,YAAAA,EAFO;AAGPrE,YAAAA,QAAQ,EAAEH,IAAI,CAACG,QAHR;AAIPC,YAAAA,SAAS,EAAEJ,IAAI,CAACI,SAJT;AAKP8E,YAAAA,IAAI,EAAElF,IAAI,CAACkF;AALJ,WAAT;AAOA;;AACF,aAAK;AAAE;AAAP;AACEsB,UAAAA,GAAG,CAAC/E,IAAJ,CAAS;AACPxB,YAAAA,IAAI,EAAE;AAAE;AADD;AAEPuE,YAAAA,EAFO;AAGPrE,YAAAA,QAAQ,EAAEH,IAAI,CAACG,QAHR;AAIPC,YAAAA,SAAS,EAAEJ,IAAI,CAACI;AAJT,WAAT;AAMA;;AACF,aAAK;AAAE;AAAP;AACEoG,UAAAA,GAAG,CAAC/E,IAAJ,CACEzB,IAAI,CAACG,QAAL,GAAgB;AACdF,YAAAA,IAAI,EAAE;AAAE;AADM;AAEduE,YAAAA,EAFc;AAGdrE,YAAAA,QAAQ,EAAEH,IAAI,CAACG,QAHD;AAIdC,YAAAA,SAAS,EAAEJ,IAAI,CAACI,SAJF;AAKd8E,YAAAA,IAAI,EAAElF,IAAI,CAACkF;AALG,WAAhB,GAMI;AAAEjF,YAAAA,IAAI,EAAE;AAAE;AAAV;AAA+BuE,YAAAA,EAA/B;AAAmCU,YAAAA,IAAI,EAAElF,IAAI,CAACkF;AAA9C,WAPN;AASA;;AACF,aAAK;AAAE;AAAP;AACEsB,UAAAA,GAAG,CAAC/E,IAAJ,CAAS;AACPxB,YAAAA,IAAI,EAAE;AAAE;AADD;AAEPuE,YAAAA,EAFO;AAGPrE,YAAAA,QAAQ,EAAEH,IAAI,CAACG,QAHR;AAIPC,YAAAA,SAAS,EAAEJ,IAAI,CAACI;AAJT,WAAT;AAMA;AApCJ;AAsCD;AACF,GA3DD;AA4DA,SAAOoG,GAAP;AACD;;AACD,SAASiF,yBAAT,CAAmCC,KAAnC,EAA0CC,MAA1C,EAAkD;AAChD,QAAM/D,OAAO,GAAG8D,KAAK,CAAC9D,OAAtB;;AACA,OAAK,MAAM,CAAC3L,GAAD,EAAMf,KAAN,CAAX,IAA2BkN,OAAO,CAACuD,MAAM,CAAC/D,OAAR,CAAlC,EAAoD;AAClDA,IAAAA,OAAO,CAAC3L,GAAD,CAAP,GAAef,KAAf;AACD;;AACD,SAAOwB,aAAa,CAACL,cAAc,CAAC,EAAD,EAAKsP,MAAL,CAAf,EAA6B;AAC/C/D,IAAAA;AAD+C,GAA7B,CAApB;AAGD;;AACD,SAASgE,sBAAT,CAAgCF,KAAhC,EAAuCC,MAAvC,EAA+C;AAC7C,QAAM/D,OAAO,GAAG8D,KAAK,CAAC9D,OAAtB;;AACA,OAAK,MAAM,CAAC3L,GAAD,EAAMf,KAAN,CAAX,IAA2BkN,OAAO,CAACuD,MAAM,CAAC/D,OAAR,CAAlC,EAAoD;AAClDA,IAAAA,OAAO,CAAC3L,GAAD,CAAP,GAAef,KAAf;AACD;;AACD,SAAOwB,aAAa,CAACL,cAAc,CAAC,EAAD,EAAKsP,MAAL,CAAf,EAA6B;AAC/C/D,IAAAA;AAD+C,GAA7B,CAApB;AAGD;;AACD,SAASiE,uBAAT,CAAiCH,KAAjC,EAAwCC,MAAxC,EAAgD;AAC9C,QAAM/D,OAAO,GAAG8D,KAAK,CAAC9D,OAAtB;AACA,SAAOlL,aAAa,CAACL,cAAc,CAAC,EAAD,EAAKsP,MAAL,CAAf,EAA6B;AAC/C/D,IAAAA,OAAO,EAAEA,OAAO,CAACkE,MAAR,CAAeH,MAAM,CAAC/D,OAAtB;AADsC,GAA7B,CAApB;AAGD;;AACD,SAASmE,mBAAT,CAA6BL,KAA7B,EAAoCC,MAApC,EAA4C;AAC1C,MAAI,CAACD,KAAL,EAAY;AACV,WAAOC,MAAP;AACD;;AACD,MAAID,KAAK,CAACzL,IAAN,KAAe,YAAf,IAA+B0L,MAAM,CAAC1L,IAAP,KAAgB,YAAnD,EAAiE;AAC/D,WAAOwL,yBAAyB,CAACC,KAAD,EAAQC,MAAR,CAAhC;AACD,GAFD,MAEO,IAAID,KAAK,CAACzL,IAAN,KAAe,SAAf,IAA4B0L,MAAM,CAAC1L,IAAP,KAAgB,SAAhD,EAA2D;AAChE,WAAO2L,sBAAsB,CAACF,KAAD,EAAQC,MAAR,CAA7B;AACD,GAFM,MAEA,IAAID,KAAK,CAACzL,IAAN,KAAe,UAAf,IAA6B0L,MAAM,CAAC1L,IAAP,KAAgB,UAAjD,EAA6D;AAClE,WAAO4L,uBAAuB,CAACH,KAAD,EAAQC,MAAR,CAA9B;AACD,GAFM,MAEA,CACN;;AACD,SAAOA,MAAP;AACD;;AACD,SAASK,OAAT,CAAiB9Q,KAAjB,EAAwB;AACtB,QAAM+E,IAAI,GAAG,OAAO/E,KAApB;AACA,SAAOA,KAAK,KAAK,KAAK,CAAf,IAAoBA,KAAK,KAAK,IAA9B,IAAsC+E,IAAI,KAAK,QAA/C,IAA2DA,IAAI,KAAK,SAApE,IAAiFA,IAAI,KAAK,QAA1F,IAAsGgM,KAAK,CAACC,OAAN,CAAchR,KAAd,CAAtG,IAA8HiR,aAAa,CAACjR,KAAD,CAAlJ;AACD;;AACD,SAASiR,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,SAAOA,IAAI,KAAK,IAAT,IAAiB,OAAOA,IAAP,KAAgB,QAAjC,IAA6CrR,MAAM,CAACY,SAAP,CAAiB0Q,QAAjB,CAA0B5P,IAA1B,CAA+B2P,IAA/B,MAAyC,iBAA7F;AACD;;AACD,SAASE,wBAAT,CAAkCpR,KAAlC,EAAoD;AAAA,MAAXqR,IAAW,uEAAJ,EAAI;;AAClD,MAAI,CAACP,OAAL,EAAc;AACZ,WAAO;AACLO,MAAAA,IAAI,EAAEA,IAAI,IAAI,MADT;AAELrR,MAAAA;AAFK,KAAP;AAID;;AACD,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;AAC/C,WAAO,KAAP;AACD;;AACD,OAAK,MAAM,CAACe,GAAD,EAAMuQ,WAAN,CAAX,IAAiCzR,MAAM,CAACqN,OAAP,CAAelN,KAAf,CAAjC,EAAwD;AACtD,UAAMuR,UAAU,GAAGF,IAAI,GAAGA,IAAI,GAAG,GAAP,GAAatQ,GAAhB,GAAsBA,GAA7C;;AACA,QAAI,CAAC+P,OAAO,CAACQ,WAAD,CAAZ,EAA2B;AACzB,aAAO;AACLD,QAAAA,IAAI,EAAEE,UADD;AAELvR,QAAAA,KAAK,EAAEsR;AAFF,OAAP;AAID;;AACD,QAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;AACnC,YAAME,0BAA0B,GAAGJ,wBAAwB,CACzDE,WADyD,EAEzDC,UAFyD,CAA3D;;AAIA,UAAIC,0BAAJ,EAAgC;AAC9B,eAAOA,0BAAP;AACD;AACF;AACF;;AACD,SAAO,KAAP;AACD;;AACD,SAAShD,WAAT,CAAqBiD,QAArB,EAA+B;AAC7B,QAAM3Q,GAAG,GAAG,EAAZ;;AACA,OAAK,MAAM,CAACC,GAAD,EAAMoO,GAAN,CAAX,IAAyBsC,QAAzB,EAAmC;AACjC3Q,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWoO,GAAX;AACD;;AACD,SAAOrO,GAAP;AACD;;AACD,SAASoM,OAAT,CAAiBpM,GAAjB,EAAsB;AACpB,SAAOjB,MAAM,CAACqN,OAAP,CAAepM,GAAf,CAAP;AACD;;AACD,SAAS4Q,YAAT,CAAsBC,UAAtB,EAAkC;AAChC,MAAI;AACF,WAAOtB,IAAI,CAACuB,KAAL,CAAWD,UAAX,CAAP;AACD,GAFD,CAEE,OAAOnP,CAAP,EAAU;AACV,WAAO,KAAK,CAAZ;AACD;AACF;;AACD,SAASqP,SAAT,CAAmBC,QAAnB,EAA6B;AAC3B,MAAI;AACF,UAAMC,cAAc,GAAGD,QAAQ,CAACE,OAAT,CAAiB,IAAjB,EAAuB,GAAvB,EAA4BA,OAA5B,CAAoC,IAApC,EAA0C,GAA1C,CAAvB;AACA,UAAMC,YAAY,GAAGC,kBAAkB,CACrCC,IAAI,CAACJ,cAAD,CAAJ,CAAqBK,KAArB,CAA2B,EAA3B,EAA+B3G,GAA/B,CAAmC,UAAS4G,CAAT,EAAY;AAC7C,aAAO,MAAM,CAAC,OAAOA,CAAC,CAACrL,UAAF,CAAa,CAAb,EAAgBmK,QAAhB,CAAyB,EAAzB,CAAR,EAAsCvK,KAAtC,CAA4C,CAAC,CAA7C,CAAb;AACD,KAFD,EAEG0L,IAFH,CAEQ,EAFR,CADqC,CAAvC;AAKA,WAAOL,YAAP;AACD,GARD,CAQE,OAAO5N,GAAP,EAAY;AACZ,WAAO8N,IAAI,CAACL,QAAD,CAAX;AACD;AACF,C,CAED;;;AACA,SAASS,mBAAT,CAA6BC,KAA7B,EAAoCC,KAApC,EAA2C;AACzC,SAAOtL,eAAe,CACpBqL,KAAK,CAACpK,oBAAN,EADoB,EAEpBqK,KAAK,CAACrK,oBAAN,EAFoB,CAAtB;AAID;;AACD,IAAIsH,QAAQ,GAAG,cAAczH,YAAd,CAA2B;AACxCC,EAAAA,WAAW,GAAa;AAAA,QAAZmH,KAAY,uEAAJ,EAAI;AACtB;AACA,SAAKqD,MAAL,GAAc,EAAd;AACA,SAAKC,uBAAL,GAA+B,eAAgB,IAAIC,OAAJ,EAA/C;AACA,SAAKC,mBAAL,GAA2B,eAAgB,IAAI5H,GAAJ,EAA3C;AACA,QAAI6H,QAAQ,GAAG,KAAK,CAApB;;AACA,SAAK,IAAI1M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiJ,KAAK,CAAChJ,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,YAAM2M,WAAW,GAAGrN,YAAY,CAACoN,QAAD,CAAhC;AACA,YAAM1I,IAAI,GAAGgB,cAAc,CAACiE,KAAK,CAACjJ,CAAD,CAAN,CAA3B;;AACAgE,MAAAA,IAAI,CAAClB,cAAL,CAAoB,IAApB,EAA0B6J,WAA1B;;AACA,WAAKL,MAAL,CAAYnM,IAAZ,CAAiB6D,IAAjB;;AACA0I,MAAAA,QAAQ,GAAGC,WAAX;AACD;AACF;;AACkB,SAAZ7I,YAAY,QAAOqB,gBAAP,EAAyBhC,IAAzB,EAA+B;AAAA,QAA9B,CAACD,EAAD,CAA8B;AAChD,UAAM0J,IAAI,GAAG,IAAItD,QAAJ,EAAb;;AACAsD,IAAAA,IAAI,CAAC3J,OAAL,CAAaC,EAAb,EAAiBC,IAAjB;;AACA,UAAMmC,QAAQ,GAAGH,gBAAgB,CAACI,GAAjB,CAAqBrC,EAArB,CAAjB;;AACA,QAAIoC,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AACvB,aAAOsH,IAAP;AACD;;AACD,SAAK,MAAM,CAACpH,GAAD,EAAM9G,IAAN,CAAX,IAA0B4G,QAA1B,EAAoC;AAClC,YAAMG,KAAK,GAAGC,WAAW,CAAC,CAACF,GAAD,EAAM9G,IAAN,CAAD,EAAcyG,gBAAd,EAAgChC,IAAhC,CAAzB;;AACAsC,MAAAA,KAAK,CAAC3C,cAAN,CAAqB8J,IAArB,EAA2BlO,IAAI,CAACI,SAAhC;;AACA8N,MAAAA,IAAI,CAACC,cAAL,CAAoBpH,KAApB;AACD;;AACD,WAAOmH,IAAP;AACD;;AACD1I,EAAAA,MAAM,CAACrF,QAAD,EAAWC,SAAX,EAAsBqE,IAAtB,EAA4B;AAChC,QAAI,KAAKd,GAAL,KAAa,KAAK,CAAtB,EAAyB;AACvB,YAAM,IAAI3E,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,UAAMwH,GAAG,GAAG,EAAZ;AACA,UAAMxC,EAAE,GAAG;AACTQ,MAAAA,EAAE,EAAE,KAAKb,GADA;AAET8B,MAAAA,IAAI,EAAEhB,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACiB,YAAL,EAFrB;AAGTzF,MAAAA,IAAI,EAAE;AAAE;AAHC;AAITE,MAAAA,QAJS;AAKTC,MAAAA;AALS,KAAX;AAOAoG,IAAAA,GAAG,CAAC/E,IAAJ,CAASuC,EAAT;;AACA,SAAK,MAAMsB,IAAX,IAAmB,KAAKsI,MAAxB,EAAgC;AAC9BpH,MAAAA,GAAG,CAAC/E,IAAJ,CAAS,GAAG6D,IAAI,CAACE,MAAL,CAAY,KAAK7B,GAAjB,EAAsB2B,IAAI,CAAChC,oBAAL,EAAtB,EAAmDmB,IAAnD,CAAZ;AACD;;AACD,WAAO+B,GAAP;AACD;;AACD2H,EAAAA,cAAc,CAAC7I,IAAD,EAAO;AACnB,SAAKsI,MAAL,CAAYnM,IAAZ,CAAiB6D,IAAjB;;AACA,SAAK8I,UAAL;AACD;;AACDA,EAAAA,UAAU,GAAG;AACX,SAAKR,MAAL,CAAYS,IAAZ,CAAiBZ,mBAAjB;;AACA,SAAK5I,UAAL;AACD;;AACDyJ,EAAAA,gBAAgB,CAACN,QAAD,EAAW;AACzB,WAAO,KAAKJ,MAAL,CAAYW,SAAZ,CACJjJ,IAAD,IAAUA,IAAI,CAAChC,oBAAL,OAAgC0K,QADrC,CAAP;AAGD;;AACDzJ,EAAAA,OAAO,CAACC,EAAD,EAAKC,IAAL,EAAW;AAChB,UAAMF,OAAN,CAAcC,EAAd,EAAkBC,IAAlB;;AACA,SAAK,MAAMa,IAAX,IAAmB,KAAKsI,MAAxB,EAAgC;AAC9BtI,MAAAA,IAAI,CAACf,OAAL,CAAaE,IAAI,CAAC2C,UAAL,EAAb,EAAgC3C,IAAhC;AACD;AACF;;AACDE,EAAAA,OAAO,GAAG;AACR,UAAMA,OAAN;;AACA,SAAK,MAAMW,IAAX,IAAmB,KAAKsI,MAAxB,EAAgC;AAC9BtI,MAAAA,IAAI,CAACX,OAAL;AACD;AACF;;AACD6J,EAAAA,eAAe,CAACxK,EAAD,EAAK;AAClB,QAAI,KAAKR,KAAL,KAAe,KAAK,CAAxB,EAA2B;AACzB,YAAM,IAAIxE,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,UAAM;AAAEwF,MAAAA,EAAF;AAAMpE,MAAAA,SAAS,EAAEnE;AAAjB,QAAyB+H,EAA/B;AACA,UAAM+C,KAAK,GAAGM,oBAAoB,CAACrD,EAAD,CAAlC;;AACA+C,IAAAA,KAAK,CAACxC,OAAN,CAAcC,EAAd,EAAkB,KAAKhB,KAAvB;;AACAuD,IAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BnI,GAA3B;;AACA,UAAMwS,SAAS,GAAGzK,EAAE,CAACyK,SAArB;;AACA,UAAMC,2BAA2B,GAAG,KAAKJ,gBAAL,CAAsBrS,GAAtB,CAApC;;AACA,QAAIyS,2BAA2B,KAAK,CAAC,CAArC,EAAwC;AACtC,YAAMC,oBAAoB,GAAG,KAAKf,MAAL,CAAYc,2BAAZ,CAA7B;;AACA,UAAIC,oBAAoB,CAAChL,GAArB,KAA6B8K,SAAjC,EAA4C;AAC1CE,QAAAA,oBAAoB,CAAChK,OAArB;;AACA,aAAKiJ,MAAL,CAAYc,2BAAZ,IAA2C3H,KAA3C;AACA,eAAO;AACL5C,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CACzBC,QAAQ,CAACH,2BAAD,EAA8B3H,KAA9B,CADiB,CAAP,CADf;AAILW,UAAAA,OAAO,EAAE;AAJJ,SAAP;AAMD,OATD,MASO;AACL,aAAKmG,uBAAL,CAA6BpP,GAA7B,CAAiCkQ,oBAAjC;;AACA,aAAKf,MAAL,CAAYc,2BAAZ,IAA2C3H,KAA3C;AACA,cAAM+H,KAAK,GAAG,CACZD,QAAQ,CAACH,2BAAD,EAA8B3H,KAA9B,CADI,CAAd;;AAGA,cAAMgI,YAAY,GAAG,KAAKC,mCAAL,CACnBhL,EAAE,CAACyK,SADgB,CAArB;;AAGA,YAAIM,YAAJ,EAAkB;AAChBD,UAAAA,KAAK,CAACrN,IAAN,CAAWsN,YAAX;AACD;;AACD,eAAO;AACL5K,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAOE,KAAP,CADf;AAELpH,UAAAA,OAAO,EAAE;AAFJ,SAAP;AAID;AACF,KA5BD,MA4BO;AACL,YAAME,OAAO,GAAG,EAAhB;;AACA,YAAMmH,YAAY,GAAG,KAAKC,mCAAL,CACnBhL,EAAE,CAACyK,SADgB,CAArB;;AAGA,UAAIM,YAAJ,EAAkB;AAChBnH,QAAAA,OAAO,CAACnG,IAAR,CAAasN,YAAb;AACD;;AACD,WAAKZ,cAAL,CAAoBpH,KAApB;;AACAa,MAAAA,OAAO,CAACnG,IAAR,CAAawN,WAAW,CAAC,KAAKX,gBAAL,CAAsBrS,GAAtB,CAAD,EAA6B8K,KAA7B,CAAxB;AACA,aAAO;AACLW,QAAAA,OAAO,EAAE,EADJ;AAELvD,QAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAOhH,OAAP;AAFf,OAAP;AAID;AACF;;AACDsH,EAAAA,YAAY,CAAClL,EAAD,EAAK;AACf,QAAI,KAAKR,KAAL,KAAe,KAAK,CAAxB,EAA2B;AACzB,YAAM,IAAIxE,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,UAAM8P,KAAK,GAAG,EAAd;;AACA,UAAMK,YAAY,GAAG,KAAKH,mCAAL,CAAyChL,EAAE,CAACyK,SAA5C,CAArB;;AACA,QAAIU,YAAJ,EAAkB;AAChBL,MAAAA,KAAK,CAACrN,IAAN,CAAW0N,YAAX;AACD;;AACD,UAAMC,kBAAkB,GAAG,KAAKrB,mBAAL,CAAyBlH,GAAzB,CAA6B7C,EAAE,CAAC5D,SAAhC,CAA3B;;AACA,QAAIgP,kBAAkB,KAAK,KAAK,CAAhC,EAAmC;AACjC,UAAIA,kBAAkB,KAAKpL,EAAE,CAACyB,IAA9B,EAAoC;AAClC,eAAOqJ,KAAK,CAACvN,MAAN,KAAiB,CAAjB,GAAqB;AAAE4C,UAAAA,QAAQ,EAAE;AAAZ,SAArB,GAA2C;AAAEA,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAOE,KAAP,CAAtB;AAAqCpH,UAAAA,OAAO,EAAE;AAA9C,SAAlD;AACD,OAFD,MAEO;AACL,aAAKqG,mBAAL,CAAyBvG,MAAzB,CAAgCxD,EAAE,CAAC5D,SAAnC;AACD;AACF;;AACD,UAAMsO,2BAA2B,GAAG,KAAKJ,gBAAL,CAAsBtK,EAAE,CAAC5D,SAAzB,CAApC;;AACA,UAAMiP,YAAY,GAAG,KAAKzB,MAAL,CAAYxD,IAAZ,CAAkB9E,IAAD,IAAUA,IAAI,CAAC3B,GAAL,KAAaK,EAAE,CAACQ,EAA3C,CAArB;;AACA,QAAI6K,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAC3B,UAAIA,YAAY,CAACvL,UAAb,KAA4BE,EAAE,CAAC5D,SAAnC,EAA8C;AAC5C,eAAO;AACL+D,UAAAA,QAAQ,EAAE2K,KAAK,CAACvN,MAAN,GAAe,CAAf,GAAmBqN,UAAU,CAAC,IAAD,EAAOE,KAAP,CAA7B,GAA6C,KADlD;AAELpH,UAAAA,OAAO,EAAE;AAFJ,SAAP;AAID;;AACD,UAAIgH,2BAA2B,KAAK,CAAC,CAArC,EAAwC;AACtC,aAAKb,uBAAL,CAA6BpP,GAA7B,CACE,KAAKmP,MAAL,CAAYc,2BAAZ,CADF;;AAGA,aAAKd,MAAL,CAAY0B,MAAZ,CAAmBZ,2BAAnB,EAAgD,CAAhD;;AACAI,QAAAA,KAAK,CAACrN,IAAN,CAAW8N,WAAW,CAACb,2BAAD,CAAtB;AACD;;AACD,YAAMc,aAAa,GAAG,KAAK5B,MAAL,CAAY7Q,OAAZ,CAAoBsS,YAApB,CAAtB;;AACAA,MAAAA,YAAY,CAACjL,cAAb,CAA4B,IAA5B,EAAkCJ,EAAE,CAAC5D,SAArC;;AACA,WAAKgO,UAAL;;AACA,YAAMqB,QAAQ,GAAG,KAAK7B,MAAL,CAAY7Q,OAAZ,CAAoBsS,YAApB,CAAjB;;AACA,UAAII,QAAQ,KAAKD,aAAjB,EAAgC;AAC9BV,QAAAA,KAAK,CAACrN,IAAN,CAAWiO,SAAS,CAACF,aAAD,EAAgBC,QAAhB,EAA0BJ,YAA1B,CAApB;AACD;;AACD,aAAO;AACLlL,QAAAA,QAAQ,EAAE2K,KAAK,CAACvN,MAAN,GAAe,CAAf,GAAmBqN,UAAU,CAAC,IAAD,EAAOE,KAAP,CAA7B,GAA6C,KADlD;AAELpH,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID,KAzBD,MAyBO;AACL,YAAMiI,MAAM,GAAG,KAAKnM,KAAL,CAAW8D,OAAX,CAAmBtD,EAAE,CAACQ,EAAtB,CAAf;;AACA,UAAImL,MAAM,IAAI,KAAK9B,uBAAL,CAA6BrP,GAA7B,CAAiCmR,MAAjC,CAAd,EAAwD;AACtDA,QAAAA,MAAM,CAACvL,cAAP,CAAsB,IAAtB,EAA4BJ,EAAE,CAAC5D,SAA/B;;AACA,aAAKyN,uBAAL,CAA6BrG,MAA7B,CAAoCmI,MAApC;;AACA,aAAKxB,cAAL,CAAoBwB,MAApB;;AACA,cAAMC,kBAAkB,GAAG,KAAKhC,MAAL,CAAY7Q,OAAZ,CAAoB4S,MAApB,CAA3B;;AACA,eAAO;AACLxL,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CACzBF,2BAA2B,KAAK,CAAC,CAAjC,GAAqCO,WAAW,CAACW,kBAAD,EAAqBD,MAArB,CAAhD,GAA+Ed,QAAQ,CAACe,kBAAD,EAAqBD,MAArB,CAD9D,EAEzB,GAAGb,KAFsB,CAAP,CADf;AAKLpH,UAAAA,OAAO,EAAE;AALJ,SAAP;AAOD,OAZD,MAYO;AACL,YAAIgH,2BAA2B,KAAK,CAAC,CAArC,EAAwC;AACtC,eAAKd,MAAL,CAAY0B,MAAZ,CAAmBZ,2BAAnB,EAAgD,CAAhD;AACD;;AACD,cAAM;AAAEmB,UAAAA,OAAF;AAAWJ,UAAAA;AAAX,YAAwB,KAAKK,wBAAL,CAC5B9L,EAD4B,EAE5BA,EAAE,CAAC5D,SAFyB,CAA9B;;AAIA,eAAO;AACL+D,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CACzBF,2BAA2B,KAAK,CAAC,CAAjC,GAAqCO,WAAW,CAACQ,QAAD,EAAWI,OAAX,CAAhD,GAAsEhB,QAAQ,CAACY,QAAD,EAAWI,OAAX,CADrD,EAEzB,GAAGf,KAFsB,CAAP,CADf;AAKLpH,UAAAA,OAAO,EAAE;AALJ,SAAP;AAOD;AACF;AACF;;AACDsH,EAAAA,mCAAmC,CAACP,SAAD,EAAY;AAC7C,QAAIA,SAAS,KAAK,KAAK,CAAnB,IAAwB,KAAKjL,KAAL,KAAe,KAAK,CAAhD,EAAmD;AACjD,aAAO,IAAP;AACD;;AACD,UAAMuM,WAAW,GAAG,KAAKvM,KAAL,CAAW8D,OAAX,CAAmBmH,SAAnB,CAApB;;AACA,QAAIsB,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1B,aAAO,IAAP;AACD;;AACD,UAAM3O,MAAM,GAAG,KAAK8C,YAAL,CAAkB6L,WAAlB,CAAf;;AACA,QAAI3O,MAAM,CAAC+C,QAAP,KAAoB,KAAxB,EAA+B;AAC7B,aAAO,IAAP;AACD;;AACD,WAAO/C,MAAM,CAAC+C,QAAP,CAAgByD,OAAhB,CAAwB,CAAxB,CAAP;AACD;;AACDoI,EAAAA,kBAAkB,CAAChM,EAAD,EAAK;AACrB,QAAI,KAAKR,KAAL,KAAe,KAAK,CAAxB,EAA2B;AACzB,YAAM,IAAIxE,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,UAAM/C,GAAG,GAAG+H,EAAE,CAAC5D,SAAf;;AACA,UAAM6P,iBAAiB,GAAG,KAAK3B,gBAAL,CAAsBrS,GAAtB,CAA1B;;AACA,QAAIgU,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,WAAKC,kBAAL,CAAwBD,iBAAxB,EAA2ChU,GAA3C;AACD;;AACD,UAAM;AAAE4T,MAAAA,OAAF;AAAWJ,MAAAA;AAAX,QAAwB,KAAKK,wBAAL,CAA8B9L,EAA9B,EAAkC/H,GAAlC,CAA9B;;AACA,WAAO;AACLkI,MAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACK,WAAW,CAACQ,QAAD,EAAWI,OAAX,CAAZ,CAAP,CADf;AAELnI,MAAAA,OAAO,EAAE;AAFJ,KAAP;AAID;;AACDyI,EAAAA,eAAe,CAACnM,EAAD,EAAK;AAClB,UAAMqL,YAAY,GAAG,KAAKzB,MAAL,CAAYxD,IAAZ,CAAkB9E,IAAD,IAAUA,IAAI,CAAC3B,GAAL,KAAaK,EAAE,CAACQ,EAA3C,CAArB;;AACA,UAAMvI,GAAG,GAAG+H,EAAE,CAAC5D,SAAf;;AACA,UAAMgQ,mBAAmB,GAAG,KAAK9B,gBAAL,CAAsBrS,GAAtB,CAA5B;;AACA,QAAIoT,YAAJ,EAAkB;AAChB,UAAIA,YAAY,CAACvL,UAAb,KAA4B7H,GAAhC,EAAqC;AACnC,eAAO;AACLkI,UAAAA,QAAQ,EAAE;AADL,SAAP;AAGD,OAJD,MAIO;AACL,cAAMkM,gBAAgB,GAAG,KAAKzC,MAAL,CAAY7Q,OAAZ,CAAoBsS,YAApB,CAAzB;;AACA,YAAIe,mBAAmB,KAAK,CAAC,CAA7B,EAAgC;AAC9B,eAAKF,kBAAL,CAAwBE,mBAAxB,EAA6CnU,GAA7C;AACD;;AACDoT,QAAAA,YAAY,CAACjL,cAAb,CAA4B,IAA5B,EAAkCnI,GAAlC;;AACA,aAAKmS,UAAL;;AACA,cAAMqB,QAAQ,GAAG,KAAKnB,gBAAL,CAAsBrS,GAAtB,CAAjB;;AACA,YAAIwT,QAAQ,KAAKY,gBAAjB,EAAmC;AACjC,iBAAO;AAAElM,YAAAA,QAAQ,EAAE;AAAZ,WAAP;AACD;;AACD,eAAO;AACLA,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CACzBc,SAAS,CAACW,gBAAD,EAAmBZ,QAAnB,EAA6BJ,YAA7B,CADgB,CAAP,CADf;AAIL3H,UAAAA,OAAO,EAAE;AAJJ,SAAP;AAMD;AACF,KAvBD,MAuBO;AACL,YAAMiI,MAAM,GAAGnQ,EAAE,CAAC,KAAKgE,KAAN,CAAF,CAAe8D,OAAf,CAAuBtD,EAAE,CAACQ,EAA1B,CAAf;;AACA,UAAImL,MAAM,IAAI,KAAK9B,uBAAL,CAA6BrP,GAA7B,CAAiCmR,MAAjC,CAAd,EAAwD;AACtDA,QAAAA,MAAM,CAACvL,cAAP,CAAsB,IAAtB,EAA4BnI,GAA5B;;AACA,aAAK4R,uBAAL,CAA6BrG,MAA7B,CAAoCmI,MAApC;;AACA,aAAKxB,cAAL,CAAoBwB,MAApB;;AACA,cAAMF,QAAQ,GAAG,KAAKnB,gBAAL,CAAsBrS,GAAtB,CAAjB;;AACA,eAAO;AACLkI,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACK,WAAW,CAACQ,QAAD,EAAWE,MAAX,CAAZ,CAAP,CADf;AAELjI,UAAAA,OAAO,EAAE;AAFJ,SAAP;AAID,OATD,MASO;AACL,YAAI0I,mBAAmB,KAAK,CAAC,CAA7B,EAAgC;AAC9B,eAAKF,kBAAL,CAAwBE,mBAAxB,EAA6CnU,GAA7C;AACD;;AACD,cAAM;AAAE4T,UAAAA,OAAF;AAAWJ,UAAAA;AAAX,YAAwB,KAAKK,wBAAL,CAA8B9L,EAA9B,EAAkC/H,GAAlC,CAA9B;;AACA,eAAO;AACLkI,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACK,WAAW,CAACQ,QAAD,EAAWI,OAAX,CAAZ,CAAP,CADf;AAELnI,UAAAA,OAAO,EAAE;AAFJ,SAAP;AAID;AACF;AACF;;AACD4I,EAAAA,oBAAoB,CAACtM,EAAD,EAAK;AACvB,QAAIuM,EAAJ;;AACA,UAAM;AAAE/L,MAAAA,EAAF;AAAMpE,MAAAA,SAAS,EAAEnE;AAAjB,QAAyB+H,EAA/B;AACA,UAAM+C,KAAK,GAAGM,oBAAoB,CAACrD,EAAD,CAAlC;;AACA,QAAI,CAAC,CAACuM,EAAE,GAAG,KAAK/M,KAAX,KAAqB,IAArB,GAA4B,KAAK,CAAjC,GAAqC+M,EAAE,CAACjJ,OAAH,CAAW9C,EAAX,CAAtC,MAA0D,KAAK,CAAnE,EAAsE;AACpE,aAAO;AAAEL,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD;;AACD4C,IAAAA,KAAK,CAACxC,OAAN,CAAcC,EAAd,EAAkBhF,EAAE,CAAC,KAAKgE,KAAN,CAApB;;AACAuD,IAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BnI,GAA3B;;AACA,UAAMgU,iBAAiB,GAAG,KAAK3B,gBAAL,CAAsBrS,GAAtB,CAA1B;;AACA,QAAIuU,MAAM,GAAGvU,GAAb;;AACA,QAAIgU,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,YAAMpP,MAAM,GAAG,KAAK+M,MAAL,CAAYqC,iBAAZ,IAAiC,KAAKrC,MAAL,CAAYqC,iBAAZ,EAA+B3M,oBAA/B,EAAjC,GAAyF,KAAK,CAA7G;AACA,YAAMxC,KAAK,GAAG,KAAK8M,MAAL,CAAYqC,iBAAiB,GAAG,CAAhC,IAAqC,KAAKrC,MAAL,CAAYqC,iBAAiB,GAAG,CAAhC,EAAmC3M,oBAAnC,EAArC,GAAiG,KAAK,CAApH;AACAkN,MAAAA,MAAM,GAAG5P,YAAY,CAACC,MAAD,EAASC,KAAT,CAArB;;AACAiG,MAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BoM,MAA3B;AACD;;AACD,SAAKrC,cAAL,CAAoBpH,KAApB;;AACA,UAAM0I,QAAQ,GAAG,KAAKnB,gBAAL,CAAsBkC,MAAtB,CAAjB;;AACA,WAAO;AACLrM,MAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACK,WAAW,CAACQ,QAAD,EAAW1I,KAAX,CAAZ,CAAP,CADf;AAELW,MAAAA,OAAO,EAAE,CAAC;AAAEzH,QAAAA,IAAI,EAAE;AAAE;AAAV;AAA6BuE,QAAAA;AAA7B,OAAD;AAFJ,KAAP;AAID;;AACDiM,EAAAA,iBAAiB,CAACzM,EAAD,EAAK;AACpB,QAAIuM,EAAJ;;AACA,UAAM;AAAE/L,MAAAA,EAAF;AAAMpE,MAAAA,SAAS,EAAEnE;AAAjB,QAAyB+H,EAA/B;AACA,UAAM+C,KAAK,GAAGM,oBAAoB,CAACrD,EAAD,CAAlC;;AACA,QAAI,CAAC,CAACuM,EAAE,GAAG,KAAK/M,KAAX,KAAqB,IAArB,GAA4B,KAAK,CAAjC,GAAqC+M,EAAE,CAACjJ,OAAH,CAAW9C,EAAX,CAAtC,MAA0D,KAAK,CAAnE,EAAsE;AACpE,aAAO;AAAEL,QAAAA,QAAQ,EAAE;AAAZ,OAAP;AACD;;AACD,SAAK4J,mBAAL,CAAyB9G,GAAzB,CAA6BhL,GAA7B,EAAkCuD,EAAE,CAACwE,EAAE,CAACyB,IAAJ,CAApC;;AACA,UAAMiL,sBAAsB,GAAG,KAAKpC,gBAAL,CAAsBrS,GAAtB,CAA/B;;AACA8K,IAAAA,KAAK,CAACxC,OAAN,CAAcC,EAAd,EAAkBhF,EAAE,CAAC,KAAKgE,KAAN,CAApB;;AACAuD,IAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BnI,GAA3B;;AACA,UAAMuU,MAAM,GAAGvU,GAAf;;AACA,QAAIyU,sBAAsB,KAAK,CAAC,CAAhC,EAAmC;AACjC,YAAMrB,YAAY,GAAG,KAAKzB,MAAL,CAAY8C,sBAAZ,CAArB;;AACArB,MAAAA,YAAY,CAAC1K,OAAb;;AACA,WAAKiJ,MAAL,CAAY8C,sBAAZ,IAAsC3J,KAAtC;;AACA,YAAMW,OAAO,GAAG2H,YAAY,CAAC7J,MAAb,CAAoBhG,EAAE,CAAC,KAAKmE,GAAN,CAAtB,EAAkC1H,GAAlC,EAAuC,KAAKuH,KAA5C,CAAhB;;AACAmN,MAAAA,gCAAgC,CAACjJ,OAAD,EAAU1D,EAAE,CAACQ,EAAb,CAAhC;AACA,YAAMsK,KAAK,GAAG,CAACD,QAAQ,CAAC6B,sBAAD,EAAyB3J,KAAzB,CAAT,CAAd;;AACA,YAAMoI,YAAY,GAAG,KAAKH,mCAAL,CACnBhL,EAAE,CAACyK,SADgB,CAArB;;AAGA,UAAIU,YAAJ,EAAkB;AAChBL,QAAAA,KAAK,CAACrN,IAAN,CAAW0N,YAAX;AACD;;AACD,aAAO;AACLhL,QAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAOE,KAAP,CADf;AAELpH,QAAAA;AAFK,OAAP;AAID,KAjBD,MAiBO;AACL,WAAKyG,cAAL,CAAoBpH,KAApB;;AACA,WAAKiI,mCAAL,CAAyChL,EAAE,CAACyK,SAA5C;;AACA,YAAMgB,QAAQ,GAAG,KAAKnB,gBAAL,CAAsBkC,MAAtB,CAAjB;;AACA,aAAO;AACL9I,QAAAA,OAAO,EAAE,CAAC;AAAEzH,UAAAA,IAAI,EAAE;AAAE;AAAV;AAA6BuE,UAAAA;AAA7B,SAAD,CADJ;AAELL,QAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACK,WAAW,CAACQ,QAAD,EAAW1I,KAAX,CAAZ,CAAP;AAFf,OAAP;AAID;AACF;;AACDnB,EAAAA,YAAY,CAAC5B,EAAD,EAAKpH,MAAL,EAAa;AACvB,QAAI,KAAK4G,KAAL,KAAe,KAAK,CAAxB,EAA2B;AACzB,YAAM,IAAIxE,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,QAAIoC,MAAJ;;AACA,QAAI4C,EAAE,CAAC4M,MAAH,KAAc,KAAlB,EAAyB;AACvB,UAAIhU,MAAM,KAAK;AAAE;AAAjB,QAA+B;AAC7BwE,QAAAA,MAAM,GAAG,KAAKoN,eAAL,CAAqBxK,EAArB,CAAT;AACD,OAFD,MAEO,IAAIpH,MAAM,KAAK;AAAE;AAAjB,QAA4B;AACjCwE,QAAAA,MAAM,GAAG,KAAK8N,YAAL,CAAkBlL,EAAlB,CAAT;AACD,OAFM,MAEA;AACL5C,QAAAA,MAAM,GAAG,KAAKqP,iBAAL,CAAuBzM,EAAvB,CAAT;AACD;AACF,KARD,MAQO;AACL,UAAIpH,MAAM,KAAK;AAAE;AAAjB,QAA+B;AAC7BwE,QAAAA,MAAM,GAAG,KAAK4O,kBAAL,CAAwBhM,EAAxB,CAAT;AACD,OAFD,MAEO,IAAIpH,MAAM,KAAK;AAAE;AAAjB,QAA4B;AACjCwE,QAAAA,MAAM,GAAG,KAAK+O,eAAL,CAAqBnM,EAArB,CAAT;AACD,OAFM,MAEA;AACL5C,QAAAA,MAAM,GAAG,KAAKkP,oBAAL,CAA0BtM,EAA1B,CAAT;AACD;AACF;;AACD,QAAI5C,MAAM,CAAC+C,QAAP,KAAoB,KAAxB,EAA+B;AAC7B,WAAKU,UAAL;AACD;;AACD,WAAOzD,MAAP;AACD;;AACD8C,EAAAA,YAAY,CAAC6C,KAAD,EAAQ;AAClB,QAAIA,KAAJ,EAAW;AACT,YAAM3G,SAAS,GAAGZ,EAAE,CAACuH,KAAK,CAACjD,UAAP,CAApB;;AACA,YAAM4D,OAAO,GAAGX,KAAK,CAACvB,MAAN,CAAahG,EAAE,CAAC,KAAKmE,GAAN,CAAf,EAA2BvD,SAA3B,EAAsC,KAAKoD,KAA3C,CAAhB;;AACA,YAAMqN,aAAa,GAAG,KAAKjD,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAtB;;AACA,UAAI8J,aAAa,KAAK,CAAC,CAAvB,EAA0B;AACxB,eAAO;AACL1M,UAAAA,QAAQ,EAAE;AADL,SAAP;AAGD;;AACD,WAAKyJ,MAAL,CAAY0B,MAAZ,CAAmBuB,aAAnB,EAAkC,CAAlC;;AACA,WAAKhM,UAAL;;AACAkC,MAAAA,KAAK,CAACpC,OAAN;;AACA,aAAO;AACLR,QAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACW,WAAW,CAACsB,aAAD,CAAZ,CAAP,CADf;AAELnJ,QAAAA;AAFK,OAAP;AAID;;AACD,WAAO;AAAEvD,MAAAA,QAAQ,EAAE;AAAZ,KAAP;AACD;;AACD2M,EAAAA,uBAAuB,CAACN,MAAD,EAASzJ,KAAT,EAAgB;AACrC,QAAIwJ,EAAJ;;AACA,QAAI,KAAK1C,uBAAL,CAA6BrP,GAA7B,CAAiCuI,KAAjC,CAAJ,EAA6C;AAC3C,WAAK8G,uBAAL,CAA6BrG,MAA7B,CAAoCT,KAApC;;AACAA,MAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BoM,MAA3B;;AACA,WAAKrC,cAAL,CAAoBpH,KAApB;;AACA,YAAM0I,QAAQ,GAAG,KAAK7B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAjB;;AACA,aAAO;AACL5C,QAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACK,WAAW,CAACQ,QAAD,EAAW1I,KAAX,CAAZ,CAAP,CADf;AAELW,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID;;AACD,UAAMqJ,WAAW,GAAGhK,KAAK,CAACjD,UAA1B;;AACA,QAAI0M,MAAM,KAAKO,WAAf,EAA4B;AAC1B,aAAO;AACL5M,QAAAA,QAAQ,EAAE;AADL,OAAP;AAGD;;AACD,UAAM8L,iBAAiB,GAAG,KAAK3B,gBAAL,CAAsBkC,MAAtB,CAA1B;;AACA,QAAIP,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,YAAMT,aAAa,GAAG,KAAK5B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAtB;;AACAA,MAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BoM,MAA3B;;AACA,WAAKpC,UAAL;;AACA,YAAMqB,QAAQ,GAAG,KAAK7B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAjB;;AACA,UAAI0I,QAAQ,KAAKD,aAAjB,EAAgC;AAC9B,eAAO;AACLrL,UAAAA,QAAQ,EAAE;AADL,SAAP;AAGD;;AACD,aAAO;AACLA,QAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACc,SAAS,CAACF,aAAD,EAAgBC,QAAhB,EAA0B1I,KAA1B,CAAV,CAAP,CADf;AAELW,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID,KAdD,MAcO;AACL,WAAKkG,MAAL,CAAYqC,iBAAZ,EAA+B7L,cAA/B,CACE,IADF,EAEExD,YAAY,CACV4P,MADU,EAEV,CAACD,EAAE,GAAG,KAAK3C,MAAL,CAAYqC,iBAAiB,GAAG,CAAhC,CAAN,KAA6C,IAA7C,GAAoD,KAAK,CAAzD,GAA6DM,EAAE,CAACjN,oBAAH,EAFnD,CAFd;;AAOA,YAAMkM,aAAa,GAAG,KAAK5B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAtB;;AACAA,MAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BoM,MAA3B;;AACA,WAAKpC,UAAL;;AACA,YAAMqB,QAAQ,GAAG,KAAK7B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAjB;;AACA,UAAI0I,QAAQ,KAAKD,aAAjB,EAAgC;AAC9B,eAAO;AACLrL,UAAAA,QAAQ,EAAE;AADL,SAAP;AAGD;;AACD,aAAO;AACLA,QAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACc,SAAS,CAACF,aAAD,EAAgBC,QAAhB,EAA0B1I,KAA1B,CAAV,CAAP,CADf;AAELW,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID;AACF;;AACDsJ,EAAAA,oBAAoB,CAACR,MAAD,EAASzJ,KAAT,EAAgB;AAClC,QAAIwJ,EAAJ,EAAQU,EAAR;;AACA,UAAMF,WAAW,GAAGvR,EAAE,CAACuH,KAAK,CAACjD,UAAP,CAAtB;;AACA,QAAI,KAAK+J,uBAAL,CAA6BrP,GAA7B,CAAiCuI,KAAjC,CAAJ,EAA6C;AAC3C,YAAMkJ,iBAAiB,GAAG,KAAK3B,gBAAL,CAAsBkC,MAAtB,CAA1B;;AACA,WAAK3C,uBAAL,CAA6BrG,MAA7B,CAAoCT,KAApC;;AACA,UAAIkJ,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,aAAKrC,MAAL,CAAYqC,iBAAZ,EAA+B7L,cAA/B,CACE,IADF,EAEExD,YAAY,CACV4P,MADU,EAEV,CAACD,EAAE,GAAG,KAAK3C,MAAL,CAAYqC,iBAAiB,GAAG,CAAhC,CAAN,KAA6C,IAA7C,GAAoD,KAAK,CAAzD,GAA6DM,EAAE,CAACjN,oBAAH,EAFnD,CAFd;AAOD;;AACDyD,MAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BoM,MAA3B;;AACA,WAAKrC,cAAL,CAAoBpH,KAApB;;AACA,aAAO;AACL5C,QAAAA,QAAQ,EAAE;AADL,OAAP;AAGD,KAjBD,MAiBO;AACL,UAAIqM,MAAM,KAAKO,WAAf,EAA4B;AAC1B,eAAO;AACL5M,UAAAA,QAAQ,EAAE;AADL,SAAP;AAGD;;AACD,YAAMqL,aAAa,GAAG,KAAK5B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAtB;;AACA,YAAMkJ,iBAAiB,GAAG,KAAK3B,gBAAL,CAAsBkC,MAAtB,CAA1B;;AACA,UAAIP,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,aAAKrC,MAAL,CAAYqC,iBAAZ,EAA+B7L,cAA/B,CACE,IADF,EAEExD,YAAY,CACV4P,MADU,EAEV,CAACS,EAAE,GAAG,KAAKrD,MAAL,CAAYqC,iBAAiB,GAAG,CAAhC,CAAN,KAA6C,IAA7C,GAAoD,KAAK,CAAzD,GAA6DgB,EAAE,CAAC3N,oBAAH,EAFnD,CAFd;AAOD;;AACDyD,MAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BoM,MAA3B;;AACA,WAAKpC,UAAL;;AACA,YAAMqB,QAAQ,GAAG,KAAK7B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAjB;;AACA,UAAIyI,aAAa,KAAKC,QAAtB,EAAgC;AAC9B,eAAO;AACLtL,UAAAA,QAAQ,EAAE;AADL,SAAP;AAGD,OAJD,MAIO;AACL,eAAO;AACLA,UAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CACzBc,SAAS,CAACF,aAAD,EAAgBC,QAAhB,EAA0B1I,KAA1B,CADgB,CAAP,CADf;AAILW,UAAAA,OAAO,EAAE;AAJJ,SAAP;AAMD;AACF;AACF;;AACDwJ,EAAAA,yBAAyB,CAACV,MAAD,EAASzJ,KAAT,EAAgB;AACvC,QAAIwJ,EAAJ;;AACA,UAAMQ,WAAW,GAAGvR,EAAE,CAACuH,KAAK,CAACjD,UAAP,CAAtB;;AACA,UAAM0L,aAAa,GAAG,KAAK5B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAtB;;AACA,UAAMkJ,iBAAiB,GAAG,KAAK3B,gBAAL,CAAsBkC,MAAtB,CAA1B;;AACA,QAAIP,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,WAAKrC,MAAL,CAAYqC,iBAAZ,EAA+B7L,cAA/B,CACE,IADF,EAEExD,YAAY,CACV4P,MADU,EAEV,CAACD,EAAE,GAAG,KAAK3C,MAAL,CAAYqC,iBAAiB,GAAG,CAAhC,CAAN,KAA6C,IAA7C,GAAoD,KAAK,CAAzD,GAA6DM,EAAE,CAACjN,oBAAH,EAFnD,CAFd;AAOD;;AACDyD,IAAAA,KAAK,CAAC3C,cAAN,CAAqB,IAArB,EAA2BoM,MAA3B;;AACA,SAAKpC,UAAL;;AACA,UAAMqB,QAAQ,GAAG,KAAK7B,MAAL,CAAY7Q,OAAZ,CAAoBgK,KAApB,CAAjB;;AACA,QAAIyI,aAAa,KAAKC,QAAtB,EAAgC;AAC9B,aAAO;AACLtL,QAAAA,QAAQ,EAAE;AADL,OAAP;AAGD;;AACD,WAAO;AACLA,MAAAA,QAAQ,EAAEyK,UAAU,CAAC,IAAD,EAAO,CAACc,SAAS,CAACF,aAAD,EAAgBC,QAAhB,EAA0B1I,KAA1B,CAAV,CAAP,CADf;AAELW,MAAAA,OAAO,EAAE,CACP;AACEzH,QAAAA,IAAI,EAAE;AAAE;AADV;AAEEuE,QAAAA,EAAE,EAAEhF,EAAE,CAACuH,KAAK,CAACpD,GAAP,CAFR;AAGEvD,QAAAA,SAAS,EAAE2Q;AAHb,OADO;AAFJ,KAAP;AAUD;;AACDI,EAAAA,YAAY,CAACX,MAAD,EAASzJ,KAAT,EAAgBnK,MAAhB,EAAwB;AAClC,QAAIA,MAAM,KAAK;AAAE;AAAjB,MAA+B;AAC7B,aAAO,KAAKkU,uBAAL,CAA6BN,MAA7B,EAAqCzJ,KAArC,CAAP;AACD,KAFD,MAEO,IAAInK,MAAM,KAAK;AAAE;AAAjB,MAA4B;AACjC,aAAO,KAAKoU,oBAAL,CAA0BR,MAA1B,EAAkCzJ,KAAlC,CAAP;AACD,KAFM,MAEA;AACL,aAAO,KAAKmK,yBAAL,CAA+BV,MAA/B,EAAuCzJ,KAAvC,CAAP;AACD;AACF;;AACDhD,EAAAA,MAAM,CAACC,EAAD,EAAK+B,OAAL,EAAc;AAClB,WAAO,MAAMhC,MAAN,CAAaC,EAAb,EAAiB+B,OAAjB,CAAP;AACD;;AACDJ,EAAAA,UAAU,GAAG;AACX,QAAI,KAAKpC,MAAL,CAAYtD,IAAZ,KAAqB,WAAzB,EAAsC;AACpC,YAAM,IAAIjB,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,WAAO;AACLiB,MAAAA,IAAI,EAAE;AAAE;AADH;AAELE,MAAAA,QAAQ,EAAEX,EAAE,CAAC,KAAK+D,MAAL,CAAYT,IAAZ,CAAiBa,GAAlB,EAAuB,iCAAvB,CAFP;AAGLvD,MAAAA,SAAS,EAAE,KAAKmD,MAAL,CAAYtH;AAHlB,KAAP;AAKD;;AACS,MAANsF,MAAM,GAAG;AACX,WAAO,KAAKqM,MAAL,CAAYrM,MAAnB;AACD;;AACDE,EAAAA,IAAI,CAAC2P,OAAD,EAAU;AACZ,WAAO,KAAKC,MAAL,CAAYD,OAAZ,EAAqB,KAAK7P,MAA1B,CAAP;AACD;;AACD8P,EAAAA,MAAM,CAACD,OAAD,EAAUzP,KAAV,EAAiB;AACrB,QAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,KAAKiM,MAAL,CAAYrM,MAArC,EAA6C;AAC3C,YAAM,IAAIvC,KAAJ,CACH,sCAAqC2C,KAAM,oCAAmC,KAAKiM,MAAL,CAAYrM,MAAO,EAD9F,CAAN;AAGD;;AACD,UAAMV,MAAM,GAAG,KAAK+M,MAAL,CAAYjM,KAAK,GAAG,CAApB,IAAyB,KAAKiM,MAAL,CAAYjM,KAAK,GAAG,CAApB,EAAuB2B,oBAAvB,EAAzB,GAAyE,KAAK,CAA7F;AACA,UAAMxC,KAAK,GAAG,KAAK8M,MAAL,CAAYjM,KAAZ,IAAqB,KAAKiM,MAAL,CAAYjM,KAAZ,EAAmB2B,oBAAnB,EAArB,GAAiE,KAAK,CAApF;AACA,UAAM0K,QAAQ,GAAGpN,YAAY,CAACC,MAAD,EAASC,KAAT,CAA7B;AACA,UAAM5F,KAAK,GAAGoL,cAAc,CAAC8K,OAAD,CAA5B;;AACAlW,IAAAA,KAAK,CAACkJ,cAAN,CAAqB,IAArB,EAA2B4J,QAA3B;;AACA,SAAKG,cAAL,CAAoBjT,KAApB;;AACA,QAAI,KAAKsI,KAAL,IAAc,KAAKG,GAAvB,EAA4B;AAC1B,YAAMa,EAAE,GAAG,KAAKhB,KAAL,CAAW4D,UAAX,EAAX;;AACAlM,MAAAA,KAAK,CAACqJ,OAAN,CAAcC,EAAd,EAAkB,KAAKhB,KAAvB;;AACA,WAAKA,KAAL,CAAW0E,QAAX,CACEhN,KAAK,CAACsK,MAAN,CAAa,KAAK7B,GAAlB,EAAuBqK,QAAvB,EAAiC,KAAKxK,KAAtC,CADF,EAEE,CAAC;AAAEvD,QAAAA,IAAI,EAAE;AAAE;AAAV;AAA6BuE,QAAAA;AAA7B,OAAD,CAFF,EAGE,eAAgB,IAAI2B,GAAJ,CAAQ,CACtB,CAAC,KAAKxC,GAAN,EAAWiL,UAAU,CAAC,IAAD,EAAO,CAACK,WAAW,CAACtN,KAAD,EAAQzG,KAAR,CAAZ,CAAP,CAArB,CADsB,CAAR,CAHlB;AAOD;AACF;;AACDoW,EAAAA,IAAI,CAAC3P,KAAD,EAAQ4P,WAAR,EAAqB;AACvB,QAAIA,WAAW,GAAG,CAAlB,EAAqB;AACnB,YAAM,IAAIvS,KAAJ,CAAU,mCAAV,CAAN;AACD;;AACD,QAAIuS,WAAW,IAAI,KAAK3D,MAAL,CAAYrM,MAA/B,EAAuC;AACrC,YAAM,IAAIvC,KAAJ,CACJ,6DADI,CAAN;AAGD;;AACD,QAAI2C,KAAK,GAAG,CAAZ,EAAe;AACb,YAAM,IAAI3C,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACD,QAAI2C,KAAK,IAAI,KAAKiM,MAAL,CAAYrM,MAAzB,EAAiC;AAC/B,YAAM,IAAIvC,KAAJ,CAAU,uDAAV,CAAN;AACD;;AACD,QAAIwS,cAAc,GAAG,IAArB;AACA,QAAIC,aAAa,GAAG,IAApB;;AACA,QAAI9P,KAAK,GAAG4P,WAAZ,EAAyB;AACvBE,MAAAA,aAAa,GAAGF,WAAW,KAAK,KAAK3D,MAAL,CAAYrM,MAAZ,GAAqB,CAArC,GAAyC,KAAK,CAA9C,GAAkD,KAAKqM,MAAL,CAAY2D,WAAW,GAAG,CAA1B,EAA6BjO,oBAA7B,EAAlE;AACAkO,MAAAA,cAAc,GAAG,KAAK5D,MAAL,CAAY2D,WAAZ,EAAyBjO,oBAAzB,EAAjB;AACD,KAHD,MAGO;AACLmO,MAAAA,aAAa,GAAG,KAAK7D,MAAL,CAAY2D,WAAZ,EAAyBjO,oBAAzB,EAAhB;AACAkO,MAAAA,cAAc,GAAGD,WAAW,KAAK,CAAhB,GAAoB,KAAK,CAAzB,GAA6B,KAAK3D,MAAL,CAAY2D,WAAW,GAAG,CAA1B,EAA6BjO,oBAA7B,EAA9C;AACD;;AACD,UAAM0K,QAAQ,GAAGpN,YAAY,CAAC4Q,cAAD,EAAiBC,aAAjB,CAA7B;AACA,UAAMnM,IAAI,GAAG,KAAKsI,MAAL,CAAYjM,KAAZ,CAAb;;AACA,UAAM+P,gBAAgB,GAAGpM,IAAI,CAAChC,oBAAL,EAAzB;;AACAgC,IAAAA,IAAI,CAAClB,cAAL,CAAoB,IAApB,EAA0B4J,QAA1B;;AACA,SAAKI,UAAL;;AACA,QAAI,KAAK5K,KAAL,IAAc,KAAKG,GAAvB,EAA4B;AAC1B,YAAMsE,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,CAAQ,CAC7C,CAAC,KAAKxC,GAAN,EAAWiL,UAAU,CAAC,IAAD,EAAO,CAACc,SAAS,CAAC/N,KAAD,EAAQ4P,WAAR,EAAqBjM,IAArB,CAAV,CAAP,CAArB,CAD6C,CAAR,CAAvC;;AAGA,WAAK9B,KAAL,CAAW0E,QAAX,CACE,CACE;AACEjI,QAAAA,IAAI,EAAE;AAAE;AADV;AAEEuE,QAAAA,EAAE,EAAEhF,EAAE,CAAC8F,IAAI,CAAC3B,GAAN,CAFR;AAGE8B,QAAAA,IAAI,EAAE,KAAKjC,KAAL,CAAWkC,YAAX,EAHR;AAIEtF,QAAAA,SAAS,EAAE4N;AAJb,OADF,CADF,EASE,CACE;AACE/N,QAAAA,IAAI,EAAE;AAAE;AADV;AAEEuE,QAAAA,EAAE,EAAEhF,EAAE,CAAC8F,IAAI,CAAC3B,GAAN,CAFR;AAGEvD,QAAAA,SAAS,EAAEsR;AAHb,OADF,CATF,EAgBEzJ,cAhBF;AAkBD;AACF;;AACDT,EAAAA,MAAM,CAAC7F,KAAD,EAAQ;AACZ,QAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAI,KAAKiM,MAAL,CAAYrM,MAAtC,EAA8C;AAC5C,YAAM,IAAIvC,KAAJ,CACH,sCAAqC2C,KAAM,oCAAmC,KAAKiM,MAAL,CAAYrM,MAAZ,GAAqB,CAAE,EADlG,CAAN;AAGD;;AACD,UAAM+D,IAAI,GAAG,KAAKsI,MAAL,CAAYjM,KAAZ,CAAb;;AACA2D,IAAAA,IAAI,CAACX,OAAL;;AACA,SAAKiJ,MAAL,CAAY0B,MAAZ,CAAmB3N,KAAnB,EAA0B,CAA1B;;AACA,SAAKkD,UAAL;;AACA,QAAI,KAAKrB,KAAT,EAAgB;AACd,YAAMmO,aAAa,GAAGrM,IAAI,CAAC3B,GAA3B;;AACA,UAAIgO,aAAJ,EAAmB;AACjB,cAAM1J,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,EAAvC;AACA8B,QAAAA,cAAc,CAAChB,GAAf,CACEzH,EAAE,CAAC,KAAKmE,GAAN,CADJ,EAEEiL,UAAU,CAAC,IAAD,EAAO,CAACW,WAAW,CAAC5N,KAAD,CAAZ,CAAP,CAFZ;;AAIA,aAAK6B,KAAL,CAAW0E,QAAX,CACE,CACE;AACE1D,UAAAA,EAAE,EAAEmN,aADN;AAEElM,UAAAA,IAAI,EAAE,KAAKjC,KAAL,CAAWkC,YAAX,EAFR;AAGEzF,UAAAA,IAAI,EAAE;AAAE;;AAHV,SADF,CADF,EAQEqF,IAAI,CAACE,MAAL,CAAYhG,EAAE,CAAC,KAAKmE,GAAN,CAAd,EAA0B2B,IAAI,CAAChC,oBAAL,EAA1B,CARF,EASE2E,cATF;AAWD;AACF;AACF;;AACD2J,EAAAA,KAAK,GAAG;AACN,QAAI,KAAKpO,KAAT,EAAgB;AACd,YAAMgD,GAAG,GAAG,EAAZ;AACA,YAAMuD,UAAU,GAAG,EAAnB;AACA,YAAMR,WAAW,GAAG,EAApB;;AACA,WAAK,MAAMjE,IAAX,IAAmB,KAAKsI,MAAxB,EAAgC;AAC9BtI,QAAAA,IAAI,CAACX,OAAL;;AACA,cAAMkN,OAAO,GAAGvM,IAAI,CAAC3B,GAArB;;AACA,YAAIkO,OAAJ,EAAa;AACXrL,UAAAA,GAAG,CAAC/E,IAAJ,CAAS;AACPxB,YAAAA,IAAI,EAAE;AAAE;AADD;AAEPuE,YAAAA,EAAE,EAAEqN,OAFG;AAGPpM,YAAAA,IAAI,EAAE,KAAKjC,KAAL,CAAWkC,YAAX;AAHC,WAAT;AAKAqE,UAAAA,UAAU,CAACtI,IAAX,CACE,GAAG6D,IAAI,CAACE,MAAL,CAAYhG,EAAE,CAAC,KAAKmE,GAAN,CAAd,EAA0B2B,IAAI,CAAChC,oBAAL,EAA1B,CADL;AAGAiG,UAAAA,WAAW,CAAC9H,IAAZ,CAAiB8N,WAAW,CAAC,CAAD,CAA5B;AACD;AACF;;AACD,WAAK3B,MAAL,GAAc,EAAd;AACA,WAAK/I,UAAL;AACA,YAAMoD,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,EAAvC;AACA8B,MAAAA,cAAc,CAAChB,GAAf,CAAmBzH,EAAE,CAAC,KAAKmE,GAAN,CAArB,EAAiCiL,UAAU,CAAC,IAAD,EAAOrF,WAAP,CAA3C;;AACA,WAAK/F,KAAL,CAAW0E,QAAX,CAAoB1B,GAApB,EAAyBuD,UAAzB,EAAqC9B,cAArC;AACD,KAxBD,MAwBO;AACL,WAAK,MAAM3C,IAAX,IAAmB,KAAKsI,MAAxB,EAAgC;AAC9BtI,QAAAA,IAAI,CAACX,OAAL;AACD;;AACD,WAAKiJ,MAAL,GAAc,EAAd;AACA,WAAK/I,UAAL;AACD;AACF;;AACDoC,EAAAA,GAAG,CAACtF,KAAD,EAAQ2D,IAAR,EAAc;AACf,QAAI3D,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAI,KAAKiM,MAAL,CAAYrM,MAAtC,EAA8C;AAC5C,YAAM,IAAIvC,KAAJ,CACH,mCAAkC2C,KAAM,oCAAmC,KAAKiM,MAAL,CAAYrM,MAAZ,GAAqB,CAAE,EAD/F,CAAN;AAGD;;AACD,UAAM8N,YAAY,GAAG,KAAKzB,MAAL,CAAYjM,KAAZ,CAArB;;AACA,UAAMqM,QAAQ,GAAGqB,YAAY,CAAC/L,oBAAb,EAAjB;;AACA,UAAMwO,UAAU,GAAGzC,YAAY,CAAC1L,GAAhC;;AACA0L,IAAAA,YAAY,CAAC1K,OAAb;;AACA,UAAMzJ,KAAK,GAAGoL,cAAc,CAAChB,IAAD,CAA5B;;AACApK,IAAAA,KAAK,CAACkJ,cAAN,CAAqB,IAArB,EAA2B4J,QAA3B;;AACA,SAAKJ,MAAL,CAAYjM,KAAZ,IAAqBzG,KAArB;AACA,SAAK2J,UAAL;;AACA,QAAI,KAAKrB,KAAL,IAAc,KAAKG,GAAvB,EAA4B;AAC1B,YAAMa,EAAE,GAAG,KAAKhB,KAAL,CAAW4D,UAAX,EAAX;;AACAlM,MAAAA,KAAK,CAACqJ,OAAN,CAAcC,EAAd,EAAkB,KAAKhB,KAAvB;;AACA,YAAMyE,cAAc,GAAG,eAAgB,IAAI9B,GAAJ,EAAvC;AACA8B,MAAAA,cAAc,CAAChB,GAAf,CAAmB,KAAKtD,GAAxB,EAA6BiL,UAAU,CAAC,IAAD,EAAO,CAACC,QAAQ,CAAClN,KAAD,EAAQzG,KAAR,CAAT,CAAP,CAAvC;;AACA,YAAMsL,GAAG,GAAGtL,KAAK,CAACsK,MAAN,CAAa,KAAK7B,GAAlB,EAAuBqK,QAAvB,EAAiC,KAAKxK,KAAtC,CAAZ;;AACAmN,MAAAA,gCAAgC,CAACnK,GAAD,EAAMsL,UAAN,CAAhC;;AACA,WAAK/D,mBAAL,CAAyB9G,GAAzB,CAA6B+G,QAA7B,EAAuCxO,EAAE,CAACgH,GAAG,CAAC,CAAD,CAAH,CAAOf,IAAR,CAAzC;;AACA,YAAMsE,UAAU,GAAGsF,YAAY,CAAC7J,MAAb,CAAoB,KAAK7B,GAAzB,EAA8BqK,QAA9B,EAAwC,KAAK,CAA7C,CAAnB;;AACA2C,MAAAA,gCAAgC,CAAC5G,UAAD,EAAavF,EAAb,CAAhC;;AACA,WAAKhB,KAAL,CAAW0E,QAAX,CAAoB1B,GAApB,EAAyBuD,UAAzB,EAAqC9B,cAArC;AACD;AACF;;AACD8J,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKnE,MAAL,CAAYjH,GAAZ,CACJN,KAAD,IAAW0B,cAAc,CAAC1B,KAAD,CADpB,CAAP;AAGD;;AACD2L,EAAAA,KAAK,CAACC,SAAD,EAAY;AACf,WAAO,KAAKF,OAAL,GAAeC,KAAf,CAAqBC,SAArB,CAAP;AACD;;AACDzH,EAAAA,MAAM,CAACyH,SAAD,EAAY;AAChB,WAAO,KAAKF,OAAL,GAAevH,MAAf,CAAsByH,SAAtB,CAAP;AACD;;AACD7H,EAAAA,IAAI,CAAC6H,SAAD,EAAY;AACd,WAAO,KAAKF,OAAL,GAAe3H,IAAf,CAAoB6H,SAApB,CAAP;AACD;;AACD1D,EAAAA,SAAS,CAAC0D,SAAD,EAAY;AACnB,WAAO,KAAKF,OAAL,GAAexD,SAAf,CAAyB0D,SAAzB,CAAP;AACD;;AACDvJ,EAAAA,OAAO,CAACwJ,UAAD,EAAa;AAClB,WAAO,KAAKH,OAAL,GAAerJ,OAAf,CAAuBwJ,UAAvB,CAAP;AACD;;AACDrL,EAAAA,GAAG,CAAClF,KAAD,EAAQ;AACT,QAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAI,KAAKiM,MAAL,CAAYrM,MAAtC,EAA8C;AAC5C,aAAO,KAAK,CAAZ;AACD;;AACD,WAAOwG,cAAc,CAAC,KAAK6F,MAAL,CAAYjM,KAAZ,CAAD,CAArB;AACD;;AACD5E,EAAAA,OAAO,CAACoV,aAAD,EAAgBC,SAAhB,EAA2B;AAChC,WAAO,KAAKL,OAAL,GAAehV,OAAf,CAAuBoV,aAAvB,EAAsCC,SAAtC,CAAP;AACD;;AACDC,EAAAA,WAAW,CAACF,aAAD,EAAgBC,SAAhB,EAA2B;AACpC,WAAO,KAAKL,OAAL,GAAeM,WAAf,CAA2BF,aAA3B,EAA0CC,SAA1C,CAAP;AACD;;AACDzL,EAAAA,GAAG,CAACgC,QAAD,EAAW;AACZ,WAAO,KAAKiF,MAAL,CAAYjH,GAAZ,CACL,CAACN,KAAD,EAAQ/E,CAAR,KAAcqH,QAAQ,CACpBZ,cAAc,CAAC1B,KAAD,CADM,EAEpB/E,CAFoB,CADjB,CAAP;AAMD;;AACDgR,EAAAA,IAAI,CAACL,SAAD,EAAY;AACd,WAAO,KAAKF,OAAL,GAAeO,IAAf,CAAoBL,SAApB,CAAP;AACD;;AACe,GAAf3J,MAAM,CAACC,QAAQ,IAAI;AAClB,WAAO,IAAIgK,gBAAJ,CAAqB,KAAK3E,MAA1B,CAAP;AACD;;AACDkC,EAAAA,wBAAwB,CAAC9L,EAAD,EAAK/H,GAAL,EAAU;AAChC,UAAM4T,OAAO,GAAGxI,oBAAoB,CAACrD,EAAD,CAApC;;AACA6L,IAAAA,OAAO,CAACtL,OAAR,CAAgBP,EAAE,CAACQ,EAAnB,EAAuBhF,EAAE,CAAC,KAAKgE,KAAN,CAAzB;;AACAqM,IAAAA,OAAO,CAACzL,cAAR,CAAuB,IAAvB,EAA6BnI,GAA7B;;AACA,SAAKkS,cAAL,CAAoB0B,OAApB;;AACA,UAAMJ,QAAQ,GAAG,KAAKnB,gBAAL,CAAsBrS,GAAtB,CAAjB;;AACA,WAAO;AAAE4T,MAAAA,OAAF;AAAWJ,MAAAA;AAAX,KAAP;AACD;;AACDS,EAAAA,kBAAkB,CAACvO,KAAD,EAAQ1F,GAAR,EAAa;AAC7B,QAAIsU,EAAJ;;AACA,UAAMiC,eAAe,GAAG5R,YAAY,CAClC3E,GADkC,EAElC,KAAK2R,MAAL,CAAYrM,MAAZ,GAAqBI,KAAK,GAAG,CAA7B,GAAiC,CAAC4O,EAAE,GAAG,KAAK3C,MAAL,CAAYjM,KAAK,GAAG,CAApB,CAAN,KAAiC,IAAjC,GAAwC,KAAK,CAA7C,GAAiD4O,EAAE,CAACjN,oBAAH,EAAlF,GAA8G,KAAK,CAFjF,CAApC;;AAIA,SAAKsK,MAAL,CAAYjM,KAAZ,EAAmByC,cAAnB,CAAkC,IAAlC,EAAwCoO,eAAxC;AACD;;AACDzN,EAAAA,WAAW,GAAG;AACZ,WAAO,MAAMA,WAAN,EAAP;AACD;;AACDC,EAAAA,YAAY,GAAG;AACb,UAAM5D,MAAM,GAAG,KAAKwM,MAAL,CAAYjH,GAAZ,CAAiB7D,IAAD,IAAUA,IAAI,CAACiC,WAAL,EAA1B,CAAf;;AACA,WAAO1G,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC6C,MAAxC,GAAiDrG,MAAM,CAACgI,MAAP,CAAc3B,MAAd,CAAxD;AACD;;AA/xBuC,CAA1C;AAiyBA,IAAImR,gBAAgB,GAAG,MAAM;AAC3BnP,EAAAA,WAAW,CAACmH,KAAD,EAAQ;AACjB,SAAKkI,cAAL,GAAsBlI,KAAK,CAACjC,MAAM,CAACC,QAAR,CAAL,EAAtB;AACD;;AACe,GAAfD,MAAM,CAACC,QAAQ,IAAI;AAClB,WAAO,IAAP;AACD;;AACD9K,EAAAA,IAAI,GAAG;AACL,UAAM2D,MAAM,GAAG,KAAKqR,cAAL,CAAoBhV,IAApB,EAAf;;AACA,QAAI2D,MAAM,CAACtD,IAAX,EAAiB;AACf,aAAO;AACLA,QAAAA,IAAI,EAAE,IADD;AAEL5C,QAAAA,KAAK,EAAE,KAAK;AAFP,OAAP;AAID;;AACD,UAAMA,KAAK,GAAG6M,cAAc,CAAC3G,MAAM,CAAClG,KAAR,CAA5B;AACA,WAAO;AAAEA,MAAAA;AAAF,KAAP;AACD;;AAjB0B,CAA7B;;AAmBA,SAAS0T,UAAT,CAAoB8D,QAApB,EAA8BC,YAA9B,EAA4C;AAC1C,SAAO;AACL7P,IAAAA,IAAI,EAAE4P,QADD;AAELzS,IAAAA,IAAI,EAAE,UAFD;AAGL2H,IAAAA,OAAO,EAAE+K;AAHJ,GAAP;AAKD;;AACD,SAAS9D,QAAT,CAAkBlN,KAAlB,EAAyB2D,IAAzB,EAA+B;AAC7B,SAAO;AACL3D,IAAAA,KADK;AAEL1B,IAAAA,IAAI,EAAE,KAFD;AAGLqF,IAAAA,IAAI,EAAEA,IAAI,YAAYL,YAAhB,GAA+BK,IAAI,CAACJ,IAApC,GAA2CI;AAH5C,GAAP;AAKD;;AACD,SAASiK,WAAT,CAAqB5N,KAArB,EAA4B;AAC1B,SAAO;AACLA,IAAAA,KADK;AAEL1B,IAAAA,IAAI,EAAE;AAFD,GAAP;AAID;;AACD,SAASgP,WAAT,CAAqBtN,KAArB,EAA4B2D,IAA5B,EAAkC;AAChC,SAAO;AACL3D,IAAAA,KADK;AAEL1B,IAAAA,IAAI,EAAE,QAFD;AAGLqF,IAAAA,IAAI,EAAEA,IAAI,YAAYL,YAAhB,GAA+BK,IAAI,CAACJ,IAApC,GAA2CI;AAH5C,GAAP;AAKD;;AACD,SAASoK,SAAT,CAAmBF,aAAnB,EAAkC7N,KAAlC,EAAyC2D,IAAzC,EAA+C;AAC7C,SAAO;AACL3D,IAAAA,KADK;AAEL1B,IAAAA,IAAI,EAAE,MAFD;AAGLuP,IAAAA,aAHK;AAILlK,IAAAA,IAAI,EAAEA,IAAI,YAAYL,YAAhB,GAA+BK,IAAI,CAACJ,IAApC,GAA2CI;AAJ5C,GAAP;AAMD;;AACD,SAASqL,gCAAT,CAA0CnK,GAA1C,EAA+CiI,SAA/C,EAA0D;AACxD,MAAIjI,GAAG,CAACjF,MAAJ,KAAe,CAAnB,EAAsB;AACpB,UAAM,IAAIvC,KAAJ,CACJ,2EADI,CAAN;AAGD;;AACD,QAAM4T,OAAO,GAAGpM,GAAG,CAAC,CAAD,CAAnB;AACAoM,EAAAA,OAAO,CAAChC,MAAR,GAAiB,KAAjB;AACAgC,EAAAA,OAAO,CAACnE,SAAR,GAAoBA,SAApB;AACD,C,CAED;;;AACA,IAAIoE,MAAM,GAAG,CACX,oBADW,EAEX,mBAFW,EAGX,WAHW,EAIX,YAJW,EAKX,YALW,EAMX,aANW,CAAb;;AAQA,SAASC,UAAT,CAAoB5N,IAApB,EAA0B;AACxB,MAAI,CAACiH,aAAa,CAACjH,IAAD,CAAlB,EAA0B;AACxB,WAAO,KAAP;AACD;;AACD,QAAM;AAAE6N,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAe9N,IAArB;AACA,SAAO,OAAO6N,GAAP,KAAe,QAAf,IAA2B,OAAOC,GAAP,KAAe,QAAjD;AACD;;AACD,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,QAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,KAAa,GAAzB;AACA,SAAOA,GAAG,GAAGD,KAAK,CAACF,GAAN,GAAY,GAAlB,IAAyBG,GAAG,GAAGD,KAAK,CAACH,GAAN,GAAY,GAAlD;AACD;;AACD,SAASM,OAAT,CAAiBnY,KAAjB,EAAwB;AACtB,SAAO2X,MAAM,CAACS,QAAP,CAAgBpY,KAAhB,CAAP;AACD;;AACD,SAASqY,YAAT,CAAsBrY,KAAtB,EAA6B;AAC3B,SAAO+Q,KAAK,CAACC,OAAN,CAAchR,KAAd,KAAwBA,KAAK,CAAC8W,KAAN,CAAa1Q,CAAD,IAAO,OAAOA,CAAP,KAAa,QAAhC,CAA/B;AACD;;AACD,SAASkS,kBAAT,CAA4BtO,IAA5B,EAAkC;AAChC,SAAO,OAAOA,IAAI,CAACuO,KAAZ,KAAsB,QAAtB,IAAkCvO,IAAI,CAACxB,MAAL,KAAgB,KAAK,CAAvD,IAA4D6P,YAAY,CAACrO,IAAI,CAACwO,MAAN,CAA/E;AACD;;AACD,SAASC,eAAT,CAAyBzO,IAAzB,EAA+B;AAC7B,SAAO,OAAOA,IAAI,CAACuO,KAAZ,KAAsB,QAAtB,IAAkC,OAAOvO,IAAI,CAACxB,MAAZ,KAAuB,QAAzD,IAAqE,OAAOwB,IAAI,CAAC0O,KAAZ,KAAsB,QAA3F,KAAwG1O,IAAI,CAACV,EAAL,KAAY,KAAK,CAAjB,IAAsB,OAAOU,IAAI,CAACV,EAAZ,KAAmB,QAAjJ,KAA8J+O,YAAY,CAACrO,IAAI,CAACwO,MAAN,CAA1K,KAA4LxO,IAAI,CAAC2O,qBAAL,KAA+B,KAAK,CAApC,IAAyC,OAAO3O,IAAI,CAAC2O,qBAAZ,KAAsC,QAA3Q,CAAP;AACD;;AACD,SAASC,WAAT,CAAqB5O,IAArB,EAA2B;AACzB,SAAOsO,kBAAkB,CAACtO,IAAD,CAAlB,IAA4ByO,eAAe,CAACzO,IAAD,CAAlD;AACD;;AACD,SAAS6O,aAAT,CAAuBb,KAAvB,EAA8B;AAC5B,QAAMc,UAAU,GAAGd,KAAK,CAAC5F,KAAN,CAAY,GAAZ,CAAnB;;AACA,MAAI0G,UAAU,CAACzS,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,UAAM,IAAIvC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,QAAMkG,IAAI,GAAG0H,YAAY,CAACG,SAAS,CAACiH,UAAU,CAAC,CAAD,CAAX,CAAV,CAAzB;;AACA,MAAI9O,IAAI,IAAI4N,UAAU,CAAC5N,IAAD,CAAtB,EAA8B;AAC5B,WAAOA,IAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAIlG,KAAJ,CAAU,4CAAV,CAAN;AACD;AACF;;AACD,SAASiV,kBAAT,CAA4BC,WAA5B,EAAyC;AACvC,QAAMhP,IAAI,GAAG6O,aAAa,CAACG,WAAD,CAA1B;;AACA,MAAIhP,IAAI,IAAIyO,eAAe,CAACzO,IAAD,CAA3B,EAAmC;AACjC,UAAMqL,EAAE,GAAGrL,IAAX;AAAA,UAAiB;AACfiP,MAAAA,cAAc,EAAEC;AADD,QAEb7D,EAFJ;AAAA,UAEQ2C,KAAK,GAAGvW,SAAS,CAAC4T,EAAD,EAAK,CAC5B,gBAD4B,CAAL,CAFzB;;AAKA,WAAO2C,KAAP;AACD,GAPD,MAOO;AACL,UAAM,IAAIlU,KAAJ,CACJ,iQADI,CAAN;AAGD;AACF,C,CAED;;;AACA,SAASqV,wBAAT,CAAkCC,GAAlC,EAAuC;AACrCvZ,EAAAA,MAAM,CAACC,cAAP,CAAsBsZ,GAAtB,EAA2B,OAA3B,EAAoC;AAClCpZ,IAAAA,KAAK,EAAEoZ,GAAG,CAAC/S,MADuB;AAElCrF,IAAAA,UAAU,EAAE;AAFsB,GAApC;AAIAnB,EAAAA,MAAM,CAACC,cAAP,CAAsBsZ,GAAtB,EAA2B,SAA3B,EAAsC;AACpCpZ,IAAAA,KAAK,EAAE,MAAMoZ,GADuB;AAEpCpY,IAAAA,UAAU,EAAE;AAFwB,GAAtC;AAIA,SAAO6G,MAAM,CAACuR,GAAD,CAAb;AACD,C,CAED;;;AACA,SAASC,YAAT,CAAsBrP,IAAtB,EAA4B;AAC1B,SAAOA,IAAI,KAAK,IAAT,IAAiB,OAAOA,IAAP,KAAgB,QAAjC,IAA6C,OAAOA,IAAP,KAAgB,QAA7D,IAAyE,OAAOA,IAAP,KAAgB,SAAhG;AACD;;AACD,SAASsP,WAAT,CAAqBtP,IAArB,EAA2B;AACzB,SAAO+G,KAAK,CAACC,OAAN,CAAchH,IAAd,CAAP;AACD;;AACD,SAASuP,YAAT,CAAsBvP,IAAtB,EAA4B;AAC1B,SAAO,CAACqP,YAAY,CAACrP,IAAD,CAAb,IAAuB,CAACsP,WAAW,CAACtP,IAAD,CAA1C;AACD;;AAiDDjK,OAAO,CAACoB,cAAR,GAAyBA,cAAzB;AAAyCpB,OAAO,CAACyB,aAAR,GAAwBA,aAAxB;AAAuCzB,OAAO,CAAC+B,OAAR,GAAkBA,OAAlB;AAA2B/B,OAAO,CAACkD,SAAR,GAAoBA,SAApB;AAA+BlD,OAAO,CAAC2D,WAAR,GAAsBA,WAAtB;AAAmC3D,OAAO,CAAC6D,eAAR,GAA0BA,eAA1B;AAA2C7D,OAAO,CAACiE,OAAR,GAAkBA,OAAlB;AAA2BjE,OAAO,CAACkE,WAAR,GAAsBA,WAAtB;AAAmClE,OAAO,CAACuE,EAAR,GAAaA,EAAb;AAAiBvE,OAAO,CAACwE,aAAR,GAAwBA,aAAxB;AAAuCxE,OAAO,CAAC0E,MAAR,GAAiBA,MAAjB;AAAyB1E,OAAO,CAAC4E,QAAR,GAAmBA,QAAnB;AAA6B5E,OAAO,CAAC8E,UAAR,GAAqBA,UAArB;AAAiC9E,OAAO,CAACiF,WAAR,GAAsBA,WAAtB;AAAmCjF,OAAO,CAACoF,aAAR,GAAwBA,aAAxB;AAAuCpF,OAAO,CAACsF,eAAR,GAA0BA,eAA1B;AAA2CtF,OAAO,CAACuF,mBAAR,GAA8BA,mBAA9B;AAAmDvF,OAAO,CAACgK,YAAR,GAAuBA,YAAvB;AAAqChK,OAAO,CAAC2F,YAAR,GAAuBA,YAAvB;AAAqC3F,OAAO,CAACoH,eAAR,GAA0BA,eAA1B;AAA2CpH,OAAO,CAAC2P,QAAR,GAAmBA,QAAnB;AAA6B3P,OAAO,CAAC+K,OAAR,GAAkBA,OAAlB;AAA2B/K,OAAO,CAAC2N,UAAR,GAAqBA,UAArB;AAAiC3N,OAAO,CAAC8H,MAAR,GAAiBA,MAAjB;AAAyB9H,OAAO,CAACqP,OAAR,GAAkBA,OAAlB;AAA2BrP,OAAO,CAACwP,aAAR,GAAwBA,aAAxB;AAAuCxP,OAAO,CAAC4P,mBAAR,GAA8BA,mBAA9B;AAAmD5P,OAAO,CAACkM,UAAR,GAAqBA,UAArB;AAAiClM,OAAO,CAAC6P,UAAR,GAAqBA,UAArB;AAAiC7P,OAAO,CAAC+P,YAAR,GAAuBA,YAAvB;AAAqC/P,OAAO,CAACiQ,sBAAR,GAAiCA,sBAAjC;AAAyDjQ,OAAO,CAAC8Q,mBAAR,GAA8BA,mBAA9B;AAAmD9Q,OAAO,CAACkR,aAAR,GAAwBA,aAAxB;AAAuClR,OAAO,CAACqR,wBAAR,GAAmCA,wBAAnC;AAA6DrR,OAAO,CAAC2R,YAAR,GAAuBA,YAAvB;AAAqC3R,OAAO,CAAC8R,SAAR,GAAoBA,SAApB;AAA+B9R,OAAO,CAACgY,cAAR,GAAyBA,cAAzB;AAAyChY,OAAO,CAACoY,OAAR,GAAkBA,OAAlB;AAA2BpY,OAAO,CAACuY,kBAAR,GAA6BA,kBAA7B;AAAiDvY,OAAO,CAAC0Y,eAAR,GAA0BA,eAA1B;AAA2C1Y,OAAO,CAAC6Y,WAAR,GAAsBA,WAAtB;AAAmC7Y,OAAO,CAACgZ,kBAAR,GAA6BA,kBAA7B;AAAiDhZ,OAAO,CAACoZ,wBAAR,GAAmCA,wBAAnC;AAA6DpZ,OAAO,CAACsZ,YAAR,GAAuBA,YAAvB;AAAqCtZ,OAAO,CAACuZ,WAAR,GAAsBA,WAAtB;AAAmCvZ,OAAO,CAACwZ,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true});var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      console.error(`DEPRECATION WARNING: ${message}`);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (process.env.NODE_ENV !== \"production\" && !condition) {\n    const err = new Error(errmsg);\n    err.name = \"Assertion failure\";\n    throw err;\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/types/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/types/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\n\n// src/types/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/types/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/index.ts\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"connection\" || value === \"history\";\n}\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\n\n// src/position.ts\nvar min = 32;\nvar max = 126;\nfunction makePosition(before, after) {\n  if (before !== void 0 && after !== void 0) {\n    return pos(makePositionFromCodes(posCodes(before), posCodes(after)));\n  } else if (before !== void 0) {\n    return getNextPosition(before);\n  } else if (after !== void 0) {\n    return getPreviousPosition(after);\n  }\n  return pos([min + 1]);\n}\nfunction getPreviousPosition(after) {\n  const result = [];\n  const afterCodes = posCodes(after);\n  for (let i = 0; i < afterCodes.length; i++) {\n    const code = afterCodes[i];\n    if (code <= min + 1) {\n      result.push(min);\n      if (afterCodes.length - 1 === i) {\n        result.push(max);\n        break;\n      }\n    } else {\n      result.push(code - 1);\n      break;\n    }\n  }\n  return pos(result);\n}\nfunction getNextPosition(before) {\n  const result = [];\n  const beforeCodes = posCodes(before);\n  for (let i = 0; i < beforeCodes.length; i++) {\n    const code = beforeCodes[i];\n    if (code === max) {\n      result.push(code);\n      if (beforeCodes.length - 1 === i) {\n        result.push(min + 1);\n        break;\n      }\n    } else {\n      result.push(code + 1);\n      break;\n    }\n  }\n  return pos(result);\n}\nfunction makePositionFromCodes(before, after) {\n  let index = 0;\n  const result = [];\n  while (true) {\n    const beforeDigit = before[index] || min;\n    const afterDigit = after[index] || max;\n    if (beforeDigit > afterDigit) {\n      throw new Error(\n        `Impossible to generate position between ${before} and ${after}`\n      );\n    }\n    if (beforeDigit === afterDigit) {\n      result.push(beforeDigit);\n      index++;\n      continue;\n    }\n    if (afterDigit - beforeDigit === 1) {\n      result.push(beforeDigit);\n      result.push(...makePositionFromCodes(before.slice(index + 1), []));\n      break;\n    }\n    const mid = afterDigit + beforeDigit >> 1;\n    result.push(mid);\n    break;\n  }\n  return result;\n}\nfunction posCodes(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    codes.push(str.charCodeAt(i));\n  }\n  return codes;\n}\nfunction pos(codes) {\n  return String.fromCharCode(...codes);\n}\nfunction comparePosition(posA, posB) {\n  const aCodes = posCodes(posA);\n  const bCodes = posCodes(posB);\n  const maxLength = Math.max(aCodes.length, bCodes.length);\n  for (let i = 0; i < maxLength; i++) {\n    const a = aCodes[i] === void 0 ? min : aCodes[i];\n    const b = bCodes[i] === void 0 ? min : bCodes[i];\n    if (a === b) {\n      continue;\n    } else {\n      return a - b;\n    }\n  }\n  throw new Error(\n    `Impossible to compare similar position \"${posA}\" and \"${posB}\"`\n  );\n}\n\n// src/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key) {\n  return Object.freeze({ type: \"HasParent\", node, key });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey) {\n  return Object.freeze({ type: \"Orphaned\", oldKey });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    this._parent = NoParent;\n  }\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  get _id() {\n    return this.__id;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get _parentNode() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.node;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return null;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        this._parent = Orphaned(this.parent.oldKey);\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  invalidate() {\n    if (this._cachedImmutable !== void 0) {\n      this._cachedImmutable = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/LiveRegister.ts\nvar LiveRegister = class extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool == null ? void 0 : pool.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  _toImmutable() {\n    return this._data;\n  }\n};\n\n// src/LiveMap.ts\nvar LiveMap = class extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const entry of entries2) {\n        const value = lsonToLiveNode(entry[1]);\n        value._setParentLink(this, entry[0]);\n        mappedEntries.push([entry[0], value]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool == null ? void 0 : pool.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  set(key, value) {\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  get size() {\n    return this._map.size;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  delete(key) {\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  keys() {\n    return this._map.keys();\n  }\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n};\n\n// src/LiveObject.ts\nvar LiveObject = class extends AbstractCrdt {\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    for (const key in obj) {\n      const value = obj[key];\n      if (value === void 0) {\n        continue;\n      } else if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(obj));\n  }\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool == null ? void 0 : pool.generateOpId();\n    const ops = [];\n    const op = parentId !== void 0 && parentKey !== void 0 ? {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    } : { type: 4 /* CREATE_OBJECT */, id: this._id, opId, data: {} };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op);\n    }\n    return super._apply(op, isLocal);\n  }\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    reverse.push(reverseUpdate);\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  _applyDeleteObjectKey(op) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  toObject() {\n    return fromEntries(this._map);\n  }\n  set(key, value) {\n    this.update({ [key]: value });\n  }\n  get(key) {\n    return this._map.get(key);\n  }\n  delete(key) {\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  update(patch) {\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n};\n\n// src/utils.ts\nvar freeze = process.env.NODE_ENV === \"production\" ? (x) => x : Object.freeze;\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = __spreadValues({}, obj);\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList();\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          ops.push(\n            crdt.parentId ? {\n              type: 4 /* CREATE_OBJECT */,\n              id,\n              parentId: crdt.parentId,\n              parentKey: crdt.parentKey,\n              data: crdt.data\n            } : { type: 4 /* CREATE_OBJECT */, id, data: crdt.data }\n          );\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return __spreadProps(__spreadValues({}, second), {\n    updates\n  });\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return __spreadProps(__spreadValues({}, second), {\n    updates\n  });\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return __spreadProps(__spreadValues({}, second), {\n    updates: updates.concat(second.updates)\n  });\n}\nfunction mergeStorageUpdates(first, second) {\n  if (!first) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\nfunction fromEntries(iterable) {\n  const obj = {};\n  for (const [key, val] of iterable) {\n    obj[key] = val;\n  }\n  return obj;\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\n\n// src/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  return comparePosition(\n    itemA._getParentKeyOrThrow(),\n    itemB._getParentKeyOrThrow()\n  );\n}\nvar LiveList = class extends AbstractCrdt {\n  constructor(items = []) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (let i = 0; i < items.length; i++) {\n      const newPosition = makePosition(position);\n      const item = lsonToLiveNode(items[i]);\n      item._setParentLink(this, newPosition);\n      this._items.push(item);\n      position = newPosition;\n    }\n  }\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new LiveList();\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool == null ? void 0 : pool.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      ops.push(...item._toOps(this._id, item._getParentKeyOrThrow(), pool));\n    }\n    return ops;\n  }\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = op.parentKey;\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = op.parentKey;\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  _applyInsertUndoRedo(op) {\n    var _a;\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before = this._items[existingItemIndex] ? this._items[existingItemIndex]._getParentKeyOrThrow() : void 0;\n      const after = this._items[existingItemIndex + 1] ? this._items[existingItemIndex + 1]._getParentKeyOrThrow() : void 0;\n      newKey = makePosition(before, after);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  _applySetUndoRedo(op) {\n    var _a;\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (((_a = this._pool) == null ? void 0 : _a.getNode(id)) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = existingItem._toOps(nn(this._id), key, this._pool);\n      addIntentAndDeletedIdToOperation(reverse, op.id);\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  _applySetChildKeyRemote(newKey, child) {\n    var _a;\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(\n          newKey,\n          (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()\n        )\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  _applySetChildKeyAck(newKey, child) {\n    var _a, _b;\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(\n            newKey,\n            (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()\n          )\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(\n            newKey,\n            (_b = this._items[existingItemIndex + 1]) == null ? void 0 : _b._getParentKeyOrThrow()\n          )\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  _applySetChildKeyUndoRedo(newKey, child) {\n    var _a;\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(\n          newKey,\n          (_a = this._items[existingItemIndex + 1]) == null ? void 0 : _a._getParentKeyOrThrow()\n        )\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  get length() {\n    return this._items.length;\n  }\n  push(element) {\n    return this.insert(element, this.length);\n  }\n  insert(element, index) {\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before = this._items[index - 1] ? this._items[index - 1]._getParentKeyOrThrow() : void 0;\n    const after = this._items[index] ? this._items[index]._getParentKeyOrThrow() : void 0;\n    const position = makePosition(before, after);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  move(index, targetIndex) {\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._getParentKeyOrThrow();\n      beforePosition = this._items[targetIndex]._getParentKeyOrThrow();\n    } else {\n      afterPosition = this._items[targetIndex]._getParentKeyOrThrow();\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._getParentKeyOrThrow();\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  delete(index) {\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = value._toOps(this._id, position, this._pool);\n      addIntentAndDeletedIdToOperation(ops, existingId);\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = existingItem._toOps(this._id, position, void 0);\n      addIntentAndDeletedIdToOperation(reverseOps, id);\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n    );\n  }\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        i\n      )\n    );\n  }\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  _shiftItemPosition(index, key) {\n    var _a;\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? (_a = this._items[index + 1]) == null ? void 0 : _a._getParentKeyOrThrow() : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction addIntentAndDeletedIdToOperation(ops, deletedId) {\n  if (ops.length === 0) {\n    throw new Error(\n      \"Internal error. Serialized LiveStructure should have at least 1 operation\"\n    );\n  }\n  const firstOp = ops[0];\n  firstOp.intent = \"set\";\n  firstOp.deletedId = deletedId;\n}\n\n// src/AuthToken.ts\nvar SCOPES = [\n  \"websocket:presence\",\n  \"websocket:storage\",\n  \"room:read\",\n  \"room:write\",\n  \"rooms:read\",\n  \"rooms:write\"\n];\nfunction hasJwtMeta(data) {\n  if (!isPlainObject(data)) {\n    return false;\n  }\n  const { iat, exp } = data;\n  return typeof iat === \"number\" && typeof exp === \"number\";\n}\nfunction isTokenExpired(token) {\n  const now = Date.now() / 1e3;\n  return now > token.exp - 300 || now < token.iat + 300;\n}\nfunction isScope(value) {\n  return SCOPES.includes(value);\n}\nfunction isStringList(value) {\n  return Array.isArray(value) && value.every((i) => typeof i === \"string\");\n}\nfunction isAppOnlyAuthToken(data) {\n  return typeof data.appId === \"string\" && data.roomId === void 0 && isStringList(data.scopes);\n}\nfunction isRoomAuthToken(data) {\n  return typeof data.appId === \"string\" && typeof data.roomId === \"string\" && typeof data.actor === \"number\" && (data.id === void 0 || typeof data.id === \"string\") && isStringList(data.scopes) && (data.maxConnectionsPerRoom === void 0 || typeof data.maxConnectionsPerRoom === \"number\");\n}\nfunction isAuthToken(data) {\n  return isAppOnlyAuthToken(data) || isRoomAuthToken(data);\n}\nfunction parseJwtToken(token) {\n  const tokenParts = token.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const data = tryParseJson(b64decode(tokenParts[1]));\n  if (data && hasJwtMeta(data)) {\n    return data;\n  } else {\n    throw new Error(\"Authentication error: missing JWT metadata\");\n  }\n}\nfunction parseRoomAuthToken(tokenString) {\n  const data = parseJwtToken(tokenString);\n  if (data && isRoomAuthToken(data)) {\n    const _a = data, {\n      maxConnections: _legacyField\n    } = _a, token = __objRest(_a, [\n      \"maxConnections\"\n    ]);\n    return token;\n  } else {\n    throw new Error(\n      \"Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n}\n\n// src/LegacyArray.ts\nfunction asArrayWithLegacyMethods(arr) {\n  Object.defineProperty(arr, \"count\", {\n    value: arr.length,\n    enumerable: false\n  });\n  Object.defineProperty(arr, \"toArray\", {\n    value: () => arr,\n    enumerable: false\n  });\n  return freeze(arr);\n}\n\n// src/types/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexports.__spreadValues = __spreadValues; exports.__spreadProps = __spreadProps; exports.__async = __async; exports.deprecate = deprecate; exports.deprecateIf = deprecateIf; exports.throwUsageError = throwUsageError; exports.errorIf = errorIf; exports.assertNever = assertNever; exports.nn = nn; exports.ClientMsgCode = ClientMsgCode; exports.OpCode = OpCode; exports.CrdtType = CrdtType; exports.isRootCrdt = isRootCrdt; exports.isChildCrdt = isChildCrdt; exports.ServerMsgCode = ServerMsgCode; exports.isRoomEventName = isRoomEventName; exports.WebsocketCloseCodes = WebsocketCloseCodes; exports.LiveRegister = LiveRegister; exports.makePosition = makePosition; exports.comparePosition = comparePosition; exports.LiveList = LiveList; exports.LiveMap = LiveMap; exports.LiveObject = LiveObject; exports.freeze = freeze; exports.compact = compact; exports.compactObject = compactObject; exports.isSameNodeOrChildOf = isSameNodeOrChildOf; exports.isLiveNode = isLiveNode; exports.isLiveList = isLiveList; exports.isLiveObject = isLiveObject; exports.getTreesDiffOperations = getTreesDiffOperations; exports.mergeStorageUpdates = mergeStorageUpdates; exports.isPlainObject = isPlainObject; exports.findNonSerializableValue = findNonSerializableValue; exports.tryParseJson = tryParseJson; exports.b64decode = b64decode; exports.isTokenExpired = isTokenExpired; exports.isScope = isScope; exports.isAppOnlyAuthToken = isAppOnlyAuthToken; exports.isRoomAuthToken = isRoomAuthToken; exports.isAuthToken = isAuthToken; exports.parseRoomAuthToken = parseRoomAuthToken; exports.asArrayWithLegacyMethods = asArrayWithLegacyMethods; exports.isJsonScalar = isJsonScalar; exports.isJsonArray = isJsonArray; exports.isJsonObject = isJsonObject;\n"]},"metadata":{},"sourceType":"script"}